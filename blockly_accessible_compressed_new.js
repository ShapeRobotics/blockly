// Do not edit this file; automatically generated by build.py.
'use strict';

var COMPILED = false;
var goog = goog || {};
goog.global = this;
goog.global.CLOSURE_UNCOMPILED_DEFINES;
goog.global.CLOSURE_DEFINES;
goog.isDef = function(val) {
    return val !== void 0
};
goog.isString = function(val) {
    return typeof val == "string"
};
goog.isBoolean = function(val) {
    return typeof val == "boolean"
};
goog.isNumber = function(val) {
    return typeof val == "number"
};
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
    var parts = name.split(".");
    var cur = opt_objectToExportTo || goog.global;
    if (!(parts[0] in cur) && typeof cur.execScript != "undefined") cur.execScript("var " + parts[0]);
    for (var part; parts.length && (part = parts.shift());)
        if (!parts.length && goog.isDef(opt_object)) cur[part] = opt_object;
        else if (cur[part] && cur[part] !== Object.prototype[part]) cur = cur[part];
    else cur = cur[part] = {}
};
goog.define = function(name, defaultValue) {
    var value = defaultValue;
    if (!COMPILED) {
        var uncompiledDefines = goog.global.CLOSURE_UNCOMPILED_DEFINES;
        var defines = goog.global.CLOSURE_DEFINES;
        if (uncompiledDefines && uncompiledDefines.nodeType === undefined && Object.prototype.hasOwnProperty.call(uncompiledDefines, name)) value = uncompiledDefines[name];
        else if (defines && defines.nodeType === undefined && Object.prototype.hasOwnProperty.call(defines, name)) value = defines[name]
    }
    goog.exportPath_(name, value)
};
goog.define("goog.DEBUG", true);
goog.define("goog.LOCALE", "en");
goog.define("goog.TRUSTED_SITE", true);
goog.define("goog.STRICT_MODE_COMPATIBLE", false);
goog.define("goog.DISALLOW_TEST_ONLY_CODE", COMPILED && !goog.DEBUG);
goog.define("goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING", false);
goog.provide = function(name) {
    if (goog.isInModuleLoader_()) throw new Error("goog.provide cannot be used within a module.");
    if (!COMPILED)
        if (goog.isProvided_(name)) throw new Error('Namespace "' + name + '" already declared.');
    goog.constructNamespace_(name)
};
goog.constructNamespace_ = function(name, opt_obj) {
    if (!COMPILED) {
        delete goog.implicitNamespaces_[name];
        var namespace = name;
        while (namespace = namespace.substring(0, namespace.lastIndexOf("."))) {
            if (goog.getObjectByName(namespace)) break;
            goog.implicitNamespaces_[namespace] = true
        }
    }
    goog.exportPath_(name, opt_obj)
};
goog.getScriptNonce = function(opt_window) {
    if (opt_window && opt_window != goog.global) return goog.getScriptNonce_(opt_window.document);
    if (goog.cspNonce_ === null) goog.cspNonce_ = goog.getScriptNonce_(goog.global.document);
    return goog.cspNonce_
};
goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/;
goog.cspNonce_ = null;
goog.getScriptNonce_ = function(doc) {
    var script = doc.querySelector && doc.querySelector("script[nonce]");
    if (script) {
        var nonce = script["nonce"] || script.getAttribute("nonce");
        if (nonce && goog.NONCE_PATTERN_.test(nonce)) return nonce
    }
    return ""
};
goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
goog.module = function(name) {
    if (!goog.isString(name) || !name || name.search(goog.VALID_MODULE_RE_) == -1) throw new Error("Invalid module identifier");
    if (!goog.isInGoogModuleLoader_()) throw new Error("Module " + name + " has been loaded incorrectly. Note, " + "modules cannot be loaded as normal scripts. They require some kind of " + "pre-processing step. You're likely trying to load a module via a " + "script tag or as a part of a concatenated bundle without rewriting the " + "module. For more info see: " + "https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
    if (goog.moduleLoaderState_.moduleName) throw new Error("goog.module may only be called once per module.");
    goog.moduleLoaderState_.moduleName = name;
    if (!COMPILED) {
        if (goog.isProvided_(name)) throw new Error('Namespace "' + name + '" already declared.');
        delete goog.implicitNamespaces_[name]
    }
};
goog.module.get = function(name) {
    return goog.module.getInternal_(name)
};
goog.module.getInternal_ = function(name) {
    if (!COMPILED)
        if (name in goog.loadedModules_) return goog.loadedModules_[name].exports;
        else if (!goog.implicitNamespaces_[name]) {
        var ns = goog.getObjectByName(name);
        return ns != null ? ns : null
    }
    return null
};
goog.ModuleType = {
    ES6: "es6",
    GOOG: "goog"
};
goog.moduleLoaderState_ = null;
goog.isInModuleLoader_ = function() {
    return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_()
};
goog.isInGoogModuleLoader_ = function() {
    return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG
};
goog.isInEs6ModuleLoader_ = function() {
    var inLoader = !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6;
    if (inLoader) return true;
    var jscomp = goog.global["$jscomp"];
    if (jscomp) {
        if (typeof jscomp.getCurrentModulePath != "function") return false;
        return !!jscomp.getCurrentModulePath()
    }
    return false
};
goog.module.declareLegacyNamespace = function() {
    if (!COMPILED && !goog.isInGoogModuleLoader_()) throw new Error("goog.module.declareLegacyNamespace must be called from " + "within a goog.module");
    if (!COMPILED && !goog.moduleLoaderState_.moduleName) throw new Error("goog.module must be called prior to " + "goog.module.declareLegacyNamespace.");
    goog.moduleLoaderState_.declareLegacyNamespace = true
};
goog.declareModuleId = function(namespace) {
    if (!COMPILED) {
        if (!goog.isInEs6ModuleLoader_()) throw new Error("goog.declareModuleId may only be called from " + "within an ES6 module");
        if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName) throw new Error("goog.declareModuleId may only be called once per module.");
        if (namespace in goog.loadedModules_) throw new Error('Module with namespace "' + namespace + '" already exists.');
    }
    if (goog.moduleLoaderState_) goog.moduleLoaderState_.moduleName = namespace;
    else {
        var jscomp =
            goog.global["$jscomp"];
        if (!jscomp || typeof jscomp.getCurrentModulePath != "function") throw new Error('Module with namespace "' + namespace + '" has been loaded incorrectly.');
        var exports = jscomp.require(jscomp.getCurrentModulePath());
        goog.loadedModules_[namespace] = {
            exports: exports,
            type: goog.ModuleType.ES6,
            moduleId: namespace
        }
    }
};
goog.module.declareNamespace = goog.declareModuleId;
goog.setTestOnly = function(opt_message) {
    if (goog.DISALLOW_TEST_ONLY_CODE) {
        opt_message = opt_message || "";
        throw new Error("Importing test-only code into non-debug environment" + (opt_message ? ": " + opt_message : "."));
    }
};
goog.forwardDeclare = function(name) {};
goog.forwardDeclare("Document");
goog.forwardDeclare("HTMLScriptElement");
goog.forwardDeclare("XMLHttpRequest");
if (!COMPILED) {
    goog.isProvided_ = function(name) {
        return name in goog.loadedModules_ || !goog.implicitNamespaces_[name] && goog.isDefAndNotNull(goog.getObjectByName(name))
    };
    goog.implicitNamespaces_ = {
        "goog.module": true
    }
}
goog.getObjectByName = function(name, opt_obj) {
    var parts = name.split(".");
    var cur = opt_obj || goog.global;
    for (var i = 0; i < parts.length; i++) {
        cur = cur[parts[i]];
        if (!goog.isDefAndNotNull(cur)) return null
    }
    return cur
};
goog.globalize = function(obj, opt_global) {
    var global = opt_global || goog.global;
    for (var x in obj) global[x] = obj[x]
};
goog.addDependency = function(relPath, provides, requires, opt_loadFlags) {
    if (!COMPILED && goog.DEPENDENCIES_ENABLED) goog.debugLoader_.addDependency(relPath, provides, requires, opt_loadFlags)
};
goog.define("goog.ENABLE_DEBUG_LOADER", true);
goog.logToConsole_ = function(msg) {
    if (goog.global.console) goog.global.console["error"](msg)
};
goog.require = function(namespace) {
    if (!COMPILED) {
        if (goog.ENABLE_DEBUG_LOADER) goog.debugLoader_.requested(namespace);
        if (goog.isProvided_(namespace)) {
            if (goog.isInModuleLoader_()) return goog.module.getInternal_(namespace)
        } else if (goog.ENABLE_DEBUG_LOADER) {
            var moduleLoaderState = goog.moduleLoaderState_;
            goog.moduleLoaderState_ = null;
            try {
                goog.debugLoader_.load_(namespace)
            } finally {
                goog.moduleLoaderState_ = moduleLoaderState
            }
        }
        return null
    }
};
goog.requireType = function(namespace) {
    return {}
};
goog.basePath = "";
goog.global.CLOSURE_BASE_PATH;
goog.global.CLOSURE_NO_DEPS;
goog.global.CLOSURE_IMPORT_SCRIPT;
goog.nullFunction = function() {};
goog.abstractMethod = function() {
    throw new Error("unimplemented abstract method");
};
goog.addSingletonGetter = function(ctor) {
    ctor.instance_ = undefined;
    ctor.getInstance = function() {
        if (ctor.instance_) return ctor.instance_;
        if (goog.DEBUG) goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
        return ctor.instance_ = new ctor
    }
};
goog.instantiatedSingletons_ = [];
goog.define("goog.LOAD_MODULE_USING_EVAL", true);
goog.define("goog.SEAL_MODULE_EXPORTS", goog.DEBUG);
goog.loadedModules_ = {};
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
goog.define("goog.TRANSPILE", "detect");
goog.define("goog.TRANSPILE_TO_LANGUAGE", "");
goog.define("goog.TRANSPILER", "transpile.js");
goog.hasBadLetScoping = null;
goog.useSafari10Workaround = function() {
    if (goog.hasBadLetScoping == null) {
        var hasBadLetScoping;
        try {
            hasBadLetScoping = !eval('"use strict";' + "let x = 1; function f() { return typeof x; };" + 'f() == "number";')
        } catch (e) {
            hasBadLetScoping = false
        }
        goog.hasBadLetScoping = hasBadLetScoping
    }
    return goog.hasBadLetScoping
};
goog.workaroundSafari10EvalBug = function(moduleDef) {
    return "(function(){" + moduleDef + "\n" + ";" + "})();\n"
};
goog.loadModule = function(moduleDef) {
    var previousState = goog.moduleLoaderState_;
    try {
        goog.moduleLoaderState_ = {
            moduleName: "",
            declareLegacyNamespace: false,
            type: goog.ModuleType.GOOG
        };
        var exports;
        if (goog.isFunction(moduleDef)) exports = moduleDef.call(undefined, {});
        else if (goog.isString(moduleDef)) {
            if (goog.useSafari10Workaround()) moduleDef = goog.workaroundSafari10EvalBug(moduleDef);
            exports = goog.loadModuleFromSource_.call(undefined, moduleDef)
        } else throw new Error("Invalid module definition");
        var moduleName = goog.moduleLoaderState_.moduleName;
        if (goog.isString(moduleName) && moduleName) {
            if (goog.moduleLoaderState_.declareLegacyNamespace) goog.constructNamespace_(moduleName, exports);
            else if (goog.SEAL_MODULE_EXPORTS && Object.seal && typeof exports == "object" && exports != null) Object.seal(exports);
            var data = {
                exports: exports,
                type: goog.ModuleType.GOOG,
                moduleId: goog.moduleLoaderState_.moduleName
            };
            goog.loadedModules_[moduleName] = data
        } else throw new Error('Invalid module name "' + moduleName + '"');
    } finally {
        goog.moduleLoaderState_ = previousState
    }
};
goog.loadModuleFromSource_ = function() {
    var exports = {};
    eval(arguments[0]);
    return exports
};
goog.normalizePath_ = function(path) {
    var components = path.split("/");
    var i = 0;
    while (i < components.length)
        if (components[i] == ".") components.splice(i, 1);
        else if (i && components[i] == ".." && components[i - 1] && components[i - 1] != "..") components.splice(--i, 2);
    else i++;
    return components.join("/")
};
goog.global.CLOSURE_LOAD_FILE_SYNC;
goog.loadFileSync_ = function(src) {
    if (goog.global.CLOSURE_LOAD_FILE_SYNC) return goog.global.CLOSURE_LOAD_FILE_SYNC(src);
    else try {
        var xhr = new goog.global["XMLHttpRequest"];
        xhr.open("get", src, false);
        xhr.send();
        return xhr.status == 0 || xhr.status == 200 ? xhr.responseText : null
    } catch (err) {
        return null
    }
};
goog.transpile_ = function(code, path, target) {
    var jscomp = goog.global["$jscomp"];
    if (!jscomp) goog.global["$jscomp"] = jscomp = {};
    var transpile = jscomp.transpile;
    if (!transpile) {
        var transpilerPath = goog.basePath + goog.TRANSPILER;
        var transpilerCode = goog.loadFileSync_(transpilerPath);
        if (transpilerCode) {
            (function() {
                eval(transpilerCode + "\n//# sourceURL=" + transpilerPath)
            }).call(goog.global);
            if (goog.global["$gwtExport"] && goog.global["$gwtExport"]["$jscomp"] && !goog.global["$gwtExport"]["$jscomp"]["transpile"]) throw new Error('The transpiler did not properly export the "transpile" ' +
                "method. $gwtExport: " + JSON.stringify(goog.global["$gwtExport"]));
            goog.global["$jscomp"].transpile = goog.global["$gwtExport"]["$jscomp"]["transpile"];
            jscomp = goog.global["$jscomp"];
            transpile = jscomp.transpile
        }
    }
    if (!transpile) {
        var suffix = " requires transpilation but no transpiler was found.";
        transpile = jscomp.transpile = function(code, path) {
            goog.logToConsole_(path + suffix);
            return code
        }
    }
    return transpile(code, path, target)
};
goog.typeOf = function(value) {
    var s = typeof value;
    if (s == "object")
        if (value) {
            if (value instanceof Array) return "array";
            else if (value instanceof Object) return s;
            var className = Object.prototype.toString.call(value);
            if (className == "[object Window]") return "object";
            if (className == "[object Array]" || typeof value.length == "number" && typeof value.splice != "undefined" && typeof value.propertyIsEnumerable != "undefined" && !value.propertyIsEnumerable("splice")) return "array";
            if (className == "[object Function]" || typeof value.call !=
                "undefined" && typeof value.propertyIsEnumerable != "undefined" && !value.propertyIsEnumerable("call")) return "function"
        } else return "null";
    else if (s == "function" && typeof value.call == "undefined") return "object";
    return s
};
goog.isNull = function(val) {
    return val === null
};
goog.isDefAndNotNull = function(val) {
    return val != null
};
goog.isArray = function(val) {
    return goog.typeOf(val) == "array"
};
goog.isArrayLike = function(val) {
    var type = goog.typeOf(val);
    return type == "array" || type == "object" && typeof val.length == "number"
};
goog.isDateLike = function(val) {
    return goog.isObject(val) && typeof val.getFullYear == "function"
};
goog.isFunction = function(val) {
    return goog.typeOf(val) == "function"
};
goog.isObject = function(val) {
    var type = typeof val;
    return type == "object" && val != null || type == "function"
};
goog.getUid = function(obj) {
    return obj[goog.UID_PROPERTY_] || (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_)
};
goog.hasUid = function(obj) {
    return !!obj[goog.UID_PROPERTY_]
};
goog.removeUid = function(obj) {
    if (obj !== null && "removeAttribute" in obj) obj.removeAttribute(goog.UID_PROPERTY_);
    try {
        delete obj[goog.UID_PROPERTY_]
    } catch (ex) {}
};
goog.UID_PROPERTY_ = "closure_uid_" + (Math.random() * 1E9 >>> 0);
goog.uidCounter_ = 0;
goog.getHashCode = goog.getUid;
goog.removeHashCode = goog.removeUid;
goog.cloneObject = function(obj) {
    var type = goog.typeOf(obj);
    if (type == "object" || type == "array") {
        if (typeof obj.clone === "function") return obj.clone();
        var clone = type == "array" ? [] : {};
        for (var key in obj) clone[key] = goog.cloneObject(obj[key]);
        return clone
    }
    return obj
};
goog.bindNative_ = function(fn, selfObj, var_args) {
    return fn.call.apply(fn.bind, arguments)
};
goog.bindJs_ = function(fn, selfObj, var_args) {
    if (!fn) throw new Error;
    if (arguments.length > 2) {
        var boundArgs = Array.prototype.slice.call(arguments, 2);
        return function() {
            var newArgs = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(newArgs, boundArgs);
            return fn.apply(selfObj, newArgs)
        }
    } else return function() {
        return fn.apply(selfObj, arguments)
    }
};
goog.bind = function(fn, selfObj, var_args) {
    if (Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1) goog.bind = goog.bindNative_;
    else goog.bind = goog.bindJs_;
    return goog.bind.apply(null, arguments)
};
goog.partial = function(fn, var_args) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
        var newArgs = args.slice();
        newArgs.push.apply(newArgs, arguments);
        return fn.apply(this, newArgs)
    }
};
goog.mixin = function(target, source) {
    for (var x in source) target[x] = source[x]
};
goog.now = goog.TRUSTED_SITE && Date.now || function() {
    return +new Date
};
goog.globalEval = function(script) {
    if (goog.global.execScript) goog.global.execScript(script, "JavaScript");
    else if (goog.global.eval) {
        if (goog.evalWorksForGlobals_ == null) {
            try {
                goog.global.eval("var _evalTest_ = 1;")
            } catch (ignore) {}
            if (typeof goog.global["_evalTest_"] != "undefined") {
                try {
                    delete goog.global["_evalTest_"]
                } catch (ignore$0) {}
                goog.evalWorksForGlobals_ = true
            } else goog.evalWorksForGlobals_ = false
        }
        if (goog.evalWorksForGlobals_) goog.global.eval(script);
        else {
            var doc = goog.global.document;
            var scriptElt = doc.createElement("SCRIPT");
            scriptElt.type = "text/javascript";
            scriptElt.defer = false;
            scriptElt.appendChild(doc.createTextNode(script));
            doc.head.appendChild(scriptElt);
            doc.head.removeChild(scriptElt)
        }
    } else throw new Error("goog.globalEval not available");
};
goog.evalWorksForGlobals_ = null;
goog.cssNameMapping_;
goog.cssNameMappingStyle_;
goog.global.CLOSURE_CSS_NAME_MAP_FN;
goog.getCssName = function(className, opt_modifier) {
    if (String(className).charAt(0) == ".") throw new Error('className passed in goog.getCssName must not start with ".".' + " You passed: " + className);
    var getMapping = function(cssName) {
        return goog.cssNameMapping_[cssName] || cssName
    };
    var renameByParts = function(cssName) {
        var parts = cssName.split("-");
        var mapped = [];
        for (var i = 0; i < parts.length; i++) mapped.push(getMapping(parts[i]));
        return mapped.join("-")
    };
    var rename;
    if (goog.cssNameMapping_) rename = goog.cssNameMappingStyle_ ==
        "BY_WHOLE" ? getMapping : renameByParts;
    else rename = function(a) {
        return a
    };
    var result = opt_modifier ? className + "-" + rename(opt_modifier) : rename(className);
    if (goog.global.CLOSURE_CSS_NAME_MAP_FN) return goog.global.CLOSURE_CSS_NAME_MAP_FN(result);
    return result
};
goog.setCssNameMapping = function(mapping, opt_style) {
    goog.cssNameMapping_ = mapping;
    goog.cssNameMappingStyle_ = opt_style
};
goog.global.CLOSURE_CSS_NAME_MAPPING;
if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
goog.getMsg = function(str, opt_values) {
    if (opt_values) str = str.replace(/\{\$([^}]+)}/g, function(match, key) {
        return opt_values != null && key in opt_values ? opt_values[key] : match
    });
    return str
};
goog.getMsgWithFallback = function(a, b) {
    return a
};
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
    goog.exportPath_(publicPath, object, opt_objectToExportTo)
};
goog.exportProperty = function(object, publicName, symbol) {
    object[publicName] = symbol
};
goog.inherits = function(childCtor, parentCtor) {
    function tempCtor() {}
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor;
    childCtor.prototype.constructor = childCtor;
    childCtor.base = function(me, methodName, var_args) {
        var args = new Array(arguments.length - 2);
        for (var i = 2; i < arguments.length; i++) args[i - 2] = arguments[i];
        return parentCtor.prototype[methodName].apply(me, args)
    }
};
goog.base = function(me, opt_methodName, var_args) {
    var caller = arguments.callee.caller;
    if (goog.STRICT_MODE_COMPATIBLE || goog.DEBUG && !caller) throw new Error("arguments.caller not defined.  goog.base() cannot be used " + "with strict mode code. See " + "http://www.ecma-international.org/ecma-262/5.1/#sec-C");
    if (typeof caller.superClass_ !== "undefined") {
        var ctorArgs = new Array(arguments.length - 1);
        for (var i = 1; i < arguments.length; i++) ctorArgs[i - 1] = arguments[i];
        return caller.superClass_.constructor.apply(me, ctorArgs)
    }
    if (typeof opt_methodName !=
        "string" && typeof opt_methodName != "symbol") throw new Error("method names provided to goog.base must be a string or a symbol");
    var args = new Array(arguments.length - 2);
    for (var i = 2; i < arguments.length; i++) args[i - 2] = arguments[i];
    var foundCaller = false;
    for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor)
        if (ctor.prototype[opt_methodName] === caller) foundCaller = true;
        else if (foundCaller) return ctor.prototype[opt_methodName].apply(me, args);
    if (me[opt_methodName] === caller) return me.constructor.prototype[opt_methodName].apply(me,
        args);
    else throw new Error("goog.base called from a method of one name " + "to a method of a different name");
};
goog.scope = function(fn) {
    if (goog.isInModuleLoader_()) throw new Error("goog.scope is not supported within a module.");
    fn.call(goog.global)
};
if (!COMPILED) goog.global["COMPILED"] = COMPILED;
goog.defineClass = function(superClass, def) {
    var constructor = def.constructor;
    var statics = def.statics;
    if (!constructor || constructor == Object.prototype.constructor) constructor = function() {
        throw new Error("cannot instantiate an interface (no constructor defined).");
    };
    var cls = goog.defineClass.createSealingConstructor_(constructor, superClass);
    if (superClass) goog.inherits(cls, superClass);
    delete def.constructor;
    delete def.statics;
    goog.defineClass.applyProperties_(cls.prototype, def);
    if (statics != null)
        if (statics instanceof Function) statics(cls);
        else goog.defineClass.applyProperties_(cls, statics);
    return cls
};
goog.defineClass.ClassDescriptor;
goog.define("goog.defineClass.SEAL_CLASS_INSTANCES", goog.DEBUG);
goog.defineClass.createSealingConstructor_ = function(ctr, superClass) {
    if (!goog.defineClass.SEAL_CLASS_INSTANCES) return ctr;
    var superclassSealable = !goog.defineClass.isUnsealable_(superClass);
    var wrappedCtr = function() {
        var instance = ctr.apply(this, arguments) || this;
        instance[goog.UID_PROPERTY_] = instance[goog.UID_PROPERTY_];
        if (this.constructor === wrappedCtr && superclassSealable && Object.seal instanceof Function) Object.seal(instance);
        return instance
    };
    return wrappedCtr
};
goog.defineClass.isUnsealable_ = function(ctr) {
    return ctr && ctr.prototype && ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_]
};
goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
goog.defineClass.applyProperties_ = function(target, source) {
    var key;
    for (key in source)
        if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
    for (var i = 0; i < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; i++) {
        key = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[i];
        if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key]
    }
};
goog.tagUnsealableClass = function(ctr) {
    if (!COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES) ctr.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true
};
goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
if (!COMPILED && goog.DEPENDENCIES_ENABLED) {
    goog.inHtmlDocument_ = function() {
        var doc = goog.global.document;
        return doc != null && "write" in doc
    };
    goog.isDocumentLoading_ = function() {
        var doc = goog.global.document;
        return doc.attachEvent ? doc.readyState != "complete" : doc.readyState == "loading"
    };
    goog.findBasePath_ = function() {
        if (goog.isDef(goog.global.CLOSURE_BASE_PATH) && goog.isString(goog.global.CLOSURE_BASE_PATH)) {
            goog.basePath = goog.global.CLOSURE_BASE_PATH;
            return
        } else if (!goog.inHtmlDocument_()) return;
        var doc = goog.global.document;
        var currentScript = doc.currentScript;
        if (currentScript) var scripts = [currentScript];
        else var scripts = doc.getElementsByTagName("SCRIPT");
        for (var i = scripts.length - 1; i >= 0; --i) {
            var script = scripts[i];
            var src = script.src;
            var qmark = src.lastIndexOf("?");
            var l = qmark == -1 ? src.length : qmark;
            if (src.substr(l - 7, 7) == "base.js") {
                goog.basePath = src.substr(0, l - 7);
                return
            }
        }
    };
    goog.findBasePath_();
    goog.Transpiler = function() {
        this.requiresTranspilation_ = null;
        this.transpilationTarget_ = goog.TRANSPILE_TO_LANGUAGE
    };
    goog.Transpiler.prototype.createRequiresTranspilation_ =
        function() {
            var transpilationTarget = "es3";
            var requiresTranspilation = {
                "es3": false
            };
            var transpilationRequiredForAllLaterModes = false;

            function addNewerLanguageTranspilationCheck(modeName, isSupported) {
                if (transpilationRequiredForAllLaterModes) requiresTranspilation[modeName] = true;
                else if (isSupported()) {
                    transpilationTarget = modeName;
                    requiresTranspilation[modeName] = false
                } else {
                    requiresTranspilation[modeName] = true;
                    transpilationRequiredForAllLaterModes = true
                }
            }

            function evalCheck(code) {
                try {
                    return !!eval(code)
                } catch (ignored) {
                    return false
                }
            }
            var userAgent = goog.global.navigator && goog.global.navigator.userAgent ? goog.global.navigator.userAgent : "";
            addNewerLanguageTranspilationCheck("es5", function() {
                return evalCheck("[1,].length==1")
            });
            addNewerLanguageTranspilationCheck("es6", function() {
                var re = /Edge\/(\d+)(\.\d)*/i;
                var edgeUserAgent = userAgent.match(re);
                if (edgeUserAgent && Number(edgeUserAgent[1]) < 15) return false;
                var es6fullTest = "class X{constructor(){if(new.target!=String)throw 1;this.x=42}}" + "let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof " +
                    "String))throw 1;for(const a of[2,3]){if(a==2)continue;function " + "f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()" + "==3}";
                return evalCheck('(()=>{"use strict";' + es6fullTest + "})()")
            });
            addNewerLanguageTranspilationCheck("es6-impl", function() {
                return true
            });
            addNewerLanguageTranspilationCheck("es7", function() {
                return evalCheck("2 ** 2 == 4")
            });
            addNewerLanguageTranspilationCheck("es8", function() {
                return evalCheck("async () => 1, true")
            });
            addNewerLanguageTranspilationCheck("es9", function() {
                return evalCheck("({...rest} = {}), true")
            });
            addNewerLanguageTranspilationCheck("es_next", function() {
                return false
            });
            return {
                target: transpilationTarget,
                map: requiresTranspilation
            }
        };
    goog.Transpiler.prototype.needsTranspile = function(lang, module) {
        if (goog.TRANSPILE == "always") return true;
        else if (goog.TRANSPILE == "never") return false;
        else if (!this.requiresTranspilation_) {
            var obj = this.createRequiresTranspilation_();
            this.requiresTranspilation_ = obj.map;
            this.transpilationTarget_ = this.transpilationTarget_ || obj.target
        }
        if (lang in this.requiresTranspilation_)
            if (this.requiresTranspilation_[lang]) return true;
            else if (goog.inHtmlDocument_() && module == "es6" && !("noModule" in goog.global.document.createElement("script"))) return true;
        else return false;
        else throw new Error("Unknown language mode: " + lang);
    };
    goog.Transpiler.prototype.transpile = function(code, path) {
        return goog.transpile_(code, path, this.transpilationTarget_)
    };
    goog.transpiler_ = new goog.Transpiler;
    goog.protectScriptTag_ = function(str) {
        return str.replace(/<\/(SCRIPT)/ig, "\\x3c/$1")
    };
    goog.DebugLoader_ = function() {
        this.dependencies_ = {};
        this.idToPath_ = {};
        this.written_ = {};
        this.loadingDeps_ = [];
        this.depsToLoad_ = [];
        this.paused_ = false;
        this.factory_ = new goog.DependencyFactory(goog.transpiler_);
        this.deferredCallbacks_ = {};
        this.deferredQueue_ = []
    };
    goog.DebugLoader_.prototype.bootstrap = function(namespaces, callback) {
        var cb = callback;

        function resolve() {
            if (cb) {
                goog.global.setTimeout(cb, 0);
                cb = null
            }
        }
        if (!namespaces.length) {
            resolve();
            return
        }
        var deps = [];
        for (var i = 0; i < namespaces.length; i++) {
            var path = this.getPathFromDeps_(namespaces[i]);
            if (!path) throw new Error("Unregonized namespace: " +
                namespaces[i]);
            deps.push(this.dependencies_[path])
        }
        var require = goog.require;
        var loaded = 0;
        for (var i = 0; i < namespaces.length; i++) {
            require(namespaces[i]);
            deps[i].onLoad(function() {
                if (++loaded == namespaces.length) resolve()
            })
        }
    };
    goog.DebugLoader_.prototype.loadClosureDeps = function() {
        var relPath = "deps.js";
        this.depsToLoad_.push(this.factory_.createDependency(goog.normalizePath_(goog.basePath + relPath), relPath, [], [], {}, false));
        this.loadDeps_()
    };
    goog.DebugLoader_.prototype.requested = function(absPathOrId, opt_force) {
        var path =
            this.getPathFromDeps_(absPathOrId);
        if (path && (opt_force || this.areDepsLoaded_(this.dependencies_[path].requires))) {
            var callback = this.deferredCallbacks_[path];
            if (callback) {
                delete this.deferredCallbacks_[path];
                callback()
            }
        }
    };
    goog.DebugLoader_.prototype.setDependencyFactory = function(factory) {
        this.factory_ = factory
    };
    goog.DebugLoader_.prototype.load_ = function(namespace) {
        if (!this.getPathFromDeps_(namespace)) {
            var errorMessage = "goog.require could not find: " + namespace;
            goog.logToConsole_(errorMessage);
            throw Error(errorMessage);
        } else {
            var loader = this;
            var deps = [];
            var visit = function(namespace) {
                var path = loader.getPathFromDeps_(namespace);
                if (!path) throw new Error("Bad dependency path or symbol: " + namespace);
                if (loader.written_[path]) return;
                loader.written_[path] = true;
                var dep = loader.dependencies_[path];
                for (var i = 0; i < dep.requires.length; i++)
                    if (!goog.isProvided_(dep.requires[i])) visit(dep.requires[i]);
                deps.push(dep)
            };
            visit(namespace);
            var wasLoading = !!this.depsToLoad_.length;
            this.depsToLoad_ = this.depsToLoad_.concat(deps);
            if (!this.paused_ &&
                !wasLoading) this.loadDeps_()
        }
    };
    goog.DebugLoader_.prototype.loadDeps_ = function() {
        var loader = this;
        var paused = this.paused_;
        while (this.depsToLoad_.length && !paused)(function() {
            var loadCallDone = false;
            var dep = loader.depsToLoad_.shift();
            var loaded = false;
            loader.loading_(dep);
            var controller = {
                pause: function() {
                    if (loadCallDone) throw new Error("Cannot call pause after the call to load.");
                    else paused = true
                },
                resume: function() {
                    if (loadCallDone) loader.resume_();
                    else paused = false
                },
                loaded: function() {
                    if (loaded) throw new Error("Double call to loaded.");
                    loaded = true;
                    loader.loaded_(dep)
                },
                pending: function() {
                    var pending = [];
                    for (var i = 0; i < loader.loadingDeps_.length; i++) pending.push(loader.loadingDeps_[i]);
                    return pending
                },
                setModuleState: function(type) {
                    goog.moduleLoaderState_ = {
                        type: type,
                        moduleName: "",
                        declareLegacyNamespace: false
                    }
                },
                registerEs6ModuleExports: function(path, exports, opt_closureNamespace) {
                    if (opt_closureNamespace) goog.loadedModules_[opt_closureNamespace] = {
                        exports: exports,
                        type: goog.ModuleType.ES6,
                        moduleId: opt_closureNamespace || ""
                    }
                },
                registerGoogModuleExports: function(moduleId,
                    exports) {
                    goog.loadedModules_[moduleId] = {
                        exports: exports,
                        type: goog.ModuleType.GOOG,
                        moduleId: moduleId
                    }
                },
                clearModuleState: function() {
                    goog.moduleLoaderState_ = null
                },
                defer: function(callback) {
                    if (loadCallDone) throw new Error("Cannot register with defer after the call to load.");
                    loader.defer_(dep, callback)
                },
                areDepsLoaded: function() {
                    return loader.areDepsLoaded_(dep.requires)
                }
            };
            try {
                dep.load(controller)
            } finally {
                loadCallDone = true
            }
        })();
        if (paused) this.pause_()
    };
    goog.DebugLoader_.prototype.pause_ = function() {
        this.paused_ =
            true
    };
    goog.DebugLoader_.prototype.resume_ = function() {
        if (this.paused_) {
            this.paused_ = false;
            this.loadDeps_()
        }
    };
    goog.DebugLoader_.prototype.loading_ = function(dep) {
        this.loadingDeps_.push(dep)
    };
    goog.DebugLoader_.prototype.loaded_ = function(dep) {
        for (var i = 0; i < this.loadingDeps_.length; i++)
            if (this.loadingDeps_[i] == dep) {
                this.loadingDeps_.splice(i, 1);
                break
            } for (var i = 0; i < this.deferredQueue_.length; i++)
            if (this.deferredQueue_[i] == dep.path) {
                this.deferredQueue_.splice(i, 1);
                break
            } if (this.loadingDeps_.length == this.deferredQueue_.length &&
            !this.depsToLoad_.length)
            while (this.deferredQueue_.length) this.requested(this.deferredQueue_.shift(), true);
        dep.loaded()
    };
    goog.DebugLoader_.prototype.areDepsLoaded_ = function(pathsOrIds) {
        for (var i = 0; i < pathsOrIds.length; i++) {
            var path = this.getPathFromDeps_(pathsOrIds[i]);
            if (!path || !(path in this.deferredCallbacks_) && !goog.isProvided_(pathsOrIds[i])) return false
        }
        return true
    };
    goog.DebugLoader_.prototype.getPathFromDeps_ = function(absPathOrId) {
        if (absPathOrId in this.idToPath_) return this.idToPath_[absPathOrId];
        else if (absPathOrId in this.dependencies_) return absPathOrId;
        else return null
    };
    goog.DebugLoader_.prototype.defer_ = function(dependency, callback) {
        this.deferredCallbacks_[dependency.path] = callback;
        this.deferredQueue_.push(dependency.path)
    };
    goog.LoadController = function() {};
    goog.LoadController.prototype.pause = function() {};
    goog.LoadController.prototype.resume = function() {};
    goog.LoadController.prototype.loaded = function() {};
    goog.LoadController.prototype.pending = function() {};
    goog.LoadController.prototype.registerEs6ModuleExports =
        function(path, exports, opt_closureNamespace) {};
    goog.LoadController.prototype.setModuleState = function(type) {};
    goog.LoadController.prototype.clearModuleState = function() {};
    goog.LoadController.prototype.defer = function(callback) {};
    goog.LoadController.prototype.areDepsLoaded = function() {};
    goog.Dependency = function(path, relativePath, provides, requires, loadFlags) {
        this.path = path;
        this.relativePath = relativePath;
        this.provides = provides;
        this.requires = requires;
        this.loadFlags = loadFlags;
        this.loaded_ = false;
        this.loadCallbacks_ = []
    };
    goog.Dependency.prototype.getPathName = function() {
        var pathName = this.path;
        var protocolIndex = pathName.indexOf("://");
        if (protocolIndex >= 0) {
            pathName = pathName.substring(protocolIndex + 3);
            var slashIndex = pathName.indexOf("/");
            if (slashIndex >= 0) pathName = pathName.substring(slashIndex + 1)
        }
        return pathName
    };
    goog.Dependency.prototype.onLoad = function(callback) {
        if (this.loaded_) callback();
        else this.loadCallbacks_.push(callback)
    };
    goog.Dependency.prototype.loaded = function() {
        this.loaded_ = true;
        var callbacks = this.loadCallbacks_;
        this.loadCallbacks_ = [];
        for (var i = 0; i < callbacks.length; i++) callbacks[i]()
    };
    goog.Dependency.defer_ = false;
    goog.Dependency.callbackMap_ = {};
    goog.Dependency.registerCallback_ = function(callback) {
        var key = Math.random().toString(32);
        goog.Dependency.callbackMap_[key] = callback;
        return key
    };
    goog.Dependency.unregisterCallback_ = function(key) {
        delete goog.Dependency.callbackMap_[key]
    };
    goog.Dependency.callback_ = function(key, var_args) {
        if (key in goog.Dependency.callbackMap_) {
            var callback = goog.Dependency.callbackMap_[key];
            var args = [];
            for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
            callback.apply(undefined, args)
        } else {
            var errorMessage = "Callback key " + key + " does not exist (was base.js loaded more than once?).";
            throw Error(errorMessage);
        }
    };
    goog.Dependency.prototype.load = function(controller) {
        if (goog.global.CLOSURE_IMPORT_SCRIPT) {
            if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) controller.loaded();
            else controller.pause();
            return
        }
        if (!goog.inHtmlDocument_()) {
            goog.logToConsole_("Cannot use default debug loader outside of HTML documents.");
            if (this.relativePath == "deps.js") {
                goog.logToConsole_("Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, " + "or setting CLOSURE_NO_DEPS to true.");
                controller.loaded()
            } else controller.pause();
            return
        }
        var doc = goog.global.document;
        if (doc.readyState == "complete" && !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
            var isDeps = /\bdeps.js$/.test(this.path);
            if (isDeps) {
                controller.loaded();
                return
            } else throw Error('Cannot write "' + this.path + '" after document load');
        }
        if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING &&
            goog.isDocumentLoading_()) {
            var key = goog.Dependency.registerCallback_(function(script) {
                if (!goog.DebugLoader_.IS_OLD_IE_ || script.readyState == "complete") {
                    goog.Dependency.unregisterCallback_(key);
                    controller.loaded()
                }
            });
            var nonceAttr = !goog.DebugLoader_.IS_OLD_IE_ && goog.getScriptNonce() ? ' nonce="' + goog.getScriptNonce() + '"' : "";
            var event = goog.DebugLoader_.IS_OLD_IE_ ? "onreadystatechange" : "onload";
            var defer = goog.Dependency.defer_ ? "defer" : "";
            doc.write('<script src="' + this.path + '" ' + event + "=\"goog.Dependency.callback_('" +
                key + '\', this)" type="text/javascript" ' + defer + nonceAttr + "><" + "/script>")
        } else {
            var scriptEl = doc.createElement("script");
            scriptEl.defer = goog.Dependency.defer_;
            scriptEl.async = false;
            scriptEl.type = "text/javascript";
            var nonce = goog.getScriptNonce();
            if (nonce) scriptEl.setAttribute("nonce", nonce);
            if (goog.DebugLoader_.IS_OLD_IE_) {
                controller.pause();
                scriptEl.onreadystatechange = function() {
                    if (scriptEl.readyState == "loaded" || scriptEl.readyState == "complete") {
                        controller.loaded();
                        controller.resume()
                    }
                }
            } else scriptEl.onload =
                function() {
                    scriptEl.onload = null;
                    controller.loaded()
                };
            scriptEl.src = this.path;
            doc.head.appendChild(scriptEl)
        }
    };
    goog.Es6ModuleDependency = function(path, relativePath, provides, requires, loadFlags) {
        goog.Es6ModuleDependency.base(this, "constructor", path, relativePath, provides, requires, loadFlags)
    };
    goog.inherits(goog.Es6ModuleDependency, goog.Dependency);
    goog.Es6ModuleDependency.prototype.load = function(controller) {
        if (goog.global.CLOSURE_IMPORT_SCRIPT) {
            if (goog.global.CLOSURE_IMPORT_SCRIPT(this.path)) controller.loaded();
            else controller.pause();
            return
        }
        if (!goog.inHtmlDocument_()) {
            goog.logToConsole_("Cannot use default debug loader outside of HTML documents.");
            controller.pause();
            return
        }
        var doc = goog.global.document;
        var dep = this;

        function write(src, contents) {
            if (contents) doc.write('<script type="module" crossorigin>' + contents + "</" + "script>");
            else doc.write('<script type="module" crossorigin src="' + src + '"></' + "script>")
        }

        function append(src, contents) {
            var scriptEl = doc.createElement("script");
            scriptEl.defer = true;
            scriptEl.async =
                false;
            scriptEl.type = "module";
            scriptEl.setAttribute("crossorigin", true);
            var nonce = goog.getScriptNonce();
            if (nonce) scriptEl.setAttribute("nonce", nonce);
            if (contents) scriptEl.textContent = contents;
            else scriptEl.src = src;
            doc.head.appendChild(scriptEl)
        }
        var create;
        if (goog.isDocumentLoading_()) {
            create = write;
            goog.Dependency.defer_ = true
        } else create = append;
        var beforeKey = goog.Dependency.registerCallback_(function() {
            goog.Dependency.unregisterCallback_(beforeKey);
            controller.setModuleState(goog.ModuleType.ES6)
        });
        create(undefined,
            'goog.Dependency.callback_("' + beforeKey + '")');
        create(this.path, undefined);
        var registerKey = goog.Dependency.registerCallback_(function(exports) {
            goog.Dependency.unregisterCallback_(registerKey);
            controller.registerEs6ModuleExports(dep.path, exports, goog.moduleLoaderState_.moduleName)
        });
        create(undefined, 'import * as m from "' + this.path + '"; goog.Dependency.callback_("' + registerKey + '", m)');
        var afterKey = goog.Dependency.registerCallback_(function() {
            goog.Dependency.unregisterCallback_(afterKey);
            controller.clearModuleState();
            controller.loaded()
        });
        create(undefined, 'goog.Dependency.callback_("' + afterKey + '")')
    };
    goog.TransformedDependency = function(path, relativePath, provides, requires, loadFlags) {
        goog.TransformedDependency.base(this, "constructor", path, relativePath, provides, requires, loadFlags);
        this.contents_ = null;
        this.lazyFetch_ = !goog.inHtmlDocument_() || !("noModule" in goog.global.document.createElement("script"))
    };
    goog.inherits(goog.TransformedDependency, goog.Dependency);
    goog.TransformedDependency.prototype.load = function(controller) {
        var dep =
            this;

        function fetch() {
            dep.contents_ = goog.loadFileSync_(dep.path);
            if (dep.contents_) {
                dep.contents_ = dep.transform(dep.contents_);
                if (dep.contents_) dep.contents_ += "\n//# sourceURL=" + dep.path
            }
        }
        if (goog.global.CLOSURE_IMPORT_SCRIPT) {
            fetch();
            if (this.contents_ && goog.global.CLOSURE_IMPORT_SCRIPT("", this.contents_)) {
                this.contents_ = null;
                controller.loaded()
            } else controller.pause();
            return
        }
        var isEs6 = this.loadFlags["module"] == goog.ModuleType.ES6;
        if (!this.lazyFetch_) fetch();

        function load() {
            if (dep.lazyFetch_) fetch();
            if (!dep.contents_) return;
            if (isEs6) controller.setModuleState(goog.ModuleType.ES6);
            var namespace;
            try {
                var contents = dep.contents_;
                dep.contents_ = null;
                goog.globalEval(contents);
                if (isEs6) namespace = goog.moduleLoaderState_.moduleName
            } finally {
                if (isEs6) controller.clearModuleState()
            }
            if (isEs6) goog.global["$jscomp"]["require"]["ensure"]([dep.getPathName()], function() {
                controller.registerEs6ModuleExports(dep.path, goog.global["$jscomp"]["require"](dep.getPathName()), namespace)
            });
            controller.loaded()
        }

        function fetchInOwnScriptThenLoad() {
            var doc =
                goog.global.document;
            var key = goog.Dependency.registerCallback_(function() {
                goog.Dependency.unregisterCallback_(key);
                load()
            });
            doc.write('<script type="text/javascript">' + goog.protectScriptTag_('goog.Dependency.callback_("' + key + '");') + "</" + "script>")
        }
        var anythingElsePending = controller.pending().length > 1;
        var useOldIeWorkAround = anythingElsePending && goog.DebugLoader_.IS_OLD_IE_;
        var needsAsyncLoading = goog.Dependency.defer_ && (anythingElsePending || goog.isDocumentLoading_());
        if (useOldIeWorkAround || needsAsyncLoading) {
            controller.defer(function() {
                load()
            });
            return
        }
        var doc = goog.global.document;
        var isInternetExplorer = goog.inHtmlDocument_() && "ActiveXObject" in goog.global;
        if (isEs6 && goog.inHtmlDocument_() && goog.isDocumentLoading_() && !isInternetExplorer) {
            goog.Dependency.defer_ = true;
            controller.pause();
            var oldCallback = doc.onreadystatechange;
            doc.onreadystatechange = function() {
                if (doc.readyState == "interactive") {
                    doc.onreadystatechange = oldCallback;
                    load();
                    controller.resume()
                }
                if (goog.isFunction(oldCallback)) oldCallback.apply(undefined, arguments)
            }
        } else if (goog.DebugLoader_.IS_OLD_IE_ ||
            !goog.inHtmlDocument_() || !goog.isDocumentLoading_()) load();
        else fetchInOwnScriptThenLoad()
    };
    goog.TransformedDependency.prototype.transform = function(contents) {};
    goog.TranspiledDependency = function(path, relativePath, provides, requires, loadFlags, transpiler) {
        goog.TranspiledDependency.base(this, "constructor", path, relativePath, provides, requires, loadFlags);
        this.transpiler = transpiler
    };
    goog.inherits(goog.TranspiledDependency, goog.TransformedDependency);
    goog.TranspiledDependency.prototype.transform = function(contents) {
        return this.transpiler.transpile(contents,
            this.getPathName())
    };
    goog.GoogModuleDependency = function(path, relativePath, provides, requires, loadFlags, needsTranspile, transpiler) {
        goog.GoogModuleDependency.base(this, "constructor", path, relativePath, provides, requires, loadFlags);
        this.needsTranspile_ = needsTranspile;
        this.transpiler_ = transpiler
    };
    goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency);
    goog.GoogModuleDependency.prototype.transform = function(contents) {
        if (this.needsTranspile_) contents = this.transpiler_.transpile(contents, this.getPathName());
        if (!goog.LOAD_MODULE_USING_EVAL || !goog.isDef(goog.global.JSON)) return "" + "goog.loadModule(function(exports) {" + '"use strict";' + contents + "\n" + ";return exports" + "});" + "\n//# sourceURL=" + this.path + "\n";
        else return "" + "goog.loadModule(" + goog.global.JSON.stringify(contents + "\n//# sourceURL=" + this.path + "\n") + ");"
    };
    goog.DebugLoader_.IS_OLD_IE_ = !!(!goog.global.atob && goog.global.document && goog.global.document["all"]);
    goog.DebugLoader_.prototype.addDependency = function(relPath, provides, requires, opt_loadFlags) {
        provides =
            provides || [];
        relPath = relPath.replace(/\\/g, "/");
        var path = goog.normalizePath_(goog.basePath + relPath);
        if (!opt_loadFlags || typeof opt_loadFlags === "boolean") opt_loadFlags = opt_loadFlags ? {
            "module": goog.ModuleType.GOOG
        } : {};
        var dep = this.factory_.createDependency(path, relPath, provides, requires, opt_loadFlags, goog.transpiler_.needsTranspile(opt_loadFlags["lang"] || "es3", opt_loadFlags["module"]));
        this.dependencies_[path] = dep;
        for (var i = 0; i < provides.length; i++) this.idToPath_[provides[i]] = path;
        this.idToPath_[relPath] =
            path
    };
    goog.DependencyFactory = function(transpiler) {
        this.transpiler = transpiler
    };
    goog.DependencyFactory.prototype.createDependency = function(path, relativePath, provides, requires, loadFlags, needsTranspile) {
        if (loadFlags["module"] == goog.ModuleType.GOOG) return new goog.GoogModuleDependency(path, relativePath, provides, requires, loadFlags, needsTranspile, this.transpiler);
        else if (needsTranspile) return new goog.TranspiledDependency(path, relativePath, provides, requires, loadFlags, this.transpiler);
        else if (loadFlags["module"] ==
            goog.ModuleType.ES6) return new goog.Es6ModuleDependency(path, relativePath, provides, requires, loadFlags);
        else return new goog.Dependency(path, relativePath, provides, requires, loadFlags)
    };
    goog.debugLoader_ = new goog.DebugLoader_;
    goog.loadClosureDeps = function() {
        goog.debugLoader_.loadClosureDeps()
    };
    goog.setDependencyFactory = function(factory) {
        goog.debugLoader_.setDependencyFactory(factory)
    };
    if (!goog.global.CLOSURE_NO_DEPS) goog.debugLoader_.loadClosureDeps();
    goog.bootstrap = function(namespaces, callback) {
        goog.debugLoader_.bootstrap(namespaces,
            callback)
    }
};
goog.provide("goog.debug.Error");
goog.debug.Error = function(opt_msg) {
    if (Error.captureStackTrace) Error.captureStackTrace(this, goog.debug.Error);
    else {
        var stack = (new Error).stack;
        if (stack) this.stack = stack
    }
    if (opt_msg) this.message = String(opt_msg);
    this.reportErrorToServer = true
};
goog.inherits(goog.debug.Error, Error);
goog.debug.Error.prototype.name = "CustomError";
goog.provide("goog.dom.NodeType");
goog.dom.NodeType = {
    ELEMENT: 1,
    ATTRIBUTE: 2,
    TEXT: 3,
    CDATA_SECTION: 4,
    ENTITY_REFERENCE: 5,
    ENTITY: 6,
    PROCESSING_INSTRUCTION: 7,
    COMMENT: 8,
    DOCUMENT: 9,
    DOCUMENT_TYPE: 10,
    DOCUMENT_FRAGMENT: 11,
    NOTATION: 12
};
goog.provide("goog.asserts");
goog.provide("goog.asserts.AssertionError");
goog.require("goog.debug.Error");
goog.require("goog.dom.NodeType");
goog.define("goog.asserts.ENABLE_ASSERTS", goog.DEBUG);
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
    goog.debug.Error.call(this, goog.asserts.subs_(messagePattern, messageArgs));
    this.messagePattern = messagePattern
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
goog.asserts.AssertionError.prototype.name = "AssertionError";
goog.asserts.DEFAULT_ERROR_HANDLER = function(e) {
    throw e;
};
goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;
goog.asserts.subs_ = function(pattern, subs) {
    var splitParts = pattern.split("%s");
    var returnString = "";
    var subLast = splitParts.length - 1;
    for (var i = 0; i < subLast; i++) {
        var sub = i < subs.length ? subs[i] : "%s";
        returnString += splitParts[i] + sub
    }
    return returnString + splitParts[subLast]
};
goog.asserts.doAssertFailure_ = function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
    var message = "Assertion failed";
    if (givenMessage) {
        message += ": " + givenMessage;
        var args = givenArgs
    } else if (defaultMessage) {
        message += ": " + defaultMessage;
        args = defaultArgs
    }
    var e = new goog.asserts.AssertionError("" + message, args || []);
    goog.asserts.errorHandler_(e)
};
goog.asserts.setErrorHandler = function(errorHandler) {
    if (goog.asserts.ENABLE_ASSERTS) goog.asserts.errorHandler_ = errorHandler
};
goog.asserts.assert = function(condition, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !condition) goog.asserts.doAssertFailure_("", null, opt_message, Array.prototype.slice.call(arguments, 2));
    return condition
};
goog.asserts.fail = function(opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS) goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (opt_message ? ": " + opt_message : ""), Array.prototype.slice.call(arguments, 1)))
};
goog.asserts.assertNumber = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertString = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertFunction = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertObject = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertArray = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertElement = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) || value.nodeType != goog.dom.NodeType.ELEMENT)) goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(value), value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(type), goog.asserts.getType_(value)], opt_message, Array.prototype.slice.call(arguments, 3));
    return value
};
goog.asserts.assertFinite = function(value, opt_message, var_args) {
    if (goog.asserts.ENABLE_ASSERTS && (typeof value != "number" || !isFinite(value))) goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.", [value], opt_message, Array.prototype.slice.call(arguments, 2));
    return value
};
goog.asserts.assertObjectPrototypeIsIntact = function() {
    for (var key in Object.prototype) goog.asserts.fail(key + " should not be enumerable in Object.prototype.")
};
goog.asserts.getType_ = function(value) {
    if (value instanceof Function) return value.displayName || value.name || "unknown type name";
    else if (value instanceof Object) return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
    else return value === null ? "null" : typeof value
};
goog.provide("goog.array");
goog.require("goog.asserts");
goog.define("goog.NATIVE_ARRAY_PROTOTYPES", goog.TRUSTED_SITE);
goog.define("goog.array.ASSUME_NATIVE_FUNCTIONS", false);
goog.array.peek = function(array) {
    return array[array.length - 1]
};
goog.array.last = goog.array.peek;
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ? function(arr, obj, opt_fromIndex) {
    goog.asserts.assert(arr.length != null);
    return Array.prototype.indexOf.call(arr, obj, opt_fromIndex)
} : function(arr, obj, opt_fromIndex) {
    var fromIndex = opt_fromIndex == null ? 0 : opt_fromIndex < 0 ? Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex;
    if (goog.isString(arr)) {
        if (!goog.isString(obj) || obj.length != 1) return -1;
        return arr.indexOf(obj, fromIndex)
    }
    for (var i = fromIndex; i <
        arr.length; i++)
        if (i in arr && arr[i] === obj) return i;
    return -1
};
goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ? function(arr, obj, opt_fromIndex) {
    goog.asserts.assert(arr.length != null);
    var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
    return Array.prototype.lastIndexOf.call(arr, obj, fromIndex)
} : function(arr, obj, opt_fromIndex) {
    var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
    if (fromIndex < 0) fromIndex = Math.max(0, arr.length + fromIndex);
    if (goog.isString(arr)) {
        if (!goog.isString(obj) ||
            obj.length != 1) return -1;
        return arr.lastIndexOf(obj, fromIndex)
    }
    for (var i = fromIndex; i >= 0; i--)
        if (i in arr && arr[i] === obj) return i;
    return -1
};
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ? function(arr, f, opt_obj) {
    goog.asserts.assert(arr.length != null);
    Array.prototype.forEach.call(arr, f, opt_obj)
} : function(arr, f, opt_obj) {
    var l = arr.length;
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = 0; i < l; i++)
        if (i in arr2) f.call(opt_obj, arr2[i], i, arr)
};
goog.array.forEachRight = function(arr, f, opt_obj) {
    var l = arr.length;
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = l - 1; i >= 0; --i)
        if (i in arr2) f.call(opt_obj, arr2[i], i, arr)
};
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ? function(arr, f, opt_obj) {
    goog.asserts.assert(arr.length != null);
    return Array.prototype.filter.call(arr, f, opt_obj)
} : function(arr, f, opt_obj) {
    var l = arr.length;
    var res = [];
    var resLength = 0;
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = 0; i < l; i++)
        if (i in arr2) {
            var val = arr2[i];
            if (f.call(opt_obj, val, i, arr)) res[resLength++] = val
        } return res
};
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ? function(arr, f, opt_obj) {
    goog.asserts.assert(arr.length != null);
    return Array.prototype.map.call(arr, f, opt_obj)
} : function(arr, f, opt_obj) {
    var l = arr.length;
    var res = new Array(l);
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = 0; i < l; i++)
        if (i in arr2) res[i] = f.call(opt_obj, arr2[i], i, arr);
    return res
};
goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ? function(arr, f, val, opt_obj) {
    goog.asserts.assert(arr.length != null);
    if (opt_obj) f = goog.bind(f, opt_obj);
    return Array.prototype.reduce.call(arr, f, val)
} : function(arr, f, val, opt_obj) {
    var rval = val;
    goog.array.forEach(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr)
    });
    return rval
};
goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ? function(arr, f, val, opt_obj) {
    goog.asserts.assert(arr.length != null);
    goog.asserts.assert(f != null);
    if (opt_obj) f = goog.bind(f, opt_obj);
    return Array.prototype.reduceRight.call(arr, f, val)
} : function(arr, f, val, opt_obj) {
    var rval = val;
    goog.array.forEachRight(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr)
    });
    return rval
};
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ? function(arr, f, opt_obj) {
    goog.asserts.assert(arr.length != null);
    return Array.prototype.some.call(arr, f, opt_obj)
} : function(arr, f, opt_obj) {
    var l = arr.length;
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = 0; i < l; i++)
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) return true;
    return false
};
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ? function(arr, f, opt_obj) {
    goog.asserts.assert(arr.length != null);
    return Array.prototype.every.call(arr, f, opt_obj)
} : function(arr, f, opt_obj) {
    var l = arr.length;
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = 0; i < l; i++)
        if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) return false;
    return true
};
goog.array.count = function(arr, f, opt_obj) {
    var count = 0;
    goog.array.forEach(arr, function(element, index, arr) {
        if (f.call(opt_obj, element, index, arr)) ++count
    }, opt_obj);
    return count
};
goog.array.find = function(arr, f, opt_obj) {
    var i = goog.array.findIndex(arr, f, opt_obj);
    return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i]
};
goog.array.findIndex = function(arr, f, opt_obj) {
    var l = arr.length;
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = 0; i < l; i++)
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) return i;
    return -1
};
goog.array.findRight = function(arr, f, opt_obj) {
    var i = goog.array.findIndexRight(arr, f, opt_obj);
    return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i]
};
goog.array.findIndexRight = function(arr, f, opt_obj) {
    var l = arr.length;
    var arr2 = goog.isString(arr) ? arr.split("") : arr;
    for (var i = l - 1; i >= 0; i--)
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) return i;
    return -1
};
goog.array.contains = function(arr, obj) {
    return goog.array.indexOf(arr, obj) >= 0
};
goog.array.isEmpty = function(arr) {
    return arr.length == 0
};
goog.array.clear = function(arr) {
    if (!goog.isArray(arr))
        for (var i = arr.length - 1; i >= 0; i--) delete arr[i];
    arr.length = 0
};
goog.array.insert = function(arr, obj) {
    if (!goog.array.contains(arr, obj)) arr.push(obj)
};
goog.array.insertAt = function(arr, obj, opt_i) {
    goog.array.splice(arr, opt_i, 0, obj)
};
goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {
    goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd)
};
goog.array.insertBefore = function(arr, obj, opt_obj2) {
    var i;
    if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) arr.push(obj);
    else goog.array.insertAt(arr, obj, i)
};
goog.array.remove = function(arr, obj) {
    var i = goog.array.indexOf(arr, obj);
    var rv;
    if (rv = i >= 0) goog.array.removeAt(arr, i);
    return rv
};
goog.array.removeLast = function(arr, obj) {
    var i = goog.array.lastIndexOf(arr, obj);
    if (i >= 0) {
        goog.array.removeAt(arr, i);
        return true
    }
    return false
};
goog.array.removeAt = function(arr, i) {
    goog.asserts.assert(arr.length != null);
    return Array.prototype.splice.call(arr, i, 1).length == 1
};
goog.array.removeIf = function(arr, f, opt_obj) {
    var i = goog.array.findIndex(arr, f, opt_obj);
    if (i >= 0) {
        goog.array.removeAt(arr, i);
        return true
    }
    return false
};
goog.array.removeAllIf = function(arr, f, opt_obj) {
    var removedCount = 0;
    goog.array.forEachRight(arr, function(val, index) {
        if (f.call(opt_obj, val, index, arr))
            if (goog.array.removeAt(arr, index)) removedCount++
    });
    return removedCount
};
goog.array.concat = function(var_args) {
    return Array.prototype.concat.apply([], arguments)
};
goog.array.join = function(var_args) {
    return Array.prototype.concat.apply([], arguments)
};
goog.array.toArray = function(object) {
    var length = object.length;
    if (length > 0) {
        var rv = new Array(length);
        for (var i = 0; i < length; i++) rv[i] = object[i];
        return rv
    }
    return []
};
goog.array.clone = goog.array.toArray;
goog.array.extend = function(arr1, var_args) {
    for (var i = 1; i < arguments.length; i++) {
        var arr2 = arguments[i];
        if (goog.isArrayLike(arr2)) {
            var len1 = arr1.length || 0;
            var len2 = arr2.length || 0;
            arr1.length = len1 + len2;
            for (var j = 0; j < len2; j++) arr1[len1 + j] = arr2[j]
        } else arr1.push(arr2)
    }
};
goog.array.splice = function(arr, index, howMany, var_args) {
    goog.asserts.assert(arr.length != null);
    return Array.prototype.splice.apply(arr, goog.array.slice(arguments, 1))
};
goog.array.slice = function(arr, start, opt_end) {
    goog.asserts.assert(arr.length != null);
    if (arguments.length <= 2) return Array.prototype.slice.call(arr, start);
    else return Array.prototype.slice.call(arr, start, opt_end)
};
goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {
    var returnArray = opt_rv || arr;
    var defaultHashFn = function(item) {
        return goog.isObject(item) ? "o" + goog.getUid(item) : (typeof item).charAt(0) + item
    };
    var hashFn = opt_hashFn || defaultHashFn;
    var seen = {},
        cursorInsert = 0,
        cursorRead = 0;
    while (cursorRead < arr.length) {
        var current = arr[cursorRead++];
        var key = hashFn(current);
        if (!Object.prototype.hasOwnProperty.call(seen, key)) {
            seen[key] = true;
            returnArray[cursorInsert++] = current
        }
    }
    returnArray.length = cursorInsert
};
goog.array.binarySearch = function(arr, target, opt_compareFn) {
    return goog.array.binarySearch_(arr, opt_compareFn || goog.array.defaultCompare, false, target)
};
goog.array.binarySelect = function(arr, evaluator, opt_obj) {
    return goog.array.binarySearch_(arr, evaluator, true, undefined, opt_obj)
};
goog.array.binarySearch_ = function(arr, compareFn, isEvaluator, opt_target, opt_selfObj) {
    var left = 0;
    var right = arr.length;
    var found;
    while (left < right) {
        var middle = left + right >> 1;
        var compareResult;
        if (isEvaluator) compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
        else compareResult = compareFn(opt_target, arr[middle]);
        if (compareResult > 0) left = middle + 1;
        else {
            right = middle;
            found = !compareResult
        }
    }
    return found ? left : ~left
};
goog.array.sort = function(arr, opt_compareFn) {
    arr.sort(opt_compareFn || goog.array.defaultCompare)
};
goog.array.stableSort = function(arr, opt_compareFn) {
    var compArr = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) compArr[i] = {
        index: i,
        value: arr[i]
    };
    var valueCompareFn = opt_compareFn || goog.array.defaultCompare;

    function stableCompareFn(obj1, obj2) {
        return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index
    }
    goog.array.sort(compArr, stableCompareFn);
    for (var i = 0; i < arr.length; i++) arr[i] = compArr[i].value
};
goog.array.sortByKey = function(arr, keyFn, opt_compareFn) {
    var keyCompareFn = opt_compareFn || goog.array.defaultCompare;
    goog.array.sort(arr, function(a, b) {
        return keyCompareFn(keyFn(a), keyFn(b))
    })
};
goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {
    goog.array.sortByKey(arr, function(obj) {
        return obj[key]
    }, opt_compareFn)
};
goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {
    var compare = opt_compareFn || goog.array.defaultCompare;
    for (var i = 1; i < arr.length; i++) {
        var compareResult = compare(arr[i - 1], arr[i]);
        if (compareResult > 0 || compareResult == 0 && opt_strict) return false
    }
    return true
};
goog.array.equals = function(arr1, arr2, opt_equalsFn) {
    if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) || arr1.length != arr2.length) return false;
    var l = arr1.length;
    var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
    for (var i = 0; i < l; i++)
        if (!equalsFn(arr1[i], arr2[i])) return false;
    return true
};
goog.array.compare3 = function(arr1, arr2, opt_compareFn) {
    var compare = opt_compareFn || goog.array.defaultCompare;
    var l = Math.min(arr1.length, arr2.length);
    for (var i = 0; i < l; i++) {
        var result = compare(arr1[i], arr2[i]);
        if (result != 0) return result
    }
    return goog.array.defaultCompare(arr1.length, arr2.length)
};
goog.array.defaultCompare = function(a, b) {
    return a > b ? 1 : a < b ? -1 : 0
};
goog.array.inverseDefaultCompare = function(a, b) {
    return -goog.array.defaultCompare(a, b)
};
goog.array.defaultCompareEquality = function(a, b) {
    return a === b
};
goog.array.binaryInsert = function(array, value, opt_compareFn) {
    var index = goog.array.binarySearch(array, value, opt_compareFn);
    if (index < 0) {
        goog.array.insertAt(array, value, -(index + 1));
        return true
    }
    return false
};
goog.array.binaryRemove = function(array, value, opt_compareFn) {
    var index = goog.array.binarySearch(array, value, opt_compareFn);
    return index >= 0 ? goog.array.removeAt(array, index) : false
};
goog.array.bucket = function(array, sorter, opt_obj) {
    var buckets = {};
    for (var i = 0; i < array.length; i++) {
        var value = array[i];
        var key = sorter.call(opt_obj, value, i, array);
        if (goog.isDef(key)) {
            var bucket = buckets[key] || (buckets[key] = []);
            bucket.push(value)
        }
    }
    return buckets
};
goog.array.toObject = function(arr, keyFunc, opt_obj) {
    var ret = {};
    goog.array.forEach(arr, function(element, index) {
        ret[keyFunc.call(opt_obj, element, index, arr)] = element
    });
    return ret
};
goog.array.range = function(startOrEnd, opt_end, opt_step) {
    var array = [];
    var start = 0;
    var end = startOrEnd;
    var step = opt_step || 1;
    if (opt_end !== undefined) {
        start = startOrEnd;
        end = opt_end
    }
    if (step * (end - start) < 0) return [];
    if (step > 0)
        for (var i = start; i < end; i += step) array.push(i);
    else
        for (var i = start; i > end; i += step) array.push(i);
    return array
};
goog.array.repeat = function(value, n) {
    var array = [];
    for (var i = 0; i < n; i++) array[i] = value;
    return array
};
goog.array.flatten = function(var_args) {
    var CHUNK_SIZE = 8192;
    var result = [];
    for (var i = 0; i < arguments.length; i++) {
        var element = arguments[i];
        if (goog.isArray(element))
            for (var c = 0; c < element.length; c += CHUNK_SIZE) {
                var chunk = goog.array.slice(element, c, c + CHUNK_SIZE);
                var recurseResult = goog.array.flatten.apply(null, chunk);
                for (var r = 0; r < recurseResult.length; r++) result.push(recurseResult[r])
            } else result.push(element)
    }
    return result
};
goog.array.rotate = function(array, n) {
    goog.asserts.assert(array.length != null);
    if (array.length) {
        n %= array.length;
        if (n > 0) Array.prototype.unshift.apply(array, array.splice(-n, n));
        else if (n < 0) Array.prototype.push.apply(array, array.splice(0, -n))
    }
    return array
};
goog.array.moveItem = function(arr, fromIndex, toIndex) {
    goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
    goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
    var removedItems = Array.prototype.splice.call(arr, fromIndex, 1);
    Array.prototype.splice.call(arr, toIndex, 0, removedItems[0])
};
goog.array.zip = function(var_args) {
    if (!arguments.length) return [];
    var result = [];
    var minLen = arguments[0].length;
    for (var i = 1; i < arguments.length; i++)
        if (arguments[i].length < minLen) minLen = arguments[i].length;
    for (var i = 0; i < minLen; i++) {
        var value = [];
        for (var j = 0; j < arguments.length; j++) value.push(arguments[j][i]);
        result.push(value)
    }
    return result
};
goog.array.shuffle = function(arr, opt_randFn) {
    var randFn = opt_randFn || Math.random;
    for (var i = arr.length - 1; i > 0; i--) {
        var j = Math.floor(randFn() * (i + 1));
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp
    }
};
goog.array.copyByIndex = function(arr, index_arr) {
    var result = [];
    goog.array.forEach(index_arr, function(index) {
        result.push(arr[index])
    });
    return result
};
goog.array.concatMap = function(arr, f, opt_obj) {
    return goog.array.concat.apply([], goog.array.map(arr, f, opt_obj))
};
goog.provide("goog.math");
goog.require("goog.array");
goog.require("goog.asserts");
goog.math.randomInt = function(a) {
    return Math.floor(Math.random() * a)
};
goog.math.uniformRandom = function(a, b) {
    return a + Math.random() * (b - a)
};
goog.math.clamp = function(value, min, max) {
    return Math.min(Math.max(value, min), max)
};
goog.math.modulo = function(a, b) {
    var r = a % b;
    return r * b < 0 ? r + b : r
};
goog.math.lerp = function(a, b, x) {
    return a + x * (b - a)
};
goog.math.nearlyEquals = function(a, b, opt_tolerance) {
    return Math.abs(a - b) <= (opt_tolerance || 1E-6)
};
goog.math.standardAngle = function(angle) {
    return goog.math.modulo(angle, 360)
};
goog.math.standardAngleInRadians = function(angle) {
    return goog.math.modulo(angle, 2 * Math.PI)
};
goog.math.toRadians = function(angleDegrees) {
    return angleDegrees * Math.PI / 180
};
goog.math.toDegrees = function(angleRadians) {
    return angleRadians * 180 / Math.PI
};
goog.math.angleDx = function(degrees, radius) {
    return radius * Math.cos(goog.math.toRadians(degrees))
};
goog.math.angleDy = function(degrees, radius) {
    return radius * Math.sin(goog.math.toRadians(degrees))
};
goog.math.angle = function(x1, y1, x2, y2) {
    return goog.math.standardAngle(goog.math.toDegrees(Math.atan2(y2 - y1, x2 - x1)))
};
goog.math.angleDifference = function(startAngle, endAngle) {
    var d = goog.math.standardAngle(endAngle) - goog.math.standardAngle(startAngle);
    if (d > 180) d = d - 360;
    else if (d <= -180) d = 360 + d;
    return d
};
goog.math.sign = function(x) {
    if (x > 0) return 1;
    if (x < 0) return -1;
    return x
};
goog.math.longestCommonSubsequence = function(array1, array2, opt_compareFn, opt_collectorFn) {
    var compare = opt_compareFn || function(a, b) {
        return a == b
    };
    var collect = opt_collectorFn || function(i1, i2) {
        return array1[i1]
    };
    var length1 = array1.length;
    var length2 = array2.length;
    var arr = [];
    for (var i = 0; i < length1 + 1; i++) {
        arr[i] = [];
        arr[i][0] = 0
    }
    for (var j = 0; j < length2 + 1; j++) arr[0][j] = 0;
    for (i = 1; i <= length1; i++)
        for (j = 1; j <= length2; j++)
            if (compare(array1[i - 1], array2[j - 1])) arr[i][j] = arr[i - 1][j - 1] + 1;
            else arr[i][j] = Math.max(arr[i - 1][j],
                arr[i][j - 1]);
    var result = [];
    var i = length1,
        j = length2;
    while (i > 0 && j > 0)
        if (compare(array1[i - 1], array2[j - 1])) {
            result.unshift(collect(i - 1, j - 1));
            i--;
            j--
        } else if (arr[i - 1][j] > arr[i][j - 1]) i--;
    else j--;
    return result
};
goog.math.sum = function(var_args) {
    return goog.array.reduce(arguments, function(sum, value) {
        return sum + value
    }, 0)
};
goog.math.average = function(var_args) {
    return goog.math.sum.apply(null, arguments) / arguments.length
};
goog.math.sampleVariance = function(var_args) {
    var sampleSize = arguments.length;
    if (sampleSize < 2) return 0;
    var mean = goog.math.average.apply(null, arguments);
    var variance = goog.math.sum.apply(null, goog.array.map(arguments, function(val) {
        return Math.pow(val - mean, 2)
    })) / (sampleSize - 1);
    return variance
};
goog.math.standardDeviation = function(var_args) {
    return Math.sqrt(goog.math.sampleVariance.apply(null, arguments))
};
goog.math.isInt = function(num) {
    return isFinite(num) && num % 1 == 0
};
goog.math.isFiniteNumber = function(num) {
    return isFinite(num)
};
goog.math.isNegativeZero = function(num) {
    return num == 0 && 1 / num < 0
};
goog.math.log10Floor = function(num) {
    if (num > 0) {
        var x = Math.round(Math.log(num) * Math.LOG10E);
        return x - (parseFloat("1e" + x) > num ? 1 : 0)
    }
    return num == 0 ? -Infinity : NaN
};
goog.math.safeFloor = function(num, opt_epsilon) {
    goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
    return Math.floor(num + (opt_epsilon || 2E-15))
};
goog.math.safeCeil = function(num, opt_epsilon) {
    goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
    return Math.ceil(num - (opt_epsilon || 2E-15))
};
goog.provide("goog.math.Coordinate");
goog.require("goog.math");
goog.math.Coordinate = function(opt_x, opt_y) {
    this.x = goog.isDef(opt_x) ? opt_x : 0;
    this.y = goog.isDef(opt_y) ? opt_y : 0
};
goog.math.Coordinate.prototype.clone = function() {
    return new goog.math.Coordinate(this.x, this.y)
};
if (goog.DEBUG) goog.math.Coordinate.prototype.toString = function() {
    return "(" + this.x + ", " + this.y + ")"
};
goog.math.Coordinate.prototype.equals = function(other) {
    return other instanceof goog.math.Coordinate && goog.math.Coordinate.equals(this, other)
};
goog.math.Coordinate.equals = function(a, b) {
    if (a == b) return true;
    if (!a || !b) return false;
    return a.x == b.x && a.y == b.y
};
goog.math.Coordinate.distance = function(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy)
};
goog.math.Coordinate.magnitude = function(a) {
    return Math.sqrt(a.x * a.x + a.y * a.y)
};
goog.math.Coordinate.azimuth = function(a) {
    return goog.math.angle(0, 0, a.x, a.y)
};
goog.math.Coordinate.squaredDistance = function(a, b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return dx * dx + dy * dy
};
goog.math.Coordinate.difference = function(a, b) {
    return new goog.math.Coordinate(a.x - b.x, a.y - b.y)
};
goog.math.Coordinate.sum = function(a, b) {
    return new goog.math.Coordinate(a.x + b.x, a.y + b.y)
};
goog.math.Coordinate.prototype.ceil = function() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this
};
goog.math.Coordinate.prototype.floor = function() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this
};
goog.math.Coordinate.prototype.round = function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this
};
goog.math.Coordinate.prototype.translate = function(tx, opt_ty) {
    if (tx instanceof goog.math.Coordinate) {
        this.x += tx.x;
        this.y += tx.y
    } else {
        this.x += Number(tx);
        if (goog.isNumber(opt_ty)) this.y += opt_ty
    }
    return this
};
goog.math.Coordinate.prototype.scale = function(sx, opt_sy) {
    var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
    this.x *= sx;
    this.y *= sy;
    return this
};
goog.math.Coordinate.prototype.rotateRadians = function(radians, opt_center) {
    var center = opt_center || new goog.math.Coordinate(0, 0);
    var x = this.x;
    var y = this.y;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);
    this.x = (x - center.x) * cos - (y - center.y) * sin + center.x;
    this.y = (x - center.x) * sin + (y - center.y) * cos + center.y
};
goog.math.Coordinate.prototype.rotateDegrees = function(degrees, opt_center) {
    this.rotateRadians(goog.math.toRadians(degrees), opt_center)
};
goog.provide("goog.color.names");
goog.color.names = {
    "aliceblue": "#f0f8ff",
    "antiquewhite": "#faebd7",
    "aqua": "#00ffff",
    "aquamarine": "#7fffd4",
    "azure": "#f0ffff",
    "beige": "#f5f5dc",
    "bisque": "#ffe4c4",
    "black": "#000000",
    "blanchedalmond": "#ffebcd",
    "blue": "#0000ff",
    "blueviolet": "#8a2be2",
    "brown": "#a52a2a",
    "burlywood": "#deb887",
    "cadetblue": "#5f9ea0",
    "chartreuse": "#7fff00",
    "chocolate": "#d2691e",
    "coral": "#ff7f50",
    "cornflowerblue": "#6495ed",
    "cornsilk": "#fff8dc",
    "crimson": "#dc143c",
    "cyan": "#00ffff",
    "darkblue": "#00008b",
    "darkcyan": "#008b8b",
    "darkgoldenrod": "#b8860b",
    "darkgray": "#a9a9a9",
    "darkgreen": "#006400",
    "darkgrey": "#a9a9a9",
    "darkkhaki": "#bdb76b",
    "darkmagenta": "#8b008b",
    "darkolivegreen": "#556b2f",
    "darkorange": "#ff8c00",
    "darkorchid": "#9932cc",
    "darkred": "#8b0000",
    "darksalmon": "#e9967a",
    "darkseagreen": "#8fbc8f",
    "darkslateblue": "#483d8b",
    "darkslategray": "#2f4f4f",
    "darkslategrey": "#2f4f4f",
    "darkturquoise": "#00ced1",
    "darkviolet": "#9400d3",
    "deeppink": "#ff1493",
    "deepskyblue": "#00bfff",
    "dimgray": "#696969",
    "dimgrey": "#696969",
    "dodgerblue": "#1e90ff",
    "firebrick": "#b22222",
    "floralwhite": "#fffaf0",
    "forestgreen": "#228b22",
    "fuchsia": "#ff00ff",
    "gainsboro": "#dcdcdc",
    "ghostwhite": "#f8f8ff",
    "gold": "#ffd700",
    "goldenrod": "#daa520",
    "gray": "#808080",
    "green": "#008000",
    "greenyellow": "#adff2f",
    "grey": "#808080",
    "honeydew": "#f0fff0",
    "hotpink": "#ff69b4",
    "indianred": "#cd5c5c",
    "indigo": "#4b0082",
    "ivory": "#fffff0",
    "khaki": "#f0e68c",
    "lavender": "#e6e6fa",
    "lavenderblush": "#fff0f5",
    "lawngreen": "#7cfc00",
    "lemonchiffon": "#fffacd",
    "lightblue": "#add8e6",
    "lightcoral": "#f08080",
    "lightcyan": "#e0ffff",
    "lightgoldenrodyellow": "#fafad2",
    "lightgray": "#d3d3d3",
    "lightgreen": "#90ee90",
    "lightgrey": "#d3d3d3",
    "lightpink": "#ffb6c1",
    "lightsalmon": "#ffa07a",
    "lightseagreen": "#20b2aa",
    "lightskyblue": "#87cefa",
    "lightslategray": "#778899",
    "lightslategrey": "#778899",
    "lightsteelblue": "#b0c4de",
    "lightyellow": "#ffffe0",
    "lime": "#00ff00",
    "limegreen": "#32cd32",
    "linen": "#faf0e6",
    "magenta": "#ff00ff",
    "maroon": "#800000",
    "mediumaquamarine": "#66cdaa",
    "mediumblue": "#0000cd",
    "mediumorchid": "#ba55d3",
    "mediumpurple": "#9370db",
    "mediumseagreen": "#3cb371",
    "mediumslateblue": "#7b68ee",
    "mediumspringgreen": "#00fa9a",
    "mediumturquoise": "#48d1cc",
    "mediumvioletred": "#c71585",
    "midnightblue": "#191970",
    "mintcream": "#f5fffa",
    "mistyrose": "#ffe4e1",
    "moccasin": "#ffe4b5",
    "navajowhite": "#ffdead",
    "navy": "#000080",
    "oldlace": "#fdf5e6",
    "olive": "#808000",
    "olivedrab": "#6b8e23",
    "orange": "#ffa500",
    "orangered": "#ff4500",
    "orchid": "#da70d6",
    "palegoldenrod": "#eee8aa",
    "palegreen": "#98fb98",
    "paleturquoise": "#afeeee",
    "palevioletred": "#db7093",
    "papayawhip": "#ffefd5",
    "peachpuff": "#ffdab9",
    "peru": "#cd853f",
    "pink": "#ffc0cb",
    "plum": "#dda0dd",
    "powderblue": "#b0e0e6",
    "purple": "#800080",
    "red": "#ff0000",
    "rosybrown": "#bc8f8f",
    "royalblue": "#4169e1",
    "saddlebrown": "#8b4513",
    "salmon": "#fa8072",
    "sandybrown": "#f4a460",
    "seagreen": "#2e8b57",
    "seashell": "#fff5ee",
    "sienna": "#a0522d",
    "silver": "#c0c0c0",
    "skyblue": "#87ceeb",
    "slateblue": "#6a5acd",
    "slategray": "#708090",
    "slategrey": "#708090",
    "snow": "#fffafa",
    "springgreen": "#00ff7f",
    "steelblue": "#4682b4",
    "tan": "#d2b48c",
    "teal": "#008080",
    "thistle": "#d8bfd8",
    "tomato": "#ff6347",
    "turquoise": "#40e0d0",
    "violet": "#ee82ee",
    "wheat": "#f5deb3",
    "white": "#ffffff",
    "whitesmoke": "#f5f5f5",
    "yellow": "#ffff00",
    "yellowgreen": "#9acd32"
};
goog.provide("goog.color");
goog.provide("goog.color.Hsl");
goog.provide("goog.color.Hsv");
goog.provide("goog.color.Rgb");
goog.require("goog.color.names");
goog.require("goog.math");
goog.color.Rgb;
goog.color.Hsv;
goog.color.Hsl;
goog.color.parse = function(str) {
    var result = {};
    str = String(str);
    var maybeHex = goog.color.prependHashIfNecessaryHelper(str);
    if (goog.color.isValidHexColor_(maybeHex)) {
        result.hex = goog.color.normalizeHex(maybeHex);
        result.type = "hex";
        return result
    } else {
        var rgb = goog.color.isValidRgbColor_(str);
        if (rgb.length) {
            result.hex = goog.color.rgbArrayToHex(rgb);
            result.type = "rgb";
            return result
        } else if (goog.color.names) {
            var hex = goog.color.names[str.toLowerCase()];
            if (hex) {
                result.hex = hex;
                result.type = "named";
                return result
            }
        }
    }
    throw Error(str +
        " is not a valid color string");
};
goog.color.isValidColor = function(str) {
    var maybeHex = goog.color.prependHashIfNecessaryHelper(str);
    return !!(goog.color.isValidHexColor_(maybeHex) || goog.color.isValidRgbColor_(str).length || goog.color.names && goog.color.names[str.toLowerCase()])
};
goog.color.parseRgb = function(str) {
    var rgb = goog.color.isValidRgbColor_(str);
    if (!rgb.length) throw Error(str + " is not a valid RGB color");
    return rgb
};
goog.color.hexToRgbStyle = function(hexColor) {
    return goog.color.rgbStyle_(goog.color.hexToRgb(hexColor))
};
goog.color.hexTripletRe_ = /#(.)(.)(.)/;
goog.color.normalizeHex = function(hexColor) {
    if (!goog.color.isValidHexColor_(hexColor)) throw Error("'" + hexColor + "' is not a valid hex color");
    if (hexColor.length == 4) hexColor = hexColor.replace(goog.color.hexTripletRe_, "#$1$1$2$2$3$3");
    return hexColor.toLowerCase()
};
goog.color.hexToRgb = function(hexColor) {
    hexColor = goog.color.normalizeHex(hexColor);
    var r = parseInt(hexColor.substr(1, 2), 16);
    var g = parseInt(hexColor.substr(3, 2), 16);
    var b = parseInt(hexColor.substr(5, 2), 16);
    return [r, g, b]
};
goog.color.rgbToHex = function(r, g, b) {
    r = Number(r);
    g = Number(g);
    b = Number(b);
    if (r != (r & 255) || g != (g & 255) || b != (b & 255)) throw Error('"(' + r + "," + g + "," + b + '") is not a valid RGB color');
    var hexR = goog.color.prependZeroIfNecessaryHelper(r.toString(16));
    var hexG = goog.color.prependZeroIfNecessaryHelper(g.toString(16));
    var hexB = goog.color.prependZeroIfNecessaryHelper(b.toString(16));
    return "#" + hexR + hexG + hexB
};
goog.color.rgbArrayToHex = function(rgb) {
    return goog.color.rgbToHex(rgb[0], rgb[1], rgb[2])
};
goog.color.rgbToHsl = function(r, g, b) {
    var normR = r / 255;
    var normG = g / 255;
    var normB = b / 255;
    var max = Math.max(normR, normG, normB);
    var min = Math.min(normR, normG, normB);
    var h = 0;
    var s = 0;
    var l = .5 * (max + min);
    if (max != min) {
        if (max == normR) h = 60 * (normG - normB) / (max - min);
        else if (max == normG) h = 60 * (normB - normR) / (max - min) + 120;
        else if (max == normB) h = 60 * (normR - normG) / (max - min) + 240;
        if (0 < l && l <= .5) s = (max - min) / (2 * l);
        else s = (max - min) / (2 - 2 * l)
    }
    return [Math.round(h + 360) % 360, s, l]
};
goog.color.rgbArrayToHsl = function(rgb) {
    return goog.color.rgbToHsl(rgb[0], rgb[1], rgb[2])
};
goog.color.hueToRgb_ = function(v1, v2, vH) {
    if (vH < 0) vH += 1;
    else if (vH > 1) vH -= 1;
    if (6 * vH < 1) return v1 + (v2 - v1) * 6 * vH;
    else if (2 * vH < 1) return v2;
    else if (3 * vH < 2) return v1 + (v2 - v1) * (2 / 3 - vH) * 6;
    return v1
};
goog.color.hslToRgb = function(h, s, l) {
    var r = 0;
    var g = 0;
    var b = 0;
    var normH = h / 360;
    if (s == 0) r = g = b = l * 255;
    else {
        var temp1 = 0;
        var temp2 = 0;
        if (l < .5) temp2 = l * (1 + s);
        else temp2 = l + s - s * l;
        temp1 = 2 * l - temp2;
        r = 255 * goog.color.hueToRgb_(temp1, temp2, normH + 1 / 3);
        g = 255 * goog.color.hueToRgb_(temp1, temp2, normH);
        b = 255 * goog.color.hueToRgb_(temp1, temp2, normH - 1 / 3)
    }
    return [Math.round(r), Math.round(g), Math.round(b)]
};
goog.color.hslArrayToRgb = function(hsl) {
    return goog.color.hslToRgb(hsl[0], hsl[1], hsl[2])
};
goog.color.validHexColorRe_ = /^#(?:[0-9a-f]{3}){1,2}$/i;
goog.color.isValidHexColor_ = function(str) {
    return goog.color.validHexColorRe_.test(str)
};
goog.color.normalizedHexColorRe_ = /^#[0-9a-f]{6}$/;
goog.color.isNormalizedHexColor_ = function(str) {
    return goog.color.normalizedHexColorRe_.test(str)
};
goog.color.rgbColorRe_ = /^(?:rgb)?\((0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2}),\s?(0|[1-9]\d{0,2})\)$/i;
goog.color.isValidRgbColor_ = function(str) {
    var regExpResultArray = str.match(goog.color.rgbColorRe_);
    if (regExpResultArray) {
        var r = Number(regExpResultArray[1]);
        var g = Number(regExpResultArray[2]);
        var b = Number(regExpResultArray[3]);
        if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) return [r, g, b]
    }
    return []
};
goog.color.prependZeroIfNecessaryHelper = function(hex) {
    return hex.length == 1 ? "0" + hex : hex
};
goog.color.prependHashIfNecessaryHelper = function(str) {
    return str.charAt(0) == "#" ? str : "#" + str
};
goog.color.rgbStyle_ = function(rgb) {
    return "rgb(" + rgb.join(",") + ")"
};
goog.color.hsvToRgb = function(h, s, brightness) {
    var red = 0;
    var green = 0;
    var blue = 0;
    if (s == 0) {
        red = brightness;
        green = brightness;
        blue = brightness
    } else {
        var sextant = Math.floor(h / 60);
        var remainder = h / 60 - sextant;
        var val1 = brightness * (1 - s);
        var val2 = brightness * (1 - s * remainder);
        var val3 = brightness * (1 - s * (1 - remainder));
        switch (sextant) {
            case 1:
                red = val2;
                green = brightness;
                blue = val1;
                break;
            case 2:
                red = val1;
                green = brightness;
                blue = val3;
                break;
            case 3:
                red = val1;
                green = val2;
                blue = brightness;
                break;
            case 4:
                red = val3;
                green = val1;
                blue = brightness;
                break;
            case 5:
                red = brightness;
                green = val1;
                blue = val2;
                break;
            case 6:
            case 0:
                red = brightness;
                green = val3;
                blue = val1;
                break
        }
    }
    return [Math.floor(red), Math.floor(green), Math.floor(blue)]
};
goog.color.rgbToHsv = function(red, green, blue) {
    var max = Math.max(Math.max(red, green), blue);
    var min = Math.min(Math.min(red, green), blue);
    var hue;
    var saturation;
    var value = max;
    if (min == max) {
        hue = 0;
        saturation = 0
    } else {
        var delta = max - min;
        saturation = delta / max;
        if (red == max) hue = (green - blue) / delta;
        else if (green == max) hue = 2 + (blue - red) / delta;
        else hue = 4 + (red - green) / delta;
        hue *= 60;
        if (hue < 0) hue += 360;
        if (hue > 360) hue -= 360
    }
    return [hue, saturation, value]
};
goog.color.rgbArrayToHsv = function(rgb) {
    return goog.color.rgbToHsv(rgb[0], rgb[1], rgb[2])
};
goog.color.hsvArrayToRgb = function(hsv) {
    return goog.color.hsvToRgb(hsv[0], hsv[1], hsv[2])
};
goog.color.hexToHsl = function(hex) {
    var rgb = goog.color.hexToRgb(hex);
    return goog.color.rgbToHsl(rgb[0], rgb[1], rgb[2])
};
goog.color.hslToHex = function(h, s, l) {
    return goog.color.rgbArrayToHex(goog.color.hslToRgb(h, s, l))
};
goog.color.hslArrayToHex = function(hsl) {
    return goog.color.rgbArrayToHex(goog.color.hslToRgb(hsl[0], hsl[1], hsl[2]))
};
goog.color.hexToHsv = function(hex) {
    return goog.color.rgbArrayToHsv(goog.color.hexToRgb(hex))
};
goog.color.hsvToHex = function(h, s, v) {
    return goog.color.rgbArrayToHex(goog.color.hsvToRgb(h, s, v))
};
goog.color.hsvArrayToHex = function(hsv) {
    return goog.color.hsvToHex(hsv[0], hsv[1], hsv[2])
};
goog.color.hslDistance = function(hsl1, hsl2) {
    var sl1, sl2;
    if (hsl1[2] <= .5) sl1 = hsl1[1] * hsl1[2];
    else sl1 = hsl1[1] * (1 - hsl1[2]);
    if (hsl2[2] <= .5) sl2 = hsl2[1] * hsl2[2];
    else sl2 = hsl2[1] * (1 - hsl2[2]);
    var h1 = hsl1[0] / 360;
    var h2 = hsl2[0] / 360;
    var dh = (h1 - h2) * 2 * Math.PI;
    return (hsl1[2] - hsl2[2]) * (hsl1[2] - hsl2[2]) + sl1 * sl1 + sl2 * sl2 - 2 * sl1 * sl2 * Math.cos(dh)
};
goog.color.blend = function(rgb1, rgb2, factor) {
    factor = goog.math.clamp(factor, 0, 1);
    return [Math.round(rgb2[0] + factor * (rgb1[0] - rgb2[0])), Math.round(rgb2[1] + factor * (rgb1[1] - rgb2[1])), Math.round(rgb2[2] + factor * (rgb1[2] - rgb2[2]))]
};
goog.color.darken = function(rgb, factor) {
    var black = [0, 0, 0];
    return goog.color.blend(black, rgb, factor)
};
goog.color.lighten = function(rgb, factor) {
    var white = [255, 255, 255];
    return goog.color.blend(white, rgb, factor)
};
goog.color.highContrast = function(prime, suggestions) {
    var suggestionsWithDiff = [];
    for (var i = 0; i < suggestions.length; i++) suggestionsWithDiff.push({
        color: suggestions[i],
        diff: goog.color.yiqBrightnessDiff_(suggestions[i], prime) + goog.color.colorDiff_(suggestions[i], prime)
    });
    suggestionsWithDiff.sort(function(a, b) {
        return b.diff - a.diff
    });
    return suggestionsWithDiff[0].color
};
goog.color.yiqBrightness_ = function(rgb) {
    return Math.round((rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1E3)
};
goog.color.yiqBrightnessDiff_ = function(rgb1, rgb2) {
    return Math.abs(goog.color.yiqBrightness_(rgb1) - goog.color.yiqBrightness_(rgb2))
};
goog.color.colorDiff_ = function(rgb1, rgb2) {
    return Math.abs(rgb1[0] - rgb2[0]) + Math.abs(rgb1[1] - rgb2[1]) + Math.abs(rgb1[2] - rgb2[2])
};
goog.provide("goog.string");
goog.provide("goog.string.Unicode");
goog.define("goog.string.DETECT_DOUBLE_ESCAPING", false);
goog.define("goog.string.FORCE_NON_DOM_HTML_UNESCAPING", false);
goog.string.Unicode = {
    NBSP: "\u00a0"
};
goog.string.startsWith = function(str, prefix) {
    return str.lastIndexOf(prefix, 0) == 0
};
goog.string.endsWith = function(str, suffix) {
    var l = str.length - suffix.length;
    return l >= 0 && str.indexOf(suffix, l) == l
};
goog.string.caseInsensitiveStartsWith = function(str, prefix) {
    return goog.string.caseInsensitiveCompare(prefix, str.substr(0, prefix.length)) == 0
};
goog.string.caseInsensitiveEndsWith = function(str, suffix) {
    return goog.string.caseInsensitiveCompare(suffix, str.substr(str.length - suffix.length, suffix.length)) == 0
};
goog.string.caseInsensitiveEquals = function(str1, str2) {
    return str1.toLowerCase() == str2.toLowerCase()
};
goog.string.subs = function(str, var_args) {
    var splitParts = str.split("%s");
    var returnString = "";
    var subsArguments = Array.prototype.slice.call(arguments, 1);
    while (subsArguments.length && splitParts.length > 1) returnString += splitParts.shift() + subsArguments.shift();
    return returnString + splitParts.join("%s")
};
goog.string.collapseWhitespace = function(str) {
    return str.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "")
};
goog.string.isEmptyOrWhitespace = function(str) {
    return /^[\s\xa0]*$/.test(str)
};
goog.string.isEmptyString = function(str) {
    return str.length == 0
};
goog.string.isEmpty = goog.string.isEmptyOrWhitespace;
goog.string.isEmptyOrWhitespaceSafe = function(str) {
    return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(str))
};
goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;
goog.string.isBreakingWhitespace = function(str) {
    return !/[^\t\n\r ]/.test(str)
};
goog.string.isAlpha = function(str) {
    return !/[^a-zA-Z]/.test(str)
};
goog.string.isNumeric = function(str) {
    return !/[^0-9]/.test(str)
};
goog.string.isAlphaNumeric = function(str) {
    return !/[^a-zA-Z0-9]/.test(str)
};
goog.string.isSpace = function(ch) {
    return ch == " "
};
goog.string.isUnicodeChar = function(ch) {
    return ch.length == 1 && ch >= " " && ch <= "~" || ch >= "\u0080" && ch <= "\ufffd"
};
goog.string.stripNewlines = function(str) {
    return str.replace(/(\r\n|\r|\n)+/g, " ")
};
goog.string.canonicalizeNewlines = function(str) {
    return str.replace(/(\r\n|\r|\n)/g, "\n")
};
goog.string.normalizeWhitespace = function(str) {
    return str.replace(/\xa0|\s/g, " ")
};
goog.string.normalizeSpaces = function(str) {
    return str.replace(/\xa0|[ \t]+/g, " ")
};
goog.string.collapseBreakingSpaces = function(str) {
    return str.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "")
};
goog.string.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(str) {
    return str.trim()
} : function(str) {
    return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(str)[1]
};
goog.string.trimLeft = function(str) {
    return str.replace(/^[\s\xa0]+/, "")
};
goog.string.trimRight = function(str) {
    return str.replace(/[\s\xa0]+$/, "")
};
goog.string.caseInsensitiveCompare = function(str1, str2) {
    var test1 = String(str1).toLowerCase();
    var test2 = String(str2).toLowerCase();
    if (test1 < test2) return -1;
    else if (test1 == test2) return 0;
    else return 1
};
goog.string.numberAwareCompare_ = function(str1, str2, tokenizerRegExp) {
    if (str1 == str2) return 0;
    if (!str1) return -1;
    if (!str2) return 1;
    var tokens1 = str1.toLowerCase().match(tokenizerRegExp);
    var tokens2 = str2.toLowerCase().match(tokenizerRegExp);
    var count = Math.min(tokens1.length, tokens2.length);
    for (var i = 0; i < count; i++) {
        var a = tokens1[i];
        var b = tokens2[i];
        if (a != b) {
            var num1 = parseInt(a, 10);
            if (!isNaN(num1)) {
                var num2 = parseInt(b, 10);
                if (!isNaN(num2) && num1 - num2) return num1 - num2
            }
            return a < b ? -1 : 1
        }
    }
    if (tokens1.length != tokens2.length) return tokens1.length -
        tokens2.length;
    return str1 < str2 ? -1 : 1
};
goog.string.intAwareCompare = function(str1, str2) {
    return goog.string.numberAwareCompare_(str1, str2, /\d+|\D+/g)
};
goog.string.floatAwareCompare = function(str1, str2) {
    return goog.string.numberAwareCompare_(str1, str2, /\d+|\.\d+|\D+/g)
};
goog.string.numerateCompare = goog.string.floatAwareCompare;
goog.string.urlEncode = function(str) {
    return encodeURIComponent(String(str))
};
goog.string.urlDecode = function(str) {
    return decodeURIComponent(str.replace(/\+/g, " "))
};
goog.string.newLineToBr = function(str, opt_xml) {
    return str.replace(/(\r\n|\r|\n)/g, opt_xml ? "<br />" : "<br>")
};
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {
    if (opt_isLikelyToContainHtmlChars) {
        str = str.replace(goog.string.AMP_RE_, "&amp;").replace(goog.string.LT_RE_, "&lt;").replace(goog.string.GT_RE_, "&gt;").replace(goog.string.QUOT_RE_, "&quot;").replace(goog.string.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.NULL_RE_, "&#0;");
        if (goog.string.DETECT_DOUBLE_ESCAPING) str = str.replace(goog.string.E_RE_, "&#101;");
        return str
    } else {
        if (!goog.string.ALL_RE_.test(str)) return str;
        if (str.indexOf("&") !=
            -1) str = str.replace(goog.string.AMP_RE_, "&amp;");
        if (str.indexOf("<") != -1) str = str.replace(goog.string.LT_RE_, "&lt;");
        if (str.indexOf(">") != -1) str = str.replace(goog.string.GT_RE_, "&gt;");
        if (str.indexOf('"') != -1) str = str.replace(goog.string.QUOT_RE_, "&quot;");
        if (str.indexOf("'") != -1) str = str.replace(goog.string.SINGLE_QUOTE_RE_, "&#39;");
        if (str.indexOf("\x00") != -1) str = str.replace(goog.string.NULL_RE_, "&#0;");
        if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf("e") != -1) str = str.replace(goog.string.E_RE_, "&#101;");
        return str
    }
};
goog.string.AMP_RE_ = /&/g;
goog.string.LT_RE_ = /</g;
goog.string.GT_RE_ = />/g;
goog.string.QUOT_RE_ = /"/g;
goog.string.SINGLE_QUOTE_RE_ = /'/g;
goog.string.NULL_RE_ = /\x00/g;
goog.string.E_RE_ = /e/g;
goog.string.ALL_RE_ = goog.string.DETECT_DOUBLE_ESCAPING ? /[\x00&<>"'e]/ : /[\x00&<>"']/;
goog.string.unescapeEntities = function(str) {
    if (goog.string.contains(str, "&"))
        if (!goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global) return goog.string.unescapeEntitiesUsingDom_(str);
        else return goog.string.unescapePureXmlEntities_(str);
    return str
};
goog.string.unescapeEntitiesWithDocument = function(str, document) {
    if (goog.string.contains(str, "&")) return goog.string.unescapeEntitiesUsingDom_(str, document);
    return str
};
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
    var seen = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"'
    };
    var div;
    if (opt_document) div = opt_document.createElement("div");
    else div = goog.global.document.createElement("div");
    return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
        var value = seen[s];
        if (value) return value;
        if (entity.charAt(0) == "#") {
            var n = Number("0" + entity.substr(1));
            if (!isNaN(n)) value = String.fromCharCode(n)
        }
        if (!value) {
            div.innerHTML = s + " ";
            value = div.firstChild.nodeValue.slice(0,
                -1)
        }
        return seen[s] = value
    })
};
goog.string.unescapePureXmlEntities_ = function(str) {
    return str.replace(/&([^;]+);/g, function(s, entity) {
        switch (entity) {
            case "amp":
                return "&";
            case "lt":
                return "<";
            case "gt":
                return ">";
            case "quot":
                return '"';
            default:
                if (entity.charAt(0) == "#") {
                    var n = Number("0" + entity.substr(1));
                    if (!isNaN(n)) return String.fromCharCode(n)
                }
                return s
        }
    })
};
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
goog.string.whitespaceEscape = function(str, opt_xml) {
    return goog.string.newLineToBr(str.replace(/  /g, " &#160;"), opt_xml)
};
goog.string.preserveSpaces = function(str) {
    return str.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP)
};
goog.string.stripQuotes = function(str, quoteChars) {
    var length = quoteChars.length;
    for (var i = 0; i < length; i++) {
        var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
        if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) return str.substring(1, str.length - 1)
    }
    return str
};
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
    if (opt_protectEscapedCharacters) str = goog.string.unescapeEntities(str);
    if (str.length > chars) str = str.substring(0, chars - 3) + "...";
    if (opt_protectEscapedCharacters) str = goog.string.htmlEscape(str);
    return str
};
goog.string.truncateMiddle = function(str, chars, opt_protectEscapedCharacters, opt_trailingChars) {
    if (opt_protectEscapedCharacters) str = goog.string.unescapeEntities(str);
    if (opt_trailingChars && str.length > chars) {
        if (opt_trailingChars > chars) opt_trailingChars = chars;
        var endPoint = str.length - opt_trailingChars;
        var startPoint = chars - opt_trailingChars;
        str = str.substring(0, startPoint) + "..." + str.substring(endPoint)
    } else if (str.length > chars) {
        var half = Math.floor(chars / 2);
        var endPos = str.length - half;
        half += chars % 2;
        str = str.substring(0,
            half) + "..." + str.substring(endPos)
    }
    if (opt_protectEscapedCharacters) str = goog.string.htmlEscape(str);
    return str
};
goog.string.specialEscapeChars_ = {
    "\x00": "\\0",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t",
    "\x0B": "\\x0B",
    '"': '\\"',
    "\\": "\\\\",
    "<": "<"
};
goog.string.jsEscapeCache_ = {
    "'": "\\'"
};
goog.string.quote = function(s) {
    s = String(s);
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
        var ch = s.charAt(i);
        var cc = ch.charCodeAt(0);
        sb[i + 1] = goog.string.specialEscapeChars_[ch] || (cc > 31 && cc < 127 ? ch : goog.string.escapeChar(ch))
    }
    sb.push('"');
    return sb.join("")
};
goog.string.escapeString = function(str) {
    var sb = [];
    for (var i = 0; i < str.length; i++) sb[i] = goog.string.escapeChar(str.charAt(i));
    return sb.join("")
};
goog.string.escapeChar = function(c) {
    if (c in goog.string.jsEscapeCache_) return goog.string.jsEscapeCache_[c];
    if (c in goog.string.specialEscapeChars_) return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
    var rv = c;
    var cc = c.charCodeAt(0);
    if (cc > 31 && cc < 127) rv = c;
    else {
        if (cc < 256) {
            rv = "\\x";
            if (cc < 16 || cc > 256) rv += "0"
        } else {
            rv = "\\u";
            if (cc < 4096) rv += "0"
        }
        rv += cc.toString(16).toUpperCase()
    }
    return goog.string.jsEscapeCache_[c] = rv
};
goog.string.contains = function(str, subString) {
    return str.indexOf(subString) != -1
};
goog.string.caseInsensitiveContains = function(str, subString) {
    return goog.string.contains(str.toLowerCase(), subString.toLowerCase())
};
goog.string.countOf = function(s, ss) {
    return s && ss ? s.split(ss).length - 1 : 0
};
goog.string.removeAt = function(s, index, stringLength) {
    var resultStr = s;
    if (index >= 0 && index < s.length && stringLength > 0) resultStr = s.substr(0, index) + s.substr(index + stringLength, s.length - index - stringLength);
    return resultStr
};
goog.string.remove = function(str, substr) {
    return str.replace(substr, "")
};
goog.string.removeAll = function(s, ss) {
    var re = new RegExp(goog.string.regExpEscape(ss), "g");
    return s.replace(re, "")
};
goog.string.replaceAll = function(s, ss, replacement) {
    var re = new RegExp(goog.string.regExpEscape(ss), "g");
    return s.replace(re, replacement.replace(/\$/g, "$$$$"))
};
goog.string.regExpEscape = function(s) {
    return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
};
goog.string.repeat = String.prototype.repeat ? function(string, length) {
    return string.repeat(length)
} : function(string, length) {
    return (new Array(length + 1)).join(string)
};
goog.string.padNumber = function(num, length, opt_precision) {
    var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
    var index = s.indexOf(".");
    if (index == -1) index = s.length;
    return goog.string.repeat("0", Math.max(0, length - index)) + s
};
goog.string.makeSafe = function(obj) {
    return obj == null ? "" : String(obj)
};
goog.string.buildString = function(var_args) {
    return Array.prototype.join.call(arguments, "")
};
goog.string.getRandomString = function() {
    var x = 2147483648;
    return Math.floor(Math.random() * x).toString(36) + Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36)
};
goog.string.compareVersions = function(version1, version2) {
    var order = 0;
    var v1Subs = goog.string.trim(String(version1)).split(".");
    var v2Subs = goog.string.trim(String(version2)).split(".");
    var subCount = Math.max(v1Subs.length, v2Subs.length);
    for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
        var v1Sub = v1Subs[subIdx] || "";
        var v2Sub = v2Subs[subIdx] || "";
        do {
            var v1Comp = /(\d*)(\D*)(.*)/.exec(v1Sub) || ["", "", "", ""];
            var v2Comp = /(\d*)(\D*)(.*)/.exec(v2Sub) || ["", "", "", ""];
            if (v1Comp[0].length == 0 && v2Comp[0].length == 0) break;
            var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
            var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);
            order = goog.string.compareElements_(v1CompNum, v2CompNum) || goog.string.compareElements_(v1Comp[2].length == 0, v2Comp[2].length == 0) || goog.string.compareElements_(v1Comp[2], v2Comp[2]);
            v1Sub = v1Comp[3];
            v2Sub = v2Comp[3]
        } while (order == 0)
    }
    return order
};
goog.string.compareElements_ = function(left, right) {
    if (left < right) return -1;
    else if (left > right) return 1;
    return 0
};
goog.string.hashCode = function(str) {
    var result = 0;
    for (var i = 0; i < str.length; ++i) result = 31 * result + str.charCodeAt(i) >>> 0;
    return result
};
goog.string.uniqueStringCounter_ = Math.random() * 2147483648 | 0;
goog.string.createUniqueString = function() {
    return "goog_" + goog.string.uniqueStringCounter_++
};
goog.string.toNumber = function(str) {
    var num = Number(str);
    if (num == 0 && goog.string.isEmptyOrWhitespace(str)) return NaN;
    return num
};
goog.string.isLowerCamelCase = function(str) {
    return /^[a-z]+([A-Z][a-z]*)*$/.test(str)
};
goog.string.isUpperCamelCase = function(str) {
    return /^([A-Z][a-z]*)+$/.test(str)
};
goog.string.toCamelCase = function(str) {
    return String(str).replace(/\-([a-z])/g, function(all, match) {
        return match.toUpperCase()
    })
};
goog.string.toSelectorCase = function(str) {
    return String(str).replace(/([A-Z])/g, "-$1").toLowerCase()
};
goog.string.toTitleCase = function(str, opt_delimiters) {
    var delimiters = goog.isString(opt_delimiters) ? goog.string.regExpEscape(opt_delimiters) : "\\s";
    delimiters = delimiters ? "|[" + delimiters + "]+" : "";
    var regexp = new RegExp("(^" + delimiters + ")([a-z])", "g");
    return str.replace(regexp, function(all, p1, p2) {
        return p1 + p2.toUpperCase()
    })
};
goog.string.capitalize = function(str) {
    return String(str.charAt(0)).toUpperCase() + String(str.substr(1)).toLowerCase()
};
goog.string.parseInt = function(value) {
    if (isFinite(value)) value = String(value);
    if (goog.isString(value)) return /^\s*-?0x/i.test(value) ? parseInt(value, 16) : parseInt(value, 10);
    return NaN
};
goog.string.splitLimit = function(str, separator, limit) {
    var parts = str.split(separator);
    var returnVal = [];
    while (limit > 0 && parts.length) {
        returnVal.push(parts.shift());
        limit--
    }
    if (parts.length) returnVal.push(parts.join(separator));
    return returnVal
};
goog.string.lastComponent = function(str, separators) {
    if (!separators) return str;
    else if (typeof separators == "string") separators = [separators];
    var lastSeparatorIndex = -1;
    for (var i = 0; i < separators.length; i++) {
        if (separators[i] == "") continue;
        var currentSeparatorIndex = str.lastIndexOf(separators[i]);
        if (currentSeparatorIndex > lastSeparatorIndex) lastSeparatorIndex = currentSeparatorIndex
    }
    if (lastSeparatorIndex == -1) return str;
    return str.slice(lastSeparatorIndex + 1)
};
goog.string.editDistance = function(a, b) {
    var v0 = [];
    var v1 = [];
    if (a == b) return 0;
    if (!a.length || !b.length) return Math.max(a.length, b.length);
    for (var i = 0; i < b.length + 1; i++) v0[i] = i;
    for (var i = 0; i < a.length; i++) {
        v1[0] = i + 1;
        for (var j = 0; j < b.length; j++) {
            var cost = Number(a[i] != b[j]);
            v1[j + 1] = Math.min(v1[j] + 1, v0[j + 1] + 1, v0[j] + cost)
        }
        for (var j = 0; j < v0.length; j++) v0[j] = v1[j]
    }
    return v1[b.length]
};
goog.provide("goog.labs.userAgent.util");
goog.require("goog.string");
goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
    var navigator = goog.labs.userAgent.util.getNavigator_();
    if (navigator) {
        var userAgent = navigator.userAgent;
        if (userAgent) return userAgent
    }
    return ""
};
goog.labs.userAgent.util.getNavigator_ = function() {
    return goog.global.navigator
};
goog.labs.userAgent.util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_();
goog.labs.userAgent.util.setUserAgent = function(opt_userAgent) {
    goog.labs.userAgent.util.userAgent_ = opt_userAgent || goog.labs.userAgent.util.getNativeUserAgentString_()
};
goog.labs.userAgent.util.getUserAgent = function() {
    return goog.labs.userAgent.util.userAgent_
};
goog.labs.userAgent.util.matchUserAgent = function(str) {
    var userAgent = goog.labs.userAgent.util.getUserAgent();
    return goog.string.contains(userAgent, str)
};
goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(str) {
    var userAgent = goog.labs.userAgent.util.getUserAgent();
    return goog.string.caseInsensitiveContains(userAgent, str)
};
goog.labs.userAgent.util.extractVersionTuples = function(userAgent) {
    var versionRegExp = new RegExp("(\\w[\\w ]+)" + "/" + "([^\\s]+)" + "\\s*" + "(?:\\((.*?)\\))?", "g");
    var data = [];
    var match;
    while (match = versionRegExp.exec(userAgent)) data.push([match[1], match[2], match[3] || undefined]);
    return data
};
goog.provide("goog.object");
goog.object.is = function(v, v2) {
    if (v === v2) return v !== 0 || 1 / v === 1 / v2;
    return v !== v && v2 !== v2
};
goog.object.forEach = function(obj, f, opt_obj) {
    for (var key in obj) f.call(opt_obj, obj[key], key, obj)
};
goog.object.filter = function(obj, f, opt_obj) {
    var res = {};
    for (var key in obj)
        if (f.call(opt_obj, obj[key], key, obj)) res[key] = obj[key];
    return res
};
goog.object.map = function(obj, f, opt_obj) {
    var res = {};
    for (var key in obj) res[key] = f.call(opt_obj, obj[key], key, obj);
    return res
};
goog.object.some = function(obj, f, opt_obj) {
    for (var key in obj)
        if (f.call(opt_obj, obj[key], key, obj)) return true;
    return false
};
goog.object.every = function(obj, f, opt_obj) {
    for (var key in obj)
        if (!f.call(opt_obj, obj[key], key, obj)) return false;
    return true
};
goog.object.getCount = function(obj) {
    var rv = 0;
    for (var key in obj) rv++;
    return rv
};
goog.object.getAnyKey = function(obj) {
    for (var key in obj) return key
};
goog.object.getAnyValue = function(obj) {
    for (var key in obj) return obj[key]
};
goog.object.contains = function(obj, val) {
    return goog.object.containsValue(obj, val)
};
goog.object.getValues = function(obj) {
    var res = [];
    var i = 0;
    for (var key in obj) res[i++] = obj[key];
    return res
};
goog.object.getKeys = function(obj) {
    var res = [];
    var i = 0;
    for (var key in obj) res[i++] = key;
    return res
};
goog.object.getValueByKeys = function(obj, var_args) {
    var isArrayLike = goog.isArrayLike(var_args);
    var keys = isArrayLike ? var_args : arguments;
    for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
        if (obj == null) return undefined;
        obj = obj[keys[i]]
    }
    return obj
};
goog.object.containsKey = function(obj, key) {
    return obj !== null && key in obj
};
goog.object.containsValue = function(obj, val) {
    for (var key in obj)
        if (obj[key] == val) return true;
    return false
};
goog.object.findKey = function(obj, f, opt_this) {
    for (var key in obj)
        if (f.call(opt_this, obj[key], key, obj)) return key;
    return undefined
};
goog.object.findValue = function(obj, f, opt_this) {
    var key = goog.object.findKey(obj, f, opt_this);
    return key && obj[key]
};
goog.object.isEmpty = function(obj) {
    for (var key in obj) return false;
    return true
};
goog.object.clear = function(obj) {
    for (var i in obj) delete obj[i]
};
goog.object.remove = function(obj, key) {
    var rv;
    if (rv = key in obj) delete obj[key];
    return rv
};
goog.object.add = function(obj, key, val) {
    if (obj !== null && key in obj) throw new Error('The object already contains the key "' + key + '"');
    goog.object.set(obj, key, val)
};
goog.object.get = function(obj, key, opt_val) {
    if (obj !== null && key in obj) return obj[key];
    return opt_val
};
goog.object.set = function(obj, key, value) {
    obj[key] = value
};
goog.object.setIfUndefined = function(obj, key, value) {
    return key in obj ? obj[key] : obj[key] = value
};
goog.object.setWithReturnValueIfNotSet = function(obj, key, f) {
    if (key in obj) return obj[key];
    var val = f();
    obj[key] = val;
    return val
};
goog.object.equals = function(a, b) {
    for (var k in a)
        if (!(k in b) || a[k] !== b[k]) return false;
    for (var k in b)
        if (!(k in a)) return false;
    return true
};
goog.object.clone = function(obj) {
    var res = {};
    for (var key in obj) res[key] = obj[key];
    return res
};
goog.object.unsafeClone = function(obj) {
    var type = goog.typeOf(obj);
    if (type == "object" || type == "array") {
        if (goog.isFunction(obj.clone)) return obj.clone();
        var clone = type == "array" ? [] : {};
        for (var key in obj) clone[key] = goog.object.unsafeClone(obj[key]);
        return clone
    }
    return obj
};
goog.object.transpose = function(obj) {
    var transposed = {};
    for (var key in obj) transposed[obj[key]] = key;
    return transposed
};
goog.object.PROTOTYPE_FIELDS_ = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
goog.object.extend = function(target, var_args) {
    var key, source;
    for (var i = 1; i < arguments.length; i++) {
        source = arguments[i];
        for (key in source) target[key] = source[key];
        for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
            key = goog.object.PROTOTYPE_FIELDS_[j];
            if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key]
        }
    }
};
goog.object.create = function(var_args) {
    var argLength = arguments.length;
    if (argLength == 1 && goog.isArray(arguments[0])) return goog.object.create.apply(null, arguments[0]);
    if (argLength % 2) throw new Error("Uneven number of arguments");
    var rv = {};
    for (var i = 0; i < argLength; i += 2) rv[arguments[i]] = arguments[i + 1];
    return rv
};
goog.object.createSet = function(var_args) {
    var argLength = arguments.length;
    if (argLength == 1 && goog.isArray(arguments[0])) return goog.object.createSet.apply(null, arguments[0]);
    var rv = {};
    for (var i = 0; i < argLength; i++) rv[arguments[i]] = true;
    return rv
};
goog.object.createImmutableView = function(obj) {
    var result = obj;
    if (Object.isFrozen && !Object.isFrozen(obj)) {
        result = Object.create(obj);
        Object.freeze(result)
    }
    return result
};
goog.object.isImmutableView = function(obj) {
    return !!Object.isFrozen && Object.isFrozen(obj)
};
goog.object.getAllPropertyNames = function(obj, opt_includeObjectPrototype, opt_includeFunctionPrototype) {
    if (!obj) return [];
    if (!Object.getOwnPropertyNames || !Object.getPrototypeOf) return goog.object.getKeys(obj);
    var visitedSet = {};
    var proto = obj;
    while (proto && (proto !== Object.prototype || !!opt_includeObjectPrototype) && (proto !== Function.prototype || !!opt_includeFunctionPrototype)) {
        var names = Object.getOwnPropertyNames(proto);
        for (var i = 0; i < names.length; i++) visitedSet[names[i]] = true;
        proto = Object.getPrototypeOf(proto)
    }
    return goog.object.getKeys(visitedSet)
};
goog.provide("goog.labs.userAgent.browser");
goog.require("goog.array");
goog.require("goog.labs.userAgent.util");
goog.require("goog.object");
goog.require("goog.string");
goog.labs.userAgent.browser.matchOpera_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Opera")
};
goog.labs.userAgent.browser.matchIE_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE")
};
goog.labs.userAgent.browser.matchEdge_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge")
};
goog.labs.userAgent.browser.matchFirefox_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Firefox")
};
goog.labs.userAgent.browser.matchSafari_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Safari") && !(goog.labs.userAgent.browser.matchChrome_() || goog.labs.userAgent.browser.matchCoast_() || goog.labs.userAgent.browser.matchOpera_() || goog.labs.userAgent.browser.matchEdge_() || goog.labs.userAgent.browser.isSilk() || goog.labs.userAgent.util.matchUserAgent("Android"))
};
goog.labs.userAgent.browser.matchCoast_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Coast")
};
goog.labs.userAgent.browser.matchIosWebview_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("iPad") || goog.labs.userAgent.util.matchUserAgent("iPhone")) && !goog.labs.userAgent.browser.matchSafari_() && !goog.labs.userAgent.browser.matchChrome_() && !goog.labs.userAgent.browser.matchCoast_() && goog.labs.userAgent.util.matchUserAgent("AppleWebKit")
};
goog.labs.userAgent.browser.matchChrome_ = function() {
    return (goog.labs.userAgent.util.matchUserAgent("Chrome") || goog.labs.userAgent.util.matchUserAgent("CriOS")) && !goog.labs.userAgent.browser.matchEdge_()
};
goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android") && !(goog.labs.userAgent.browser.isChrome() || goog.labs.userAgent.browser.isFirefox() || goog.labs.userAgent.browser.isOpera() || goog.labs.userAgent.browser.isSilk())
};
goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;
goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;
goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdge_;
goog.labs.userAgent.browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_;
goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_;
goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_;
goog.labs.userAgent.browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_;
goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_;
goog.labs.userAgent.browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_;
goog.labs.userAgent.browser.isSilk = function() {
    return goog.labs.userAgent.util.matchUserAgent("Silk")
};
goog.labs.userAgent.browser.getVersion = function() {
    var userAgentString = goog.labs.userAgent.util.getUserAgent();
    if (goog.labs.userAgent.browser.isIE()) return goog.labs.userAgent.browser.getIEVersion_(userAgentString);
    var versionTuples = goog.labs.userAgent.util.extractVersionTuples(userAgentString);
    var versionMap = {};
    goog.array.forEach(versionTuples, function(tuple) {
        var key = tuple[0];
        var value = tuple[1];
        versionMap[key] = value
    });
    var versionMapHasKey = goog.partial(goog.object.containsKey, versionMap);

    function lookUpValueWithKeys(keys) {
        var key =
            goog.array.find(keys, versionMapHasKey);
        return versionMap[key] || ""
    }
    if (goog.labs.userAgent.browser.isOpera()) return lookUpValueWithKeys(["Version", "Opera"]);
    if (goog.labs.userAgent.browser.isEdge()) return lookUpValueWithKeys(["Edge"]);
    if (goog.labs.userAgent.browser.isChrome()) return lookUpValueWithKeys(["Chrome", "CriOS"]);
    var tuple = versionTuples[2];
    return tuple && tuple[1] || ""
};
goog.labs.userAgent.browser.isVersionOrHigher = function(version) {
    return goog.string.compareVersions(goog.labs.userAgent.browser.getVersion(), version) >= 0
};
goog.labs.userAgent.browser.getIEVersion_ = function(userAgent) {
    var rv = /rv: *([\d\.]*)/.exec(userAgent);
    if (rv && rv[1]) return rv[1];
    var version = "";
    var msie = /MSIE +([\d\.]+)/.exec(userAgent);
    if (msie && msie[1]) {
        var tridentVersion = /Trident\/(\d.\d)/.exec(userAgent);
        if (msie[1] == "7.0")
            if (tridentVersion && tridentVersion[1]) switch (tridentVersion[1]) {
                case "4.0":
                    version = "8.0";
                    break;
                case "5.0":
                    version = "9.0";
                    break;
                case "6.0":
                    version = "10.0";
                    break;
                case "7.0":
                    version = "11.0";
                    break
            } else version = "7.0";
            else version = msie[1]
    }
    return version
};
goog.provide("goog.labs.userAgent.engine");
goog.require("goog.array");
goog.require("goog.labs.userAgent.util");
goog.require("goog.string");
goog.labs.userAgent.engine.isPresto = function() {
    return goog.labs.userAgent.util.matchUserAgent("Presto")
};
goog.labs.userAgent.engine.isTrident = function() {
    return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE")
};
goog.labs.userAgent.engine.isEdge = function() {
    return goog.labs.userAgent.util.matchUserAgent("Edge")
};
goog.labs.userAgent.engine.isWebKit = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit") && !goog.labs.userAgent.engine.isEdge()
};
goog.labs.userAgent.engine.isGecko = function() {
    return goog.labs.userAgent.util.matchUserAgent("Gecko") && !goog.labs.userAgent.engine.isWebKit() && !goog.labs.userAgent.engine.isTrident() && !goog.labs.userAgent.engine.isEdge()
};
goog.labs.userAgent.engine.getVersion = function() {
    var userAgentString = goog.labs.userAgent.util.getUserAgent();
    if (userAgentString) {
        var tuples = goog.labs.userAgent.util.extractVersionTuples(userAgentString);
        var engineTuple = goog.labs.userAgent.engine.getEngineTuple_(tuples);
        if (engineTuple) {
            if (engineTuple[0] == "Gecko") return goog.labs.userAgent.engine.getVersionForKey_(tuples, "Firefox");
            return engineTuple[1]
        }
        var browserTuple = tuples[0];
        var info;
        if (browserTuple && (info = browserTuple[2])) {
            var match = /Trident\/([^\s;]+)/.exec(info);
            if (match) return match[1]
        }
    }
    return ""
};
goog.labs.userAgent.engine.getEngineTuple_ = function(tuples) {
    if (!goog.labs.userAgent.engine.isEdge()) return tuples[1];
    for (var i = 0; i < tuples.length; i++) {
        var tuple = tuples[i];
        if (tuple[0] == "Edge") return tuple
    }
};
goog.labs.userAgent.engine.isVersionOrHigher = function(version) {
    return goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), version) >= 0
};
goog.labs.userAgent.engine.getVersionForKey_ = function(tuples, key) {
    var pair = goog.array.find(tuples, function(pair) {
        return key == pair[0]
    });
    return pair && pair[1] || ""
};
goog.provide("goog.labs.userAgent.platform");
goog.require("goog.labs.userAgent.util");
goog.require("goog.string");
goog.labs.userAgent.platform.isAndroid = function() {
    return goog.labs.userAgent.util.matchUserAgent("Android")
};
goog.labs.userAgent.platform.isIpod = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPod")
};
goog.labs.userAgent.platform.isIphone = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPhone") && !goog.labs.userAgent.util.matchUserAgent("iPod") && !goog.labs.userAgent.util.matchUserAgent("iPad")
};
goog.labs.userAgent.platform.isIpad = function() {
    return goog.labs.userAgent.util.matchUserAgent("iPad")
};
goog.labs.userAgent.platform.isIos = function() {
    return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpad() || goog.labs.userAgent.platform.isIpod()
};
goog.labs.userAgent.platform.isMacintosh = function() {
    return goog.labs.userAgent.util.matchUserAgent("Macintosh")
};
goog.labs.userAgent.platform.isLinux = function() {
    return goog.labs.userAgent.util.matchUserAgent("Linux")
};
goog.labs.userAgent.platform.isWindows = function() {
    return goog.labs.userAgent.util.matchUserAgent("Windows")
};
goog.labs.userAgent.platform.isChromeOS = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrOS")
};
goog.labs.userAgent.platform.isChromecast = function() {
    return goog.labs.userAgent.util.matchUserAgent("CrKey")
};
goog.labs.userAgent.platform.isKaiOS = function() {
    return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS")
};
goog.labs.userAgent.platform.getVersion = function() {
    var userAgentString = goog.labs.userAgent.util.getUserAgent();
    var version = "",
        re;
    if (goog.labs.userAgent.platform.isWindows()) {
        re = /Windows (?:NT|Phone) ([0-9.]+)/;
        var match = re.exec(userAgentString);
        if (match) version = match[1];
        else version = "0.0"
    } else if (goog.labs.userAgent.platform.isIos()) {
        re = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/;
        var match = re.exec(userAgentString);
        version = match && match[1].replace(/_/g, ".")
    } else if (goog.labs.userAgent.platform.isMacintosh()) {
        re =
            /Mac OS X ([0-9_.]+)/;
        var match = re.exec(userAgentString);
        version = match ? match[1].replace(/_/g, ".") : "10"
    } else if (goog.labs.userAgent.platform.isAndroid()) {
        re = /Android\s+([^\);]+)(\)|;)/;
        var match = re.exec(userAgentString);
        version = match && match[1]
    } else if (goog.labs.userAgent.platform.isChromeOS()) {
        re = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/;
        var match = re.exec(userAgentString);
        version = match && match[1]
    }
    return version || ""
};
goog.labs.userAgent.platform.isVersionOrHigher = function(version) {
    return goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), version) >= 0
};
goog.provide("goog.reflect");
goog.reflect.object = function(type, object) {
    return object
};
goog.reflect.objectProperty = function(prop, object) {
    return prop
};
goog.reflect.sinkValue = function(x) {
    goog.reflect.sinkValue[" "](x);
    return x
};
goog.reflect.sinkValue[" "] = goog.nullFunction;
goog.reflect.canAccessProperty = function(obj, prop) {
    try {
        goog.reflect.sinkValue(obj[prop]);
        return true
    } catch (e) {}
    return false
};
goog.reflect.cache = function(cacheObj, key, valueFn, opt_keyFn) {
    var storedKey = opt_keyFn ? opt_keyFn(key) : key;
    if (Object.prototype.hasOwnProperty.call(cacheObj, storedKey)) return cacheObj[storedKey];
    return cacheObj[storedKey] = valueFn(key)
};
goog.provide("goog.userAgent");
goog.require("goog.labs.userAgent.browser");
goog.require("goog.labs.userAgent.engine");
goog.require("goog.labs.userAgent.platform");
goog.require("goog.labs.userAgent.util");
goog.require("goog.reflect");
goog.require("goog.string");
goog.define("goog.userAgent.ASSUME_IE", false);
goog.define("goog.userAgent.ASSUME_EDGE", false);
goog.define("goog.userAgent.ASSUME_GECKO", false);
goog.define("goog.userAgent.ASSUME_WEBKIT", false);
goog.define("goog.userAgent.ASSUME_MOBILE_WEBKIT", false);
goog.define("goog.userAgent.ASSUME_OPERA", false);
goog.define("goog.userAgent.ASSUME_ANY_VERSION", false);
goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO || goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_OPERA;
goog.userAgent.getUserAgentString = function() {
    return goog.labs.userAgent.util.getUserAgent()
};
goog.userAgent.getNavigatorTyped = function() {
    return goog.global["navigator"] || null
};
goog.userAgent.getNavigator = function() {
    return goog.userAgent.getNavigatorTyped()
};
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_OPERA : goog.labs.userAgent.browser.isOpera();
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_IE : goog.labs.userAgent.browser.isIE();
goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_EDGE : goog.labs.userAgent.engine.isEdge();
goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_GECKO : goog.labs.userAgent.engine.isGecko();
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT : goog.labs.userAgent.engine.isWebKit();
goog.userAgent.isMobile_ = function() {
    return goog.userAgent.WEBKIT && goog.labs.userAgent.util.matchUserAgent("Mobile")
};
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_();
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;
goog.userAgent.determinePlatform_ = function() {
    var navigator = goog.userAgent.getNavigatorTyped();
    return navigator && navigator.platform || ""
};
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();
goog.define("goog.userAgent.ASSUME_MAC", false);
goog.define("goog.userAgent.ASSUME_WINDOWS", false);
goog.define("goog.userAgent.ASSUME_LINUX", false);
goog.define("goog.userAgent.ASSUME_X11", false);
goog.define("goog.userAgent.ASSUME_ANDROID", false);
goog.define("goog.userAgent.ASSUME_IPHONE", false);
goog.define("goog.userAgent.ASSUME_IPAD", false);
goog.define("goog.userAgent.ASSUME_IPOD", false);
goog.define("goog.userAgent.ASSUME_KAIOS", false);
goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC || goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX || goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID || goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD;
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh();
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_WINDOWS : goog.labs.userAgent.platform.isWindows();
goog.userAgent.isLegacyLinux_ = function() {
    return goog.labs.userAgent.platform.isLinux() || goog.labs.userAgent.platform.isChromeOS()
};
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_LINUX : goog.userAgent.isLegacyLinux_();
goog.userAgent.isX11_ = function() {
    var navigator = goog.userAgent.getNavigatorTyped();
    return !!navigator && goog.string.contains(navigator["appVersion"] || "", "X11")
};
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_X11 : goog.userAgent.isX11_();
goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_ANDROID : goog.labs.userAgent.platform.isAndroid();
goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE : goog.labs.userAgent.platform.isIphone();
goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad();
goog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIpod();
goog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIos();
goog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_KAIOS : goog.labs.userAgent.platform.isKaiOS();
goog.userAgent.determineVersion_ = function() {
    var version = "";
    var arr = goog.userAgent.getVersionRegexResult_();
    if (arr) version = arr ? arr[1] : "";
    if (goog.userAgent.IE) {
        var docMode = goog.userAgent.getDocumentMode_();
        if (docMode != null && docMode > parseFloat(version)) return String(docMode)
    }
    return version
};
goog.userAgent.getVersionRegexResult_ = function() {
    var userAgent = goog.userAgent.getUserAgentString();
    if (goog.userAgent.GECKO) return /rv:([^\);]+)(\)|;)/.exec(userAgent);
    if (goog.userAgent.EDGE) return /Edge\/([\d\.]+)/.exec(userAgent);
    if (goog.userAgent.IE) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(userAgent);
    if (goog.userAgent.WEBKIT) return /WebKit\/(\S+)/.exec(userAgent);
    if (goog.userAgent.OPERA) return /(?:Version)[ \/]?(\S+)/.exec(userAgent);
    return undefined
};
goog.userAgent.getDocumentMode_ = function() {
    var doc = goog.global["document"];
    return doc ? doc["documentMode"] : undefined
};
goog.userAgent.VERSION = goog.userAgent.determineVersion_();
goog.userAgent.compare = function(v1, v2) {
    return goog.string.compareVersions(v1, v2)
};
goog.userAgent.isVersionOrHigherCache_ = {};
goog.userAgent.isVersionOrHigher = function(version) {
    return goog.userAgent.ASSUME_ANY_VERSION || goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_, version, function() {
        return goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0
    })
};
goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;
goog.userAgent.isDocumentModeOrHigher = function(documentMode) {
    return Number(goog.userAgent.DOCUMENT_MODE) >= documentMode
};
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;
goog.userAgent.DOCUMENT_MODE = function() {
    var doc = goog.global["document"];
    var mode = goog.userAgent.getDocumentMode_();
    if (!doc || !goog.userAgent.IE) return undefined;
    return mode || (doc["compatMode"] == "CSS1Compat" ? parseInt(goog.userAgent.VERSION, 10) : 5)
}();
goog.provide("goog.debug.EntryPointMonitor");
goog.provide("goog.debug.entryPointRegistry");
goog.require("goog.asserts");
goog.debug.EntryPointMonitor = function() {};
goog.debug.EntryPointMonitor.prototype.wrap;
goog.debug.EntryPointMonitor.prototype.unwrap;
goog.debug.entryPointRegistry.refList_ = [];
goog.debug.entryPointRegistry.monitors_ = [];
goog.debug.entryPointRegistry.monitorsMayExist_ = false;
goog.debug.entryPointRegistry.register = function(callback) {
    goog.debug.entryPointRegistry.refList_[goog.debug.entryPointRegistry.refList_.length] = callback;
    if (goog.debug.entryPointRegistry.monitorsMayExist_) {
        var monitors = goog.debug.entryPointRegistry.monitors_;
        for (var i = 0; i < monitors.length; i++) callback(goog.bind(monitors[i].wrap, monitors[i]))
    }
};
goog.debug.entryPointRegistry.monitorAll = function(monitor) {
    goog.debug.entryPointRegistry.monitorsMayExist_ = true;
    var transformer = goog.bind(monitor.wrap, monitor);
    for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) goog.debug.entryPointRegistry.refList_[i](transformer);
    goog.debug.entryPointRegistry.monitors_.push(monitor)
};
goog.debug.entryPointRegistry.unmonitorAllIfPossible = function(monitor) {
    var monitors = goog.debug.entryPointRegistry.monitors_;
    goog.asserts.assert(monitor == monitors[monitors.length - 1], "Only the most recent monitor can be unwrapped.");
    var transformer = goog.bind(monitor.unwrap, monitor);
    for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) goog.debug.entryPointRegistry.refList_[i](transformer);
    monitors.length--
};
goog.provide("goog.debug.errorcontext");
goog.debug.errorcontext.addErrorContext = function(err, contextKey, contextValue) {
    if (!err[goog.debug.errorcontext.CONTEXT_KEY_]) err[goog.debug.errorcontext.CONTEXT_KEY_] = {};
    err[goog.debug.errorcontext.CONTEXT_KEY_][contextKey] = contextValue
};
goog.debug.errorcontext.getErrorContext = function(err) {
    return err[goog.debug.errorcontext.CONTEXT_KEY_] || {}
};
goog.debug.errorcontext.CONTEXT_KEY_ = "__closure__error__context__984382";
goog.provide("goog.debug");
goog.require("goog.array");
goog.require("goog.debug.errorcontext");
goog.require("goog.userAgent");
goog.define("goog.debug.LOGGING_ENABLED", goog.DEBUG);
goog.define("goog.debug.FORCE_SLOPPY_STACKS", false);
goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {
    var target = opt_target || goog.global;
    var oldErrorHandler = target.onerror;
    var retVal = !!opt_cancel;
    if (goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher("535.3")) retVal = !retVal;
    target.onerror = function(message, url, line, opt_col, opt_error) {
        if (oldErrorHandler) oldErrorHandler(message, url, line, opt_col, opt_error);
        logFunc({
            message: message,
            fileName: url,
            line: line,
            lineNumber: line,
            col: opt_col,
            error: opt_error
        });
        return retVal
    }
};
goog.debug.expose = function(obj, opt_showFn) {
    if (typeof obj == "undefined") return "undefined";
    if (obj == null) return "NULL";
    var str = [];
    for (var x in obj) {
        if (!opt_showFn && goog.isFunction(obj[x])) continue;
        var s = x + " = ";
        try {
            s += obj[x]
        } catch (e) {
            s += "*** " + e + " ***"
        }
        str.push(s)
    }
    return str.join("\n")
};
goog.debug.deepExpose = function(obj, opt_showFn) {
    var str = [];
    var uidsToCleanup = [];
    var ancestorUids = {};
    var helper = function(obj, space) {
        var nestspace = space + "  ";
        var indentMultiline = function(str) {
            return str.replace(/\n/g, "\n" + space)
        };
        try {
            if (!goog.isDef(obj)) str.push("undefined");
            else if (goog.isNull(obj)) str.push("NULL");
            else if (goog.isString(obj)) str.push('"' + indentMultiline(obj) + '"');
            else if (goog.isFunction(obj)) str.push(indentMultiline(String(obj)));
            else if (goog.isObject(obj)) {
                if (!goog.hasUid(obj)) uidsToCleanup.push(obj);
                var uid = goog.getUid(obj);
                if (ancestorUids[uid]) str.push("*** reference loop detected (id=" + uid + ") ***");
                else {
                    ancestorUids[uid] = true;
                    str.push("{");
                    for (var x in obj) {
                        if (!opt_showFn && goog.isFunction(obj[x])) continue;
                        str.push("\n");
                        str.push(nestspace);
                        str.push(x + " = ");
                        helper(obj[x], nestspace)
                    }
                    str.push("\n" + space + "}");
                    delete ancestorUids[uid]
                }
            } else str.push(obj)
        } catch (e) {
            str.push("*** " + e + " ***")
        }
    };
    helper(obj, "");
    for (var i = 0; i < uidsToCleanup.length; i++) goog.removeUid(uidsToCleanup[i]);
    return str.join("")
};
goog.debug.exposeArray = function(arr) {
    var str = [];
    for (var i = 0; i < arr.length; i++)
        if (goog.isArray(arr[i])) str.push(goog.debug.exposeArray(arr[i]));
        else str.push(arr[i]);
    return "[ " + str.join(", ") + " ]"
};
goog.debug.normalizeErrorObject = function(err) {
    var href = goog.getObjectByName("window.location.href");
    if (goog.isString(err)) return {
        "message": err,
        "name": "Unknown error",
        "lineNumber": "Not available",
        "fileName": href,
        "stack": "Not available"
    };
    var lineNumber, fileName;
    var threwError = false;
    try {
        lineNumber = err.lineNumber || err.line || "Not available"
    } catch (e) {
        lineNumber = "Not available";
        threwError = true
    }
    try {
        fileName = err.fileName || err.filename || err.sourceURL || goog.global["$googDebugFname"] || href
    } catch (e$1) {
        fileName =
            "Not available";
        threwError = true
    }
    if (threwError || !err.lineNumber || !err.fileName || !err.stack || !err.message || !err.name) return {
        "message": err.message || "Not available",
        "name": err.name || "UnknownError",
        "lineNumber": lineNumber,
        "fileName": fileName,
        "stack": err.stack || "Not available"
    };
    return err
};
goog.debug.enhanceError = function(err, opt_message) {
    var error;
    if (!(err instanceof Error)) {
        error = Error(err);
        if (Error.captureStackTrace) Error.captureStackTrace(error, goog.debug.enhanceError)
    } else error = err;
    if (!error.stack) error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);
    if (opt_message) {
        var x = 0;
        while (error["message" + x]) ++x;
        error["message" + x] = String(opt_message)
    }
    return error
};
goog.debug.enhanceErrorWithContext = function(err, opt_context) {
    var error = goog.debug.enhanceError(err);
    if (opt_context)
        for (var key in opt_context) goog.debug.errorcontext.addErrorContext(error, key, opt_context[key]);
    return error
};
goog.debug.getStacktraceSimple = function(opt_depth) {
    if (!goog.debug.FORCE_SLOPPY_STACKS) {
        var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);
        if (stack) return stack
    }
    var sb = [];
    var fn = arguments.callee.caller;
    var depth = 0;
    while (fn && (!opt_depth || depth < opt_depth)) {
        sb.push(goog.debug.getFunctionName(fn));
        sb.push("()\n");
        try {
            fn = fn.caller
        } catch (e) {
            sb.push("[exception trying to get caller]\n");
            break
        }
        depth++;
        if (depth >= goog.debug.MAX_STACK_DEPTH) {
            sb.push("[...long stack...]");
            break
        }
    }
    if (opt_depth &&
        depth >= opt_depth) sb.push("[...reached max depth limit...]");
    else sb.push("[end]");
    return sb.join("")
};
goog.debug.MAX_STACK_DEPTH = 50;
goog.debug.getNativeStackTrace_ = function(fn) {
    var tempErr = new Error;
    if (Error.captureStackTrace) {
        Error.captureStackTrace(tempErr, fn);
        return String(tempErr.stack)
    } else {
        try {
            throw tempErr;
        } catch (e) {
            tempErr = e
        }
        var stack = tempErr.stack;
        if (stack) return String(stack)
    }
    return null
};
goog.debug.getStacktrace = function(fn) {
    var stack;
    if (!goog.debug.FORCE_SLOPPY_STACKS) {
        var contextFn = fn || goog.debug.getStacktrace;
        stack = goog.debug.getNativeStackTrace_(contextFn)
    }
    if (!stack) stack = goog.debug.getStacktraceHelper_(fn || arguments.callee.caller, []);
    return stack
};
goog.debug.getStacktraceHelper_ = function(fn, visited) {
    var sb = [];
    if (goog.array.contains(visited, fn)) sb.push("[...circular reference...]");
    else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {
        sb.push(goog.debug.getFunctionName(fn) + "(");
        var args = fn.arguments;
        for (var i = 0; args && i < args.length; i++) {
            if (i > 0) sb.push(", ");
            var argDesc;
            var arg = args[i];
            switch (typeof arg) {
                case "object":
                    argDesc = arg ? "object" : "null";
                    break;
                case "string":
                    argDesc = arg;
                    break;
                case "number":
                    argDesc = String(arg);
                    break;
                case "boolean":
                    argDesc =
                        arg ? "true" : "false";
                    break;
                case "function":
                    argDesc = goog.debug.getFunctionName(arg);
                    argDesc = argDesc ? argDesc : "[fn]";
                    break;
                case "undefined":
                default:
                    argDesc = typeof arg;
                    break
            }
            if (argDesc.length > 40) argDesc = argDesc.substr(0, 40) + "...";
            sb.push(argDesc)
        }
        visited.push(fn);
        sb.push(")\n");
        try {
            sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited))
        } catch (e) {
            sb.push("[exception trying to get caller]\n")
        }
    } else if (fn) sb.push("[...long stack...]");
    else sb.push("[end]");
    return sb.join("")
};
goog.debug.setFunctionResolver = function(resolver) {
    goog.debug.fnNameResolver_ = resolver
};
goog.debug.getFunctionName = function(fn) {
    if (goog.debug.fnNameCache_[fn]) return goog.debug.fnNameCache_[fn];
    if (goog.debug.fnNameResolver_) {
        var name = goog.debug.fnNameResolver_(fn);
        if (name) {
            goog.debug.fnNameCache_[fn] = name;
            return name
        }
    }
    var functionSource = String(fn);
    if (!goog.debug.fnNameCache_[functionSource]) {
        var matches = /function\s+([^\(]+)/m.exec(functionSource);
        if (matches) {
            var method = matches[1];
            goog.debug.fnNameCache_[functionSource] = method
        } else goog.debug.fnNameCache_[functionSource] = "[Anonymous]"
    }
    return goog.debug.fnNameCache_[functionSource]
};
goog.debug.makeWhitespaceVisible = function(string) {
    return string.replace(/ /g, "[_]").replace(/\f/g, "[f]").replace(/\n/g, "[n]\n").replace(/\r/g, "[r]").replace(/\t/g, "[t]")
};
goog.debug.runtimeType = function(value) {
    if (value instanceof Function) return value.displayName || value.name || "unknown type name";
    else if (value instanceof Object) return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
    else return value === null ? "null" : typeof value
};
goog.debug.fnNameCache_ = {};
goog.debug.fnNameResolver_;
goog.debug.freezeInternal_ = goog.DEBUG && Object.freeze || function(arg) {
    return arg
};
goog.debug.freeze = function(arg) {
    return {
        valueOf: function() {
            return goog.debug.freezeInternal_(arg)
        }
    }.valueOf()
};
goog.provide("goog.events.BrowserFeature");
goog.require("goog.userAgent");
goog.scope(function() {
    goog.events.BrowserFeature = {
        HAS_W3C_BUTTON: !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),
        HAS_W3C_EVENT_SUPPORT: !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),
        SET_KEY_CODE_TO_PREVENT_DEFAULT: goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("9"),
        HAS_NAVIGATOR_ONLINE_PROPERTY: !goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher("528"),
        HAS_HTML5_NETWORK_EVENT_SUPPORT: goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher("1.9b") || goog.userAgent.IE &&
            goog.userAgent.isVersionOrHigher("8") || goog.userAgent.OPERA && goog.userAgent.isVersionOrHigher("9.5") || goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher("528"),
        HTML5_NETWORK_EVENTS_FIRE_ON_BODY: goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher("8") || goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("9"),
        TOUCH_ENABLED: "ontouchstart" in goog.global || !!(goog.global["document"] && document.documentElement && "ontouchstart" in document.documentElement) || !!(goog.global["navigator"] && (goog.global["navigator"]["maxTouchPoints"] ||
            goog.global["navigator"]["msMaxTouchPoints"])),
        POINTER_EVENTS: "PointerEvent" in goog.global,
        MSPOINTER_EVENTS: "MSPointerEvent" in goog.global && !!(goog.global["navigator"] && goog.global["navigator"]["msPointerEnabled"]),
        PASSIVE_EVENTS: purify(function() {
            if (!goog.global.addEventListener || !Object.defineProperty) return false;
            var passive = false;
            var options = Object.defineProperty({}, "passive", {
                get: function() {
                    passive = true
                }
            });
            try {
                goog.global.addEventListener("test", goog.nullFunction, options);
                goog.global.removeEventListener("test",
                    goog.nullFunction, options)
            } catch (e) {}
            return passive
        })
    };

    function purify(fn) {
        return {
            valueOf: fn
        }.valueOf()
    }
});
goog.provide("goog.disposable.IDisposable");
goog.disposable.IDisposable = function() {};
goog.disposable.IDisposable.prototype.dispose = goog.abstractMethod;
goog.disposable.IDisposable.prototype.isDisposed = goog.abstractMethod;
goog.provide("goog.Disposable");
goog.provide("goog.dispose");
goog.provide("goog.disposeAll");
goog.require("goog.disposable.IDisposable");
goog.Disposable = function() {
    this.creationStack;
    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
        if (goog.Disposable.INCLUDE_STACK_ON_CREATION) this.creationStack = (new Error).stack;
        goog.Disposable.instances_[goog.getUid(this)] = this
    }
    this.disposed_ = this.disposed_;
    this.onDisposeCallbacks_ = this.onDisposeCallbacks_
};
goog.Disposable.MonitoringMode = {
    OFF: 0,
    PERMANENT: 1,
    INTERACTIVE: 2
};
goog.define("goog.Disposable.MONITORING_MODE", 0);
goog.define("goog.Disposable.INCLUDE_STACK_ON_CREATION", true);
goog.Disposable.instances_ = {};
goog.Disposable.getUndisposedObjects = function() {
    var ret = [];
    for (var id in goog.Disposable.instances_)
        if (goog.Disposable.instances_.hasOwnProperty(id)) ret.push(goog.Disposable.instances_[Number(id)]);
    return ret
};
goog.Disposable.clearUndisposedObjects = function() {
    goog.Disposable.instances_ = {}
};
goog.Disposable.prototype.disposed_ = false;
goog.Disposable.prototype.onDisposeCallbacks_;
goog.Disposable.prototype.isDisposed = function() {
    return this.disposed_
};
goog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;
goog.Disposable.prototype.dispose = function() {
    if (!this.disposed_) {
        this.disposed_ = true;
        this.disposeInternal();
        if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
            var uid = goog.getUid(this);
            if (goog.Disposable.MONITORING_MODE == goog.Disposable.MonitoringMode.PERMANENT && !goog.Disposable.instances_.hasOwnProperty(uid)) throw new Error(this + " did not call the goog.Disposable base " + "constructor or was disposed of after a clearUndisposedObjects " + "call");
            if (goog.Disposable.MONITORING_MODE !=
                goog.Disposable.MonitoringMode.OFF && this.onDisposeCallbacks_ && this.onDisposeCallbacks_.length > 0) throw new Error(this + " did not empty its onDisposeCallbacks queue. This " + "probably means it overrode dispose() or disposeInternal() " + "without calling the superclass' method.");
            delete goog.Disposable.instances_[uid]
        }
    }
};
goog.Disposable.prototype.registerDisposable = function(disposable) {
    this.addOnDisposeCallback(goog.partial(goog.dispose, disposable))
};
goog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {
    if (this.disposed_) {
        goog.isDef(opt_scope) ? callback.call(opt_scope) : callback();
        return
    }
    if (!this.onDisposeCallbacks_) this.onDisposeCallbacks_ = [];
    this.onDisposeCallbacks_.push(goog.isDef(opt_scope) ? goog.bind(callback, opt_scope) : callback)
};
goog.Disposable.prototype.disposeInternal = function() {
    if (this.onDisposeCallbacks_)
        while (this.onDisposeCallbacks_.length) this.onDisposeCallbacks_.shift()()
};
goog.Disposable.isDisposed = function(obj) {
    if (obj && typeof obj.isDisposed == "function") return obj.isDisposed();
    return false
};
goog.dispose = function(obj) {
    if (obj && typeof obj.dispose == "function") obj.dispose()
};
goog.disposeAll = function(var_args) {
    for (var i = 0, len = arguments.length; i < len; ++i) {
        var disposable = arguments[i];
        if (goog.isArrayLike(disposable)) goog.disposeAll.apply(null, disposable);
        else goog.dispose(disposable)
    }
};
goog.provide("goog.events.EventId");
goog.events.EventId = function(eventId) {
    this.id = eventId
};
goog.events.EventId.prototype.toString = function() {
    return this.id
};
goog.provide("goog.events.Event");
goog.provide("goog.events.EventLike");
goog.require("goog.Disposable");
goog.require("goog.events.EventId");
goog.events.EventLike;
goog.events.Event = function(type, opt_target) {
    this.type = type instanceof goog.events.EventId ? String(type) : type;
    this.target = opt_target;
    this.currentTarget = this.target;
    this.propagationStopped_ = false;
    this.defaultPrevented = false;
    this.returnValue_ = true
};
goog.events.Event.prototype.stopPropagation = function() {
    this.propagationStopped_ = true
};
goog.events.Event.prototype.preventDefault = function() {
    this.defaultPrevented = true;
    this.returnValue_ = false
};
goog.events.Event.stopPropagation = function(e) {
    e.stopPropagation()
};
goog.events.Event.preventDefault = function(e) {
    e.preventDefault()
};
goog.provide("goog.events.EventType");
goog.provide("goog.events.PointerAsMouseEventType");
goog.provide("goog.events.PointerAsTouchEventType");
goog.provide("goog.events.PointerFallbackEventType");
goog.provide("goog.events.PointerTouchFallbackEventType");
goog.require("goog.events.BrowserFeature");
goog.require("goog.userAgent");
goog.events.getVendorPrefixedName_ = function(eventName) {
    return goog.userAgent.WEBKIT ? "webkit" + eventName : goog.userAgent.OPERA ? "o" + eventName.toLowerCase() : eventName.toLowerCase()
};
goog.events.EventType = {
    CLICK: "click",
    RIGHTCLICK: "rightclick",
    DBLCLICK: "dblclick",
    MOUSEDOWN: "mousedown",
    MOUSEUP: "mouseup",
    MOUSEOVER: "mouseover",
    MOUSEOUT: "mouseout",
    MOUSEMOVE: "mousemove",
    MOUSEENTER: "mouseenter",
    MOUSELEAVE: "mouseleave",
    MOUSECANCEL: "mousecancel",
    SELECTIONCHANGE: "selectionchange",
    SELECTSTART: "selectstart",
    WHEEL: "wheel",
    KEYPRESS: "keypress",
    KEYDOWN: "keydown",
    KEYUP: "keyup",
    BLUR: "blur",
    FOCUS: "focus",
    DEACTIVATE: "deactivate",
    FOCUSIN: "focusin",
    FOCUSOUT: "focusout",
    CHANGE: "change",
    RESET: "reset",
    SELECT: "select",
    SUBMIT: "submit",
    INPUT: "input",
    PROPERTYCHANGE: "propertychange",
    DRAGSTART: "dragstart",
    DRAG: "drag",
    DRAGENTER: "dragenter",
    DRAGOVER: "dragover",
    DRAGLEAVE: "dragleave",
    DROP: "drop",
    DRAGEND: "dragend",
    TOUCHSTART: "touchstart",
    TOUCHMOVE: "touchmove",
    TOUCHEND: "touchend",
    TOUCHCANCEL: "touchcancel",
    BEFOREUNLOAD: "beforeunload",
    CONSOLEMESSAGE: "consolemessage",
    CONTEXTMENU: "contextmenu",
    DEVICECHANGE: "devicechange",
    DEVICEMOTION: "devicemotion",
    DEVICEORIENTATION: "deviceorientation",
    DOMCONTENTLOADED: "DOMContentLoaded",
    ERROR: "error",
    HELP: "help",
    LOAD: "load",
    LOSECAPTURE: "losecapture",
    ORIENTATIONCHANGE: "orientationchange",
    READYSTATECHANGE: "readystatechange",
    RESIZE: "resize",
    SCROLL: "scroll",
    UNLOAD: "unload",
    CANPLAY: "canplay",
    CANPLAYTHROUGH: "canplaythrough",
    DURATIONCHANGE: "durationchange",
    EMPTIED: "emptied",
    ENDED: "ended",
    LOADEDDATA: "loadeddata",
    LOADEDMETADATA: "loadedmetadata",
    PAUSE: "pause",
    PLAY: "play",
    PLAYING: "playing",
    RATECHANGE: "ratechange",
    SEEKED: "seeked",
    SEEKING: "seeking",
    STALLED: "stalled",
    SUSPEND: "suspend",
    TIMEUPDATE: "timeupdate",
    VOLUMECHANGE: "volumechange",
    WAITING: "waiting",
    SOURCEOPEN: "sourceopen",
    SOURCEENDED: "sourceended",
    SOURCECLOSED: "sourceclosed",
    ABORT: "abort",
    UPDATE: "update",
    UPDATESTART: "updatestart",
    UPDATEEND: "updateend",
    HASHCHANGE: "hashchange",
    PAGEHIDE: "pagehide",
    PAGESHOW: "pageshow",
    POPSTATE: "popstate",
    COPY: "copy",
    PASTE: "paste",
    CUT: "cut",
    BEFORECOPY: "beforecopy",
    BEFORECUT: "beforecut",
    BEFOREPASTE: "beforepaste",
    ONLINE: "online",
    OFFLINE: "offline",
    MESSAGE: "message",
    CONNECT: "connect",
    INSTALL: "install",
    ACTIVATE: "activate",
    FETCH: "fetch",
    FOREIGNFETCH: "foreignfetch",
    MESSAGEERROR: "messageerror",
    STATECHANGE: "statechange",
    UPDATEFOUND: "updatefound",
    CONTROLLERCHANGE: "controllerchange",
    ANIMATIONSTART: goog.events.getVendorPrefixedName_("AnimationStart"),
    ANIMATIONEND: goog.events.getVendorPrefixedName_("AnimationEnd"),
    ANIMATIONITERATION: goog.events.getVendorPrefixedName_("AnimationIteration"),
    TRANSITIONEND: goog.events.getVendorPrefixedName_("TransitionEnd"),
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTERCANCEL: "pointercancel",
    POINTERMOVE: "pointermove",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    GOTPOINTERCAPTURE: "gotpointercapture",
    LOSTPOINTERCAPTURE: "lostpointercapture",
    MSGESTURECHANGE: "MSGestureChange",
    MSGESTUREEND: "MSGestureEnd",
    MSGESTUREHOLD: "MSGestureHold",
    MSGESTURESTART: "MSGestureStart",
    MSGESTURETAP: "MSGestureTap",
    MSGOTPOINTERCAPTURE: "MSGotPointerCapture",
    MSINERTIASTART: "MSInertiaStart",
    MSLOSTPOINTERCAPTURE: "MSLostPointerCapture",
    MSPOINTERCANCEL: "MSPointerCancel",
    MSPOINTERDOWN: "MSPointerDown",
    MSPOINTERENTER: "MSPointerEnter",
    MSPOINTERHOVER: "MSPointerHover",
    MSPOINTERLEAVE: "MSPointerLeave",
    MSPOINTERMOVE: "MSPointerMove",
    MSPOINTEROUT: "MSPointerOut",
    MSPOINTEROVER: "MSPointerOver",
    MSPOINTERUP: "MSPointerUp",
    TEXT: "text",
    TEXTINPUT: goog.userAgent.IE ? "textinput" : "textInput",
    COMPOSITIONSTART: "compositionstart",
    COMPOSITIONUPDATE: "compositionupdate",
    COMPOSITIONEND: "compositionend",
    BEFOREINPUT: "beforeinput",
    EXIT: "exit",
    LOADABORT: "loadabort",
    LOADCOMMIT: "loadcommit",
    LOADREDIRECT: "loadredirect",
    LOADSTART: "loadstart",
    LOADSTOP: "loadstop",
    RESPONSIVE: "responsive",
    SIZECHANGED: "sizechanged",
    UNRESPONSIVE: "unresponsive",
    VISIBILITYCHANGE: "visibilitychange",
    STORAGE: "storage",
    DOMSUBTREEMODIFIED: "DOMSubtreeModified",
    DOMNODEINSERTED: "DOMNodeInserted",
    DOMNODEREMOVED: "DOMNodeRemoved",
    DOMNODEREMOVEDFROMDOCUMENT: "DOMNodeRemovedFromDocument",
    DOMNODEINSERTEDINTODOCUMENT: "DOMNodeInsertedIntoDocument",
    DOMATTRMODIFIED: "DOMAttrModified",
    DOMCHARACTERDATAMODIFIED: "DOMCharacterDataModified",
    BEFOREPRINT: "beforeprint",
    AFTERPRINT: "afterprint",
    BEFOREINSTALLPROMPT: "beforeinstallprompt",
    APPINSTALLED: "appinstalled"
};
goog.events.getPointerFallbackEventName_ = function(pointerEventName, msPointerEventName, fallbackEventName) {
    if (goog.events.BrowserFeature.POINTER_EVENTS) return pointerEventName;
    if (goog.events.BrowserFeature.MSPOINTER_EVENTS) return msPointerEventName;
    return fallbackEventName
};
goog.events.PointerFallbackEventType = {
    POINTERDOWN: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN, goog.events.EventType.MOUSEDOWN),
    POINTERUP: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP, goog.events.EventType.MOUSEUP),
    POINTERCANCEL: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERCANCEL, goog.events.EventType.MSPOINTERCANCEL, goog.events.EventType.MOUSECANCEL),
    POINTERMOVE: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE, goog.events.EventType.MOUSEMOVE),
    POINTEROVER: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTEROVER, goog.events.EventType.MSPOINTEROVER, goog.events.EventType.MOUSEOVER),
    POINTEROUT: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTEROUT, goog.events.EventType.MSPOINTEROUT, goog.events.EventType.MOUSEOUT),
    POINTERENTER: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERENTER,
        goog.events.EventType.MSPOINTERENTER, goog.events.EventType.MOUSEENTER),
    POINTERLEAVE: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERLEAVE, goog.events.EventType.MSPOINTERLEAVE, goog.events.EventType.MOUSELEAVE)
};
goog.events.PointerTouchFallbackEventType = {
    POINTERDOWN: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERDOWN, goog.events.EventType.MSPOINTERDOWN, goog.events.EventType.TOUCHSTART),
    POINTERUP: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERUP, goog.events.EventType.MSPOINTERUP, goog.events.EventType.TOUCHEND),
    POINTERCANCEL: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERCANCEL, goog.events.EventType.MSPOINTERCANCEL, goog.events.EventType.TOUCHCANCEL),
    POINTERMOVE: goog.events.getPointerFallbackEventName_(goog.events.EventType.POINTERMOVE, goog.events.EventType.MSPOINTERMOVE, goog.events.EventType.TOUCHMOVE)
};
goog.events.PointerAsMouseEventType = {
    MOUSEDOWN: goog.events.PointerFallbackEventType.POINTERDOWN,
    MOUSEUP: goog.events.PointerFallbackEventType.POINTERUP,
    MOUSECANCEL: goog.events.PointerFallbackEventType.POINTERCANCEL,
    MOUSEMOVE: goog.events.PointerFallbackEventType.POINTERMOVE,
    MOUSEOVER: goog.events.PointerFallbackEventType.POINTEROVER,
    MOUSEOUT: goog.events.PointerFallbackEventType.POINTEROUT,
    MOUSEENTER: goog.events.PointerFallbackEventType.POINTERENTER,
    MOUSELEAVE: goog.events.PointerFallbackEventType.POINTERLEAVE
};
goog.events.PointerAsTouchEventType = {
    TOUCHCANCEL: goog.events.PointerTouchFallbackEventType.POINTERCANCEL,
    TOUCHEND: goog.events.PointerTouchFallbackEventType.POINTERUP,
    TOUCHMOVE: goog.events.PointerTouchFallbackEventType.POINTERMOVE,
    TOUCHSTART: goog.events.PointerTouchFallbackEventType.POINTERDOWN
};
goog.provide("goog.events.BrowserEvent");
goog.provide("goog.events.BrowserEvent.MouseButton");
goog.provide("goog.events.BrowserEvent.PointerType");
goog.require("goog.debug");
goog.require("goog.events.BrowserFeature");
goog.require("goog.events.Event");
goog.require("goog.events.EventType");
goog.require("goog.reflect");
goog.require("goog.userAgent");
goog.define("goog.events.USE_LAYER_XY_AS_OFFSET_XY", false);
goog.events.BrowserEvent = function(opt_e, opt_currentTarget) {
    goog.events.BrowserEvent.base(this, "constructor", opt_e ? opt_e.type : "");
    this.target = null;
    this.currentTarget = null;
    this.relatedTarget = null;
    this.offsetX = 0;
    this.offsetY = 0;
    this.clientX = 0;
    this.clientY = 0;
    this.screenX = 0;
    this.screenY = 0;
    this.button = 0;
    this.key = "";
    this.keyCode = 0;
    this.charCode = 0;
    this.ctrlKey = false;
    this.altKey = false;
    this.shiftKey = false;
    this.metaKey = false;
    this.state = null;
    this.platformModifierKey = false;
    this.pointerId = 0;
    this.pointerType = "";
    this.event_ = null;
    if (opt_e) this.init(opt_e, opt_currentTarget)
};
goog.inherits(goog.events.BrowserEvent, goog.events.Event);
goog.events.BrowserEvent.MouseButton = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};
goog.events.BrowserEvent.PointerType = {
    MOUSE: "mouse",
    PEN: "pen",
    TOUCH: "touch"
};
goog.events.BrowserEvent.IEButtonMap = goog.debug.freeze([1, 4, 2]);
goog.events.BrowserEvent.IE_BUTTON_MAP = goog.events.BrowserEvent.IEButtonMap;
goog.events.BrowserEvent.IE_POINTER_TYPE_MAP = goog.debug.freeze({
    2: goog.events.BrowserEvent.PointerType.TOUCH,
    3: goog.events.BrowserEvent.PointerType.PEN,
    4: goog.events.BrowserEvent.PointerType.MOUSE
});
goog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {
    var type = this.type = e.type;
    var relevantTouch = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : null;
    this.target = e.target || e.srcElement;
    this.currentTarget = opt_currentTarget;
    var relatedTarget = e.relatedTarget;
    if (relatedTarget) {
        if (goog.userAgent.GECKO)
            if (!goog.reflect.canAccessProperty(relatedTarget, "nodeName")) relatedTarget = null
    } else if (type == goog.events.EventType.MOUSEOVER) relatedTarget = e.fromElement;
    else if (type == goog.events.EventType.MOUSEOUT) relatedTarget =
        e.toElement;
    this.relatedTarget = relatedTarget;
    if (relevantTouch) {
        this.clientX = relevantTouch.clientX !== undefined ? relevantTouch.clientX : relevantTouch.pageX;
        this.clientY = relevantTouch.clientY !== undefined ? relevantTouch.clientY : relevantTouch.pageY;
        this.screenX = relevantTouch.screenX || 0;
        this.screenY = relevantTouch.screenY || 0
    } else {
        if (goog.events.USE_LAYER_XY_AS_OFFSET_XY) {
            this.offsetX = e.layerX !== undefined ? e.layerX : e.offsetX;
            this.offsetY = e.layerY !== undefined ? e.layerY : e.offsetY
        } else {
            this.offsetX = goog.userAgent.WEBKIT ||
                e.offsetX !== undefined ? e.offsetX : e.layerX;
            this.offsetY = goog.userAgent.WEBKIT || e.offsetY !== undefined ? e.offsetY : e.layerY
        }
        this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;
        this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;
        this.screenX = e.screenX || 0;
        this.screenY = e.screenY || 0
    }
    this.button = e.button;
    this.keyCode = e.keyCode || 0;
    this.key = e.key || "";
    this.charCode = e.charCode || (type == "keypress" ? e.keyCode : 0);
    this.ctrlKey = e.ctrlKey;
    this.altKey = e.altKey;
    this.shiftKey = e.shiftKey;
    this.metaKey = e.metaKey;
    this.platformModifierKey =
        goog.userAgent.MAC ? e.metaKey : e.ctrlKey;
    this.pointerId = e.pointerId || 0;
    this.pointerType = goog.events.BrowserEvent.getPointerType_(e);
    this.state = e.state;
    this.event_ = e;
    if (e.defaultPrevented) this.preventDefault()
};
goog.events.BrowserEvent.prototype.isButton = function(button) {
    if (!goog.events.BrowserFeature.HAS_W3C_BUTTON)
        if (this.type == "click") return button == goog.events.BrowserEvent.MouseButton.LEFT;
        else return !!(this.event_.button & goog.events.BrowserEvent.IE_BUTTON_MAP[button]);
    else return this.event_.button == button
};
goog.events.BrowserEvent.prototype.isMouseActionButton = function() {
    return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) && !(goog.userAgent.WEBKIT && goog.userAgent.MAC && this.ctrlKey)
};
goog.events.BrowserEvent.prototype.stopPropagation = function() {
    goog.events.BrowserEvent.superClass_.stopPropagation.call(this);
    if (this.event_.stopPropagation) this.event_.stopPropagation();
    else this.event_.cancelBubble = true
};
goog.events.BrowserEvent.prototype.preventDefault = function() {
    goog.events.BrowserEvent.superClass_.preventDefault.call(this);
    var be = this.event_;
    if (!be.preventDefault) {
        be.returnValue = false;
        if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) try {
            var VK_F1 = 112;
            var VK_F12 = 123;
            if (be.ctrlKey || be.keyCode >= VK_F1 && be.keyCode <= VK_F12) be.keyCode = -1
        } catch (ex) {}
    } else be.preventDefault()
};
goog.events.BrowserEvent.prototype.getBrowserEvent = function() {
    return this.event_
};
goog.events.BrowserEvent.getPointerType_ = function(e) {
    if (goog.isString(e.pointerType)) return e.pointerType;
    return goog.events.BrowserEvent.IE_POINTER_TYPE_MAP[e.pointerType] || ""
};
goog.provide("goog.events.Listenable");
goog.provide("goog.events.ListenableKey");
goog.require("goog.events.EventId");
goog.forwardDeclare("goog.events.EventLike");
goog.forwardDeclare("goog.events.EventTarget");
goog.events.Listenable = function() {};
goog.events.Listenable.IMPLEMENTED_BY_PROP = "closure_listenable_" + (Math.random() * 1E6 | 0);
goog.events.Listenable.addImplementation = function(cls) {
    cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true
};
goog.events.Listenable.isImplementedBy = function(obj) {
    return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP])
};
goog.events.Listenable.prototype.listen;
goog.events.Listenable.prototype.listenOnce;
goog.events.Listenable.prototype.unlisten;
goog.events.Listenable.prototype.unlistenByKey;
goog.events.Listenable.prototype.dispatchEvent;
goog.events.Listenable.prototype.removeAllListeners;
goog.events.Listenable.prototype.getParentEventTarget;
goog.events.Listenable.prototype.fireListeners;
goog.events.Listenable.prototype.getListeners;
goog.events.Listenable.prototype.getListener;
goog.events.Listenable.prototype.hasListener;
goog.events.ListenableKey = function() {};
goog.events.ListenableKey.counter_ = 0;
goog.events.ListenableKey.reserveKey = function() {
    return ++goog.events.ListenableKey.counter_
};
goog.events.ListenableKey.prototype.src;
goog.events.ListenableKey.prototype.type;
goog.events.ListenableKey.prototype.listener;
goog.events.ListenableKey.prototype.capture;
goog.events.ListenableKey.prototype.handler;
goog.events.ListenableKey.prototype.key;
goog.provide("goog.events.Listener");
goog.require("goog.events.ListenableKey");
goog.events.Listener = function(listener, proxy, src, type, capture, opt_handler) {
    if (goog.events.Listener.ENABLE_MONITORING) this.creationStack = (new Error).stack;
    this.listener = listener;
    this.proxy = proxy;
    this.src = src;
    this.type = type;
    this.capture = !!capture;
    this.handler = opt_handler;
    this.key = goog.events.ListenableKey.reserveKey();
    this.callOnce = false;
    this.removed = false
};
goog.define("goog.events.Listener.ENABLE_MONITORING", false);
goog.events.Listener.prototype.creationStack;
goog.events.Listener.prototype.markAsRemoved = function() {
    this.removed = true;
    this.listener = null;
    this.proxy = null;
    this.src = null;
    this.handler = null
};
goog.provide("goog.events.ListenerMap");
goog.require("goog.array");
goog.require("goog.events.Listener");
goog.require("goog.object");
goog.events.ListenerMap = function(src) {
    this.src = src;
    this.listeners = {};
    this.typeCount_ = 0
};
goog.events.ListenerMap.prototype.getTypeCount = function() {
    return this.typeCount_
};
goog.events.ListenerMap.prototype.getListenerCount = function() {
    var count = 0;
    for (var type in this.listeners) count += this.listeners[type].length;
    return count
};
goog.events.ListenerMap.prototype.add = function(type, listener, callOnce, opt_useCapture, opt_listenerScope) {
    var typeStr = type.toString();
    var listenerArray = this.listeners[typeStr];
    if (!listenerArray) {
        listenerArray = this.listeners[typeStr] = [];
        this.typeCount_++
    }
    var listenerObj;
    var index = goog.events.ListenerMap.findListenerIndex_(listenerArray, listener, opt_useCapture, opt_listenerScope);
    if (index > -1) {
        listenerObj = listenerArray[index];
        if (!callOnce) listenerObj.callOnce = false
    } else {
        listenerObj = new goog.events.Listener(listener,
            null, this.src, typeStr, !!opt_useCapture, opt_listenerScope);
        listenerObj.callOnce = callOnce;
        listenerArray.push(listenerObj)
    }
    return listenerObj
};
goog.events.ListenerMap.prototype.remove = function(type, listener, opt_useCapture, opt_listenerScope) {
    var typeStr = type.toString();
    if (!(typeStr in this.listeners)) return false;
    var listenerArray = this.listeners[typeStr];
    var index = goog.events.ListenerMap.findListenerIndex_(listenerArray, listener, opt_useCapture, opt_listenerScope);
    if (index > -1) {
        var listenerObj = listenerArray[index];
        listenerObj.markAsRemoved();
        goog.array.removeAt(listenerArray, index);
        if (listenerArray.length == 0) {
            delete this.listeners[typeStr];
            this.typeCount_--
        }
        return true
    }
    return false
};
goog.events.ListenerMap.prototype.removeByKey = function(listener) {
    var type = listener.type;
    if (!(type in this.listeners)) return false;
    var removed = goog.array.remove(this.listeners[type], listener);
    if (removed) {
        listener.markAsRemoved();
        if (this.listeners[type].length == 0) {
            delete this.listeners[type];
            this.typeCount_--
        }
    }
    return removed
};
goog.events.ListenerMap.prototype.removeAll = function(opt_type) {
    var typeStr = opt_type && opt_type.toString();
    var count = 0;
    for (var type in this.listeners)
        if (!typeStr || type == typeStr) {
            var listenerArray = this.listeners[type];
            for (var i = 0; i < listenerArray.length; i++) {
                ++count;
                listenerArray[i].markAsRemoved()
            }
            delete this.listeners[type];
            this.typeCount_--
        } return count
};
goog.events.ListenerMap.prototype.getListeners = function(type, capture) {
    var listenerArray = this.listeners[type.toString()];
    var rv = [];
    if (listenerArray)
        for (var i = 0; i < listenerArray.length; ++i) {
            var listenerObj = listenerArray[i];
            if (listenerObj.capture == capture) rv.push(listenerObj)
        }
    return rv
};
goog.events.ListenerMap.prototype.getListener = function(type, listener, capture, opt_listenerScope) {
    var listenerArray = this.listeners[type.toString()];
    var i = -1;
    if (listenerArray) i = goog.events.ListenerMap.findListenerIndex_(listenerArray, listener, capture, opt_listenerScope);
    return i > -1 ? listenerArray[i] : null
};
goog.events.ListenerMap.prototype.hasListener = function(opt_type, opt_capture) {
    var hasType = goog.isDef(opt_type);
    var typeStr = hasType ? opt_type.toString() : "";
    var hasCapture = goog.isDef(opt_capture);
    return goog.object.some(this.listeners, function(listenerArray, type) {
        for (var i = 0; i < listenerArray.length; ++i)
            if ((!hasType || listenerArray[i].type == typeStr) && (!hasCapture || listenerArray[i].capture == opt_capture)) return true;
        return false
    })
};
goog.events.ListenerMap.findListenerIndex_ = function(listenerArray, listener, opt_useCapture, opt_listenerScope) {
    for (var i = 0; i < listenerArray.length; ++i) {
        var listenerObj = listenerArray[i];
        if (!listenerObj.removed && listenerObj.listener == listener && listenerObj.capture == !!opt_useCapture && listenerObj.handler == opt_listenerScope) return i
    }
    return -1
};
goog.provide("goog.events");
goog.provide("goog.events.CaptureSimulationMode");
goog.provide("goog.events.Key");
goog.provide("goog.events.ListenableType");
goog.require("goog.asserts");
goog.require("goog.debug.entryPointRegistry");
goog.require("goog.events.BrowserEvent");
goog.require("goog.events.BrowserFeature");
goog.require("goog.events.Listenable");
goog.require("goog.events.ListenerMap");
goog.forwardDeclare("goog.debug.ErrorHandler");
goog.forwardDeclare("goog.events.EventWrapper");
goog.events.Key;
goog.events.ListenableType;
goog.events.LISTENER_MAP_PROP_ = "closure_lm_" + (Math.random() * 1E6 | 0);
goog.events.onString_ = "on";
goog.events.onStringMap_ = {};
goog.events.CaptureSimulationMode = {
    OFF_AND_FAIL: 0,
    OFF_AND_SILENT: 1,
    ON: 2
};
goog.define("goog.events.CAPTURE_SIMULATION_MODE", 2);
goog.events.listenerCountEstimate_ = 0;
goog.events.listen = function(src, type, listener, opt_options, opt_handler) {
    if (opt_options && opt_options.once) return goog.events.listenOnce(src, type, listener, opt_options, opt_handler);
    if (goog.isArray(type)) {
        for (var i = 0; i < type.length; i++) goog.events.listen(src, type[i], listener, opt_options, opt_handler);
        return null
    }
    listener = goog.events.wrapListener(listener);
    if (goog.events.Listenable.isImplementedBy(src)) {
        var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
        return src.listen(type, listener,
            capture, opt_handler)
    } else return goog.events.listen_(src, type, listener, false, opt_options, opt_handler)
};
goog.events.listen_ = function(src, type, listener, callOnce, opt_options, opt_handler) {
    if (!type) throw new Error("Invalid event type");
    var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
    if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT)
        if (goog.events.CAPTURE_SIMULATION_MODE == goog.events.CaptureSimulationMode.OFF_AND_FAIL) {
            goog.asserts.fail("Can not register capture listener in IE8-.");
            return null
        } else if (goog.events.CAPTURE_SIMULATION_MODE == goog.events.CaptureSimulationMode.OFF_AND_SILENT) return null;
    var listenerMap = goog.events.getListenerMap_(src);
    if (!listenerMap) src[goog.events.LISTENER_MAP_PROP_] = listenerMap = new goog.events.ListenerMap(src);
    var listenerObj = listenerMap.add(type, listener, callOnce, capture, opt_handler);
    if (listenerObj.proxy) return listenerObj;
    var proxy = goog.events.getProxy();
    listenerObj.proxy = proxy;
    proxy.src = src;
    proxy.listener = listenerObj;
    if (src.addEventListener) {
        if (!goog.events.BrowserFeature.PASSIVE_EVENTS) opt_options = capture;
        if (opt_options === undefined) opt_options = false;
        src.addEventListener(type.toString(),
            proxy, opt_options)
    } else if (src.attachEvent) src.attachEvent(goog.events.getOnString_(type.toString()), proxy);
    else if (src.addListener && src.removeListener) {
        goog.asserts.assert(type === "change", "MediaQueryList only has a change event");
        src.addListener(proxy)
    } else throw new Error("addEventListener and attachEvent are unavailable.");
    goog.events.listenerCountEstimate_++;
    return listenerObj
};
goog.events.getProxy = function() {
    var proxyCallbackFunction = goog.events.handleBrowserEvent_;
    var f = goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ? function(eventObject) {
        return proxyCallbackFunction.call(f.src, f.listener, eventObject)
    } : function(eventObject) {
        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);
        if (!v) return v
    };
    return f
};
goog.events.listenOnce = function(src, type, listener, opt_options, opt_handler) {
    if (goog.isArray(type)) {
        for (var i = 0; i < type.length; i++) goog.events.listenOnce(src, type[i], listener, opt_options, opt_handler);
        return null
    }
    listener = goog.events.wrapListener(listener);
    if (goog.events.Listenable.isImplementedBy(src)) {
        var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
        return src.listenOnce(type, listener, capture, opt_handler)
    } else return goog.events.listen_(src, type, listener, true, opt_options, opt_handler)
};
goog.events.listenWithWrapper = function(src, wrapper, listener, opt_capt, opt_handler) {
    wrapper.listen(src, listener, opt_capt, opt_handler)
};
goog.events.unlisten = function(src, type, listener, opt_options, opt_handler) {
    if (goog.isArray(type)) {
        for (var i = 0; i < type.length; i++) goog.events.unlisten(src, type[i], listener, opt_options, opt_handler);
        return null
    }
    var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
    listener = goog.events.wrapListener(listener);
    if (goog.events.Listenable.isImplementedBy(src)) return src.unlisten(type, listener, capture, opt_handler);
    if (!src) return false;
    var listenerMap = goog.events.getListenerMap_(src);
    if (listenerMap) {
        var listenerObj =
            listenerMap.getListener(type, listener, capture, opt_handler);
        if (listenerObj) return goog.events.unlistenByKey(listenerObj)
    }
    return false
};
goog.events.unlistenByKey = function(key) {
    if (goog.isNumber(key)) return false;
    var listener = key;
    if (!listener || listener.removed) return false;
    var src = listener.src;
    if (goog.events.Listenable.isImplementedBy(src)) return src.unlistenByKey(listener);
    var type = listener.type;
    var proxy = listener.proxy;
    if (src.removeEventListener) src.removeEventListener(type, proxy, listener.capture);
    else if (src.detachEvent) src.detachEvent(goog.events.getOnString_(type), proxy);
    else if (src.addListener && src.removeListener) src.removeListener(proxy);
    goog.events.listenerCountEstimate_--;
    var listenerMap = goog.events.getListenerMap_(src);
    if (listenerMap) {
        listenerMap.removeByKey(listener);
        if (listenerMap.getTypeCount() == 0) {
            listenerMap.src = null;
            src[goog.events.LISTENER_MAP_PROP_] = null
        }
    } else listener.markAsRemoved();
    return true
};
goog.events.unlistenWithWrapper = function(src, wrapper, listener, opt_capt, opt_handler) {
    wrapper.unlisten(src, listener, opt_capt, opt_handler)
};
goog.events.removeAll = function(obj, opt_type) {
    if (!obj) return 0;
    if (goog.events.Listenable.isImplementedBy(obj)) return obj.removeAllListeners(opt_type);
    var listenerMap = goog.events.getListenerMap_(obj);
    if (!listenerMap) return 0;
    var count = 0;
    var typeStr = opt_type && opt_type.toString();
    for (var type in listenerMap.listeners)
        if (!typeStr || type == typeStr) {
            var listeners = listenerMap.listeners[type].concat();
            for (var i = 0; i < listeners.length; ++i)
                if (goog.events.unlistenByKey(listeners[i])) ++count
        } return count
};
goog.events.getListeners = function(obj, type, capture) {
    if (goog.events.Listenable.isImplementedBy(obj)) return obj.getListeners(type, capture);
    else {
        if (!obj) return [];
        var listenerMap = goog.events.getListenerMap_(obj);
        return listenerMap ? listenerMap.getListeners(type, capture) : []
    }
};
goog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {
    type = type;
    listener = goog.events.wrapListener(listener);
    var capture = !!opt_capt;
    if (goog.events.Listenable.isImplementedBy(src)) return src.getListener(type, listener, capture, opt_handler);
    if (!src) return null;
    var listenerMap = goog.events.getListenerMap_(src);
    if (listenerMap) return listenerMap.getListener(type, listener, capture, opt_handler);
    return null
};
goog.events.hasListener = function(obj, opt_type, opt_capture) {
    if (goog.events.Listenable.isImplementedBy(obj)) return obj.hasListener(opt_type, opt_capture);
    var listenerMap = goog.events.getListenerMap_(obj);
    return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture)
};
goog.events.expose = function(e) {
    var str = [];
    for (var key in e)
        if (e[key] && e[key].id) str.push(key + " = " + e[key] + " (" + e[key].id + ")");
        else str.push(key + " = " + e[key]);
    return str.join("\n")
};
goog.events.getOnString_ = function(type) {
    if (type in goog.events.onStringMap_) return goog.events.onStringMap_[type];
    return goog.events.onStringMap_[type] = goog.events.onString_ + type
};
goog.events.fireListeners = function(obj, type, capture, eventObject) {
    if (goog.events.Listenable.isImplementedBy(obj)) return obj.fireListeners(type, capture, eventObject);
    return goog.events.fireListeners_(obj, type, capture, eventObject)
};
goog.events.fireListeners_ = function(obj, type, capture, eventObject) {
    var retval = true;
    var listenerMap = goog.events.getListenerMap_(obj);
    if (listenerMap) {
        var listenerArray = listenerMap.listeners[type.toString()];
        if (listenerArray) {
            listenerArray = listenerArray.concat();
            for (var i = 0; i < listenerArray.length; i++) {
                var listener = listenerArray[i];
                if (listener && listener.capture == capture && !listener.removed) {
                    var result = goog.events.fireListener(listener, eventObject);
                    retval = retval && result !== false
                }
            }
        }
    }
    return retval
};
goog.events.fireListener = function(listener, eventObject) {
    var listenerFn = listener.listener;
    var listenerHandler = listener.handler || listener.src;
    if (listener.callOnce) goog.events.unlistenByKey(listener);
    return listenerFn.call(listenerHandler, eventObject)
};
goog.events.getTotalListenerCount = function() {
    return goog.events.listenerCountEstimate_
};
goog.events.dispatchEvent = function(src, e) {
    goog.asserts.assert(goog.events.Listenable.isImplementedBy(src), "Can not use goog.events.dispatchEvent with " + "non-goog.events.Listenable instance.");
    return src.dispatchEvent(e)
};
goog.events.protectBrowserEventEntryPoint = function(errorHandler) {
    goog.events.handleBrowserEvent_ = errorHandler.protectEntryPoint(goog.events.handleBrowserEvent_)
};
goog.events.handleBrowserEvent_ = function(listener, opt_evt) {
    if (listener.removed) return true;
    if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
        var ieEvent = opt_evt || goog.getObjectByName("window.event");
        var evt = new goog.events.BrowserEvent(ieEvent, this);
        var retval = true;
        if (goog.events.CAPTURE_SIMULATION_MODE == goog.events.CaptureSimulationMode.ON) {
            if (!goog.events.isMarkedIeEvent_(ieEvent)) {
                goog.events.markIeEvent_(ieEvent);
                var ancestors = [];
                for (var parent = evt.currentTarget; parent; parent = parent.parentNode) ancestors.push(parent);
                var type = listener.type;
                for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0; i--) {
                    evt.currentTarget = ancestors[i];
                    var result = goog.events.fireListeners_(ancestors[i], type, true, evt);
                    retval = retval && result
                }
                for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {
                    evt.currentTarget = ancestors[i];
                    var result = goog.events.fireListeners_(ancestors[i], type, false, evt);
                    retval = retval && result
                }
            }
        } else retval = goog.events.fireListener(listener, evt);
        return retval
    }
    return goog.events.fireListener(listener, new goog.events.BrowserEvent(opt_evt,
        this))
};
goog.events.markIeEvent_ = function(e) {
    var useReturnValue = false;
    if (e.keyCode == 0) try {
        e.keyCode = -1;
        return
    } catch (ex) {
        useReturnValue = true
    }
    if (useReturnValue || e.returnValue == undefined) e.returnValue = true
};
goog.events.isMarkedIeEvent_ = function(e) {
    return e.keyCode < 0 || e.returnValue != undefined
};
goog.events.uniqueIdCounter_ = 0;
goog.events.getUniqueId = function(identifier) {
    return identifier + "_" + goog.events.uniqueIdCounter_++
};
goog.events.getListenerMap_ = function(src) {
    var listenerMap = src[goog.events.LISTENER_MAP_PROP_];
    return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null
};
goog.events.LISTENER_WRAPPER_PROP_ = "__closure_events_fn_" + (Math.random() * 1E9 >>> 0);
goog.events.wrapListener = function(listener) {
    goog.asserts.assert(listener, "Listener can not be null.");
    if (goog.isFunction(listener)) return listener;
    goog.asserts.assert(listener.handleEvent, "An object listener must have handleEvent method.");
    if (!listener[goog.events.LISTENER_WRAPPER_PROP_]) listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {
        return listener.handleEvent(e)
    };
    return listener[goog.events.LISTENER_WRAPPER_PROP_]
};
goog.debug.entryPointRegistry.register(function(transformer) {
    goog.events.handleBrowserEvent_ = transformer(goog.events.handleBrowserEvent_)
});
goog.provide("goog.dom.HtmlElement");
goog.dom.HtmlElement = function() {};
goog.provide("goog.dom.TagName");
goog.require("goog.dom.HtmlElement");
goog.dom.TagName = function(tagName) {
    this.tagName_ = tagName
};
goog.dom.TagName.prototype.toString = function() {
    return this.tagName_
};
goog.dom.TagName.A = new goog.dom.TagName("A");
goog.dom.TagName.ABBR = new goog.dom.TagName("ABBR");
goog.dom.TagName.ACRONYM = new goog.dom.TagName("ACRONYM");
goog.dom.TagName.ADDRESS = new goog.dom.TagName("ADDRESS");
goog.dom.TagName.APPLET = new goog.dom.TagName("APPLET");
goog.dom.TagName.AREA = new goog.dom.TagName("AREA");
goog.dom.TagName.ARTICLE = new goog.dom.TagName("ARTICLE");
goog.dom.TagName.ASIDE = new goog.dom.TagName("ASIDE");
goog.dom.TagName.AUDIO = new goog.dom.TagName("AUDIO");
goog.dom.TagName.B = new goog.dom.TagName("B");
goog.dom.TagName.BASE = new goog.dom.TagName("BASE");
goog.dom.TagName.BASEFONT = new goog.dom.TagName("BASEFONT");
goog.dom.TagName.BDI = new goog.dom.TagName("BDI");
goog.dom.TagName.BDO = new goog.dom.TagName("BDO");
goog.dom.TagName.BIG = new goog.dom.TagName("BIG");
goog.dom.TagName.BLOCKQUOTE = new goog.dom.TagName("BLOCKQUOTE");
goog.dom.TagName.BODY = new goog.dom.TagName("BODY");
goog.dom.TagName.BR = new goog.dom.TagName("BR");
goog.dom.TagName.BUTTON = new goog.dom.TagName("BUTTON");
goog.dom.TagName.CANVAS = new goog.dom.TagName("CANVAS");
goog.dom.TagName.CAPTION = new goog.dom.TagName("CAPTION");
goog.dom.TagName.CENTER = new goog.dom.TagName("CENTER");
goog.dom.TagName.CITE = new goog.dom.TagName("CITE");
goog.dom.TagName.CODE = new goog.dom.TagName("CODE");
goog.dom.TagName.COL = new goog.dom.TagName("COL");
goog.dom.TagName.COLGROUP = new goog.dom.TagName("COLGROUP");
goog.dom.TagName.COMMAND = new goog.dom.TagName("COMMAND");
goog.dom.TagName.DATA = new goog.dom.TagName("DATA");
goog.dom.TagName.DATALIST = new goog.dom.TagName("DATALIST");
goog.dom.TagName.DD = new goog.dom.TagName("DD");
goog.dom.TagName.DEL = new goog.dom.TagName("DEL");
goog.dom.TagName.DETAILS = new goog.dom.TagName("DETAILS");
goog.dom.TagName.DFN = new goog.dom.TagName("DFN");
goog.dom.TagName.DIALOG = new goog.dom.TagName("DIALOG");
goog.dom.TagName.DIR = new goog.dom.TagName("DIR");
goog.dom.TagName.DIV = new goog.dom.TagName("DIV");
goog.dom.TagName.DL = new goog.dom.TagName("DL");
goog.dom.TagName.DT = new goog.dom.TagName("DT");
goog.dom.TagName.EM = new goog.dom.TagName("EM");
goog.dom.TagName.EMBED = new goog.dom.TagName("EMBED");
goog.dom.TagName.FIELDSET = new goog.dom.TagName("FIELDSET");
goog.dom.TagName.FIGCAPTION = new goog.dom.TagName("FIGCAPTION");
goog.dom.TagName.FIGURE = new goog.dom.TagName("FIGURE");
goog.dom.TagName.FONT = new goog.dom.TagName("FONT");
goog.dom.TagName.FOOTER = new goog.dom.TagName("FOOTER");
goog.dom.TagName.FORM = new goog.dom.TagName("FORM");
goog.dom.TagName.FRAME = new goog.dom.TagName("FRAME");
goog.dom.TagName.FRAMESET = new goog.dom.TagName("FRAMESET");
goog.dom.TagName.H1 = new goog.dom.TagName("H1");
goog.dom.TagName.H2 = new goog.dom.TagName("H2");
goog.dom.TagName.H3 = new goog.dom.TagName("H3");
goog.dom.TagName.H4 = new goog.dom.TagName("H4");
goog.dom.TagName.H5 = new goog.dom.TagName("H5");
goog.dom.TagName.H6 = new goog.dom.TagName("H6");
goog.dom.TagName.HEAD = new goog.dom.TagName("HEAD");
goog.dom.TagName.HEADER = new goog.dom.TagName("HEADER");
goog.dom.TagName.HGROUP = new goog.dom.TagName("HGROUP");
goog.dom.TagName.HR = new goog.dom.TagName("HR");
goog.dom.TagName.HTML = new goog.dom.TagName("HTML");
goog.dom.TagName.I = new goog.dom.TagName("I");
goog.dom.TagName.IFRAME = new goog.dom.TagName("IFRAME");
goog.dom.TagName.IMG = new goog.dom.TagName("IMG");
goog.dom.TagName.INPUT = new goog.dom.TagName("INPUT");
goog.dom.TagName.INS = new goog.dom.TagName("INS");
goog.dom.TagName.ISINDEX = new goog.dom.TagName("ISINDEX");
goog.dom.TagName.KBD = new goog.dom.TagName("KBD");
goog.dom.TagName.KEYGEN = new goog.dom.TagName("KEYGEN");
goog.dom.TagName.LABEL = new goog.dom.TagName("LABEL");
goog.dom.TagName.LEGEND = new goog.dom.TagName("LEGEND");
goog.dom.TagName.LI = new goog.dom.TagName("LI");
goog.dom.TagName.LINK = new goog.dom.TagName("LINK");
goog.dom.TagName.MAIN = new goog.dom.TagName("MAIN");
goog.dom.TagName.MAP = new goog.dom.TagName("MAP");
goog.dom.TagName.MARK = new goog.dom.TagName("MARK");
goog.dom.TagName.MATH = new goog.dom.TagName("MATH");
goog.dom.TagName.MENU = new goog.dom.TagName("MENU");
goog.dom.TagName.MENUITEM = new goog.dom.TagName("MENUITEM");
goog.dom.TagName.META = new goog.dom.TagName("META");
goog.dom.TagName.METER = new goog.dom.TagName("METER");
goog.dom.TagName.NAV = new goog.dom.TagName("NAV");
goog.dom.TagName.NOFRAMES = new goog.dom.TagName("NOFRAMES");
goog.dom.TagName.NOSCRIPT = new goog.dom.TagName("NOSCRIPT");
goog.dom.TagName.OBJECT = new goog.dom.TagName("OBJECT");
goog.dom.TagName.OL = new goog.dom.TagName("OL");
goog.dom.TagName.OPTGROUP = new goog.dom.TagName("OPTGROUP");
goog.dom.TagName.OPTION = new goog.dom.TagName("OPTION");
goog.dom.TagName.OUTPUT = new goog.dom.TagName("OUTPUT");
goog.dom.TagName.P = new goog.dom.TagName("P");
goog.dom.TagName.PARAM = new goog.dom.TagName("PARAM");
goog.dom.TagName.PICTURE = new goog.dom.TagName("PICTURE");
goog.dom.TagName.PRE = new goog.dom.TagName("PRE");
goog.dom.TagName.PROGRESS = new goog.dom.TagName("PROGRESS");
goog.dom.TagName.Q = new goog.dom.TagName("Q");
goog.dom.TagName.RP = new goog.dom.TagName("RP");
goog.dom.TagName.RT = new goog.dom.TagName("RT");
goog.dom.TagName.RTC = new goog.dom.TagName("RTC");
goog.dom.TagName.RUBY = new goog.dom.TagName("RUBY");
goog.dom.TagName.S = new goog.dom.TagName("S");
goog.dom.TagName.SAMP = new goog.dom.TagName("SAMP");
goog.dom.TagName.SCRIPT = new goog.dom.TagName("SCRIPT");
goog.dom.TagName.SECTION = new goog.dom.TagName("SECTION");
goog.dom.TagName.SELECT = new goog.dom.TagName("SELECT");
goog.dom.TagName.SMALL = new goog.dom.TagName("SMALL");
goog.dom.TagName.SOURCE = new goog.dom.TagName("SOURCE");
goog.dom.TagName.SPAN = new goog.dom.TagName("SPAN");
goog.dom.TagName.STRIKE = new goog.dom.TagName("STRIKE");
goog.dom.TagName.STRONG = new goog.dom.TagName("STRONG");
goog.dom.TagName.STYLE = new goog.dom.TagName("STYLE");
goog.dom.TagName.SUB = new goog.dom.TagName("SUB");
goog.dom.TagName.SUMMARY = new goog.dom.TagName("SUMMARY");
goog.dom.TagName.SUP = new goog.dom.TagName("SUP");
goog.dom.TagName.SVG = new goog.dom.TagName("SVG");
goog.dom.TagName.TABLE = new goog.dom.TagName("TABLE");
goog.dom.TagName.TBODY = new goog.dom.TagName("TBODY");
goog.dom.TagName.TD = new goog.dom.TagName("TD");
goog.dom.TagName.TEMPLATE = new goog.dom.TagName("TEMPLATE");
goog.dom.TagName.TEXTAREA = new goog.dom.TagName("TEXTAREA");
goog.dom.TagName.TFOOT = new goog.dom.TagName("TFOOT");
goog.dom.TagName.TH = new goog.dom.TagName("TH");
goog.dom.TagName.THEAD = new goog.dom.TagName("THEAD");
goog.dom.TagName.TIME = new goog.dom.TagName("TIME");
goog.dom.TagName.TITLE = new goog.dom.TagName("TITLE");
goog.dom.TagName.TR = new goog.dom.TagName("TR");
goog.dom.TagName.TRACK = new goog.dom.TagName("TRACK");
goog.dom.TagName.TT = new goog.dom.TagName("TT");
goog.dom.TagName.U = new goog.dom.TagName("U");
goog.dom.TagName.UL = new goog.dom.TagName("UL");
goog.dom.TagName.VAR = new goog.dom.TagName("VAR");
goog.dom.TagName.VIDEO = new goog.dom.TagName("VIDEO");
goog.dom.TagName.WBR = new goog.dom.TagName("WBR");
goog.provide("goog.dom.BrowserFeature");
goog.require("goog.userAgent");
goog.dom.BrowserFeature = {
    CAN_ADD_NAME_OR_TYPE_ATTRIBUTES: !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9),
    CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE || goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9) || goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher("1.9.1"),
    CAN_USE_INNER_TEXT: goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("9"),
    CAN_USE_PARENT_ELEMENT_PROPERTY: goog.userAgent.IE || goog.userAgent.OPERA || goog.userAgent.WEBKIT,
    INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE,
    LEGACY_IE_RANGES: goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)
};
goog.provide("goog.dom.asserts");
goog.require("goog.asserts");
goog.dom.asserts.assertIsLocation = function(o) {
    if (goog.asserts.ENABLE_ASSERTS) {
        var win = goog.dom.asserts.getWindow_(o);
        if (typeof win.Location != "undefined" && typeof win.Element != "undefined") goog.asserts.assert(o && (o instanceof win.Location || !(o instanceof win.Element)), "Argument is not a Location (or a non-Element mock); got: %s", goog.dom.asserts.debugStringForType_(o))
    }
    return o
};
goog.dom.asserts.assertIsElementType_ = function(o, typename) {
    if (goog.asserts.ENABLE_ASSERTS) {
        var win = goog.dom.asserts.getWindow_(o);
        if (typeof win[typename] != "undefined" && typeof win.Location != "undefined" && typeof win.Element != "undefined") goog.asserts.assert(o && (o instanceof win[typename] || !(o instanceof win.Location || o instanceof win.Element)), "Argument is not a %s (or a non-Element, non-Location mock); got: %s", typename, goog.dom.asserts.debugStringForType_(o))
    }
    return o
};
goog.dom.asserts.assertIsHTMLAnchorElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLAnchorElement")
};
goog.dom.asserts.assertIsHTMLButtonElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLButtonElement")
};
goog.dom.asserts.assertIsHTMLLinkElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLLinkElement")
};
goog.dom.asserts.assertIsHTMLImageElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLImageElement")
};
goog.dom.asserts.assertIsHTMLAudioElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLAudioElement")
};
goog.dom.asserts.assertIsHTMLVideoElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLVideoElement")
};
goog.dom.asserts.assertIsHTMLInputElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLInputElement")
};
goog.dom.asserts.assertIsHTMLEmbedElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLEmbedElement")
};
goog.dom.asserts.assertIsHTMLFormElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLFormElement")
};
goog.dom.asserts.assertIsHTMLFrameElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLFrameElement")
};
goog.dom.asserts.assertIsHTMLIFrameElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLIFrameElement")
};
goog.dom.asserts.assertIsHTMLObjectElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLObjectElement")
};
goog.dom.asserts.assertIsHTMLScriptElement = function(o) {
    return goog.dom.asserts.assertIsElementType_(o, "HTMLScriptElement")
};
goog.dom.asserts.debugStringForType_ = function(value) {
    if (goog.isObject(value)) return value.constructor.displayName || value.constructor.name || Object.prototype.toString.call(value);
    else return value === undefined ? "undefined" : value === null ? "null" : typeof value
};
goog.dom.asserts.getWindow_ = function(o) {
    var doc = o && o.ownerDocument;
    var win = doc && (doc.defaultView || doc.parentWindow);
    return win || goog.global
};
goog.provide("goog.functions");
goog.functions.constant = function(retValue) {
    return function() {
        return retValue
    }
};
goog.functions.FALSE = function() {
    return false
};
goog.functions.TRUE = function() {
    return true
};
goog.functions.NULL = function() {
    return null
};
goog.functions.identity = function(opt_returnValue, var_args) {
    return opt_returnValue
};
goog.functions.error = function(message) {
    return function() {
        throw new Error(message);
    }
};
goog.functions.fail = function(err) {
    return function() {
        throw err;
    }
};
goog.functions.lock = function(f, opt_numArgs) {
    opt_numArgs = opt_numArgs || 0;
    return function() {
        var self = this;
        return f.apply(self, Array.prototype.slice.call(arguments, 0, opt_numArgs))
    }
};
goog.functions.nth = function(n) {
    return function() {
        return arguments[n]
    }
};
goog.functions.partialRight = function(fn, var_args) {
    var rightArgs = Array.prototype.slice.call(arguments, 1);
    return function() {
        var self = this;
        var newArgs = Array.prototype.slice.call(arguments);
        newArgs.push.apply(newArgs, rightArgs);
        return fn.apply(self, newArgs)
    }
};
goog.functions.withReturnValue = function(f, retValue) {
    return goog.functions.sequence(f, goog.functions.constant(retValue))
};
goog.functions.equalTo = function(value, opt_useLooseComparison) {
    return function(other) {
        return opt_useLooseComparison ? value == other : value === other
    }
};
goog.functions.compose = function(fn, var_args) {
    var functions = arguments;
    var length = functions.length;
    return function() {
        var self = this;
        var result;
        if (length) result = functions[length - 1].apply(self, arguments);
        for (var i = length - 2; i >= 0; i--) result = functions[i].call(self, result);
        return result
    }
};
goog.functions.sequence = function(var_args) {
    var functions = arguments;
    var length = functions.length;
    return function() {
        var self = this;
        var result;
        for (var i = 0; i < length; i++) result = functions[i].apply(self, arguments);
        return result
    }
};
goog.functions.and = function(var_args) {
    var functions = arguments;
    var length = functions.length;
    return function() {
        var self = this;
        for (var i = 0; i < length; i++)
            if (!functions[i].apply(self, arguments)) return false;
        return true
    }
};
goog.functions.or = function(var_args) {
    var functions = arguments;
    var length = functions.length;
    return function() {
        var self = this;
        for (var i = 0; i < length; i++)
            if (functions[i].apply(self, arguments)) return true;
        return false
    }
};
goog.functions.not = function(f) {
    return function() {
        var self = this;
        return !f.apply(self, arguments)
    }
};
goog.functions.create = function(constructor, var_args) {
    var temp = function() {};
    temp.prototype = constructor.prototype;
    var obj = new temp;
    constructor.apply(obj, Array.prototype.slice.call(arguments, 1));
    return obj
};
goog.define("goog.functions.CACHE_RETURN_VALUE", true);
goog.functions.cacheReturnValue = function(fn) {
    var called = false;
    var value;
    return function() {
        if (!goog.functions.CACHE_RETURN_VALUE) return fn();
        if (!called) {
            value = fn();
            called = true
        }
        return value
    }
};
goog.functions.once = function(f) {
    var inner = f;
    return function() {
        if (inner) {
            var tmp = inner;
            inner = null;
            tmp()
        }
    }
};
goog.functions.debounce = function(f, interval, opt_scope) {
    var timeout = 0;
    return function(var_args) {
        goog.global.clearTimeout(timeout);
        var args = arguments;
        timeout = goog.global.setTimeout(function() {
            f.apply(opt_scope, args)
        }, interval)
    }
};
goog.functions.throttle = function(f, interval, opt_scope) {
    var timeout = 0;
    var shouldFire = false;
    var args = [];
    var handleTimeout = function() {
        timeout = 0;
        if (shouldFire) {
            shouldFire = false;
            fire()
        }
    };
    var fire = function() {
        timeout = goog.global.setTimeout(handleTimeout, interval);
        f.apply(opt_scope, args)
    };
    return function(var_args) {
        args = arguments;
        if (!timeout) fire();
        else shouldFire = true
    }
};
goog.functions.rateLimit = function(f, interval, opt_scope) {
    var timeout = 0;
    var handleTimeout = function() {
        timeout = 0
    };
    return function(var_args) {
        if (!timeout) {
            timeout = goog.global.setTimeout(handleTimeout, interval);
            f.apply(opt_scope, arguments)
        }
    }
};
goog.provide("goog.dom.tags");
goog.require("goog.object");
goog.dom.tags.VOID_TAGS_ = goog.object.createSet("area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr");
goog.dom.tags.isVoidTag = function(tagName) {
    return goog.dom.tags.VOID_TAGS_[tagName] === true
};
goog.provide("goog.string.TypedString");
goog.string.TypedString = function() {};
goog.string.TypedString.prototype.implementsGoogStringTypedString;
goog.string.TypedString.prototype.getTypedStringValue;
goog.provide("goog.string.Const");
goog.require("goog.asserts");
goog.require("goog.string.TypedString");
goog.string.Const = function(opt_token, opt_content) {
    this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = opt_token === goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ && opt_content || "";
    this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ = goog.string.Const.TYPE_MARKER_
};
goog.string.Const.prototype.implementsGoogStringTypedString = true;
goog.string.Const.prototype.getTypedStringValue = function() {
    return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_
};
goog.string.Const.prototype.toString = function() {
    return "Const{" + this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ + "}"
};
goog.string.Const.unwrap = function(stringConst) {
    if (stringConst instanceof goog.string.Const && stringConst.constructor === goog.string.Const && stringConst.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ === goog.string.Const.TYPE_MARKER_) return stringConst.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
    else {
        goog.asserts.fail("expected object of type Const, got '" + stringConst + "'");
        return "type_error:Const"
    }
};
goog.string.Const.from = function(s) {
    return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, s)
};
goog.string.Const.TYPE_MARKER_ = {};
goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {};
goog.string.Const.EMPTY = goog.string.Const.from("");
goog.provide("goog.html.SafeScript");
goog.require("goog.asserts");
goog.require("goog.string.Const");
goog.require("goog.string.TypedString");
goog.html.SafeScript = function() {
    this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = "";
    this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_
};
goog.html.SafeScript.prototype.implementsGoogStringTypedString = true;
goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeScript.fromConstant = function(script) {
    var scriptString = goog.string.Const.unwrap(script);
    if (scriptString.length === 0) return goog.html.SafeScript.EMPTY;
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(scriptString)
};
goog.html.SafeScript.fromConstantAndArgs = function(code, var_args) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(goog.html.SafeScript.stringify_(arguments[i]));
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("(" + goog.string.Const.unwrap(code) + ")(" + args.join(", ") + ");")
};
goog.html.SafeScript.fromJson = function(val) {
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(val))
};
goog.html.SafeScript.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeScriptWrappedValue_
};
if (goog.DEBUG) goog.html.SafeScript.prototype.toString = function() {
    return "SafeScript{" + this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + "}"
};
goog.html.SafeScript.unwrap = function(safeScript) {
    if (safeScript instanceof goog.html.SafeScript && safeScript.constructor === goog.html.SafeScript && safeScript.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) return safeScript.privateDoNotAccessOrElseSafeScriptWrappedValue_;
    else {
        goog.asserts.fail("expected object of type SafeScript, got '" + safeScript + "' of type " + goog.typeOf(safeScript));
        return "type_error:SafeScript"
    }
};
goog.html.SafeScript.stringify_ = function(val) {
    var json = JSON.stringify(val);
    return json.replace(/</g, "\\x3c")
};
goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = function(script) {
    return (new goog.html.SafeScript).initSecurityPrivateDoNotAccessOrElse_(script)
};
goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(script) {
    this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = script;
    return this
};
goog.html.SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");
goog.provide("goog.fs.url");
goog.fs.url.createObjectUrl = function(blob) {
    return goog.fs.url.getUrlObject_().createObjectURL(blob)
};
goog.fs.url.revokeObjectUrl = function(url) {
    goog.fs.url.getUrlObject_().revokeObjectURL(url)
};
goog.fs.url.UrlObject_;
goog.fs.url.getUrlObject_ = function() {
    var urlObject = goog.fs.url.findUrlObject_();
    if (urlObject != null) return urlObject;
    else throw new Error("This browser doesn't seem to support blob URLs");
};
goog.fs.url.findUrlObject_ = function() {
    if (goog.isDef(goog.global.URL) && goog.isDef(goog.global.URL.createObjectURL)) return goog.global.URL;
    else if (goog.isDef(goog.global.webkitURL) && goog.isDef(goog.global.webkitURL.createObjectURL)) return goog.global.webkitURL;
    else if (goog.isDef(goog.global.createObjectURL)) return goog.global;
    else return null
};
goog.fs.url.browserSupportsObjectUrls = function() {
    return goog.fs.url.findUrlObject_() != null
};
goog.provide("goog.i18n.bidi");
goog.provide("goog.i18n.bidi.Dir");
goog.provide("goog.i18n.bidi.DirectionalString");
goog.provide("goog.i18n.bidi.Format");
goog.define("goog.i18n.bidi.FORCE_RTL", false);
goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || (goog.LOCALE.substring(0, 2).toLowerCase() == "ar" || goog.LOCALE.substring(0, 2).toLowerCase() == "fa" || goog.LOCALE.substring(0, 2).toLowerCase() == "he" || goog.LOCALE.substring(0, 2).toLowerCase() == "iw" || goog.LOCALE.substring(0, 2).toLowerCase() == "ps" || goog.LOCALE.substring(0, 2).toLowerCase() == "sd" || goog.LOCALE.substring(0, 2).toLowerCase() == "ug" || goog.LOCALE.substring(0, 2).toLowerCase() == "ur" || goog.LOCALE.substring(0, 2).toLowerCase() == "yi") && (goog.LOCALE.length ==
    2 || goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") || goog.LOCALE.length >= 3 && goog.LOCALE.substring(0, 3).toLowerCase() == "ckb" && (goog.LOCALE.length == 3 || goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") || goog.LOCALE.length >= 7 && ((goog.LOCALE.substring(2, 3) == "-" || goog.LOCALE.substring(2, 3) == "_") && (goog.LOCALE.substring(3, 7).toLowerCase() == "adlm" || goog.LOCALE.substring(3, 7).toLowerCase() == "arab" || goog.LOCALE.substring(3, 7).toLowerCase() == "hebr" || goog.LOCALE.substring(3, 7).toLowerCase() ==
    "nkoo" || goog.LOCALE.substring(3, 7).toLowerCase() == "rohg" || goog.LOCALE.substring(3, 7).toLowerCase() == "thaa")) || goog.LOCALE.length >= 8 && ((goog.LOCALE.substring(3, 4) == "-" || goog.LOCALE.substring(3, 4) == "_") && (goog.LOCALE.substring(4, 8).toLowerCase() == "adlm" || goog.LOCALE.substring(4, 8).toLowerCase() == "arab" || goog.LOCALE.substring(4, 8).toLowerCase() == "hebr" || goog.LOCALE.substring(4, 8).toLowerCase() == "nkoo" || goog.LOCALE.substring(4, 8).toLowerCase() == "rohg" || goog.LOCALE.substring(4, 8).toLowerCase() == "thaa"));
goog.i18n.bidi.Format = {
    LRE: "\u202a",
    RLE: "\u202b",
    PDF: "\u202c",
    LRM: "\u200e",
    RLM: "\u200f"
};
goog.i18n.bidi.Dir = {
    LTR: 1,
    RTL: -1,
    NEUTRAL: 0
};
goog.i18n.bidi.RIGHT = "right";
goog.i18n.bidi.LEFT = "left";
goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;
goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
goog.i18n.bidi.toDir = function(givenDir, opt_noNeutral) {
    if (typeof givenDir == "number") return givenDir > 0 ? goog.i18n.bidi.Dir.LTR : givenDir < 0 ? goog.i18n.bidi.Dir.RTL : opt_noNeutral ? null : goog.i18n.bidi.Dir.NEUTRAL;
    else if (givenDir == null) return null;
    else return givenDir ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR
};
goog.i18n.bidi.ltrChars_ = "A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02b8\u0300-\u0590\u0900-\u1fff" + "\u200e\u2c00-\ud801\ud804-\ud839\ud83c-\udbff" + "\uf900-\ufb1c\ufe00-\ufe6f\ufefd-\uffff";
goog.i18n.bidi.rtlChars_ = "\u0591-\u06ef\u06fa-\u08ff\u200f\ud802-\ud803\ud83a-\ud83b" + "\ufb1d-\ufdff\ufe70-\ufefc";
goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;
goog.i18n.bidi.stripHtmlIfNeeded_ = function(str, opt_isStripNeeded) {
    return opt_isStripNeeded ? str.replace(goog.i18n.bidi.htmlSkipReg_, "") : str
};
goog.i18n.bidi.rtlCharReg_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]");
goog.i18n.bidi.ltrCharReg_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]");
goog.i18n.bidi.hasAnyRtl = function(str, opt_isHtml) {
    return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml))
};
goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;
goog.i18n.bidi.hasAnyLtr = function(str, opt_isHtml) {
    return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml))
};
goog.i18n.bidi.ltrRe_ = new RegExp("^[" + goog.i18n.bidi.ltrChars_ + "]");
goog.i18n.bidi.rtlRe_ = new RegExp("^[" + goog.i18n.bidi.rtlChars_ + "]");
goog.i18n.bidi.isRtlChar = function(str) {
    return goog.i18n.bidi.rtlRe_.test(str)
};
goog.i18n.bidi.isLtrChar = function(str) {
    return goog.i18n.bidi.ltrRe_.test(str)
};
goog.i18n.bidi.isNeutralChar = function(str) {
    return !goog.i18n.bidi.isLtrChar(str) && !goog.i18n.bidi.isRtlChar(str)
};
goog.i18n.bidi.ltrDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.rtlChars_ + "]*[" + goog.i18n.bidi.ltrChars_ + "]");
goog.i18n.bidi.rtlDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.ltrChars_ + "]*[" + goog.i18n.bidi.rtlChars_ + "]");
goog.i18n.bidi.startsWithRtl = function(str, opt_isHtml) {
    return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml))
};
goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;
goog.i18n.bidi.startsWithLtr = function(str, opt_isHtml) {
    return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml))
};
goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;
goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;
goog.i18n.bidi.isNeutralText = function(str, opt_isHtml) {
    str = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml);
    return goog.i18n.bidi.isRequiredLtrRe_.test(str) || !goog.i18n.bidi.hasAnyLtr(str) && !goog.i18n.bidi.hasAnyRtl(str)
};
goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]" + "[^" + goog.i18n.bidi.rtlChars_ + "]*$");
goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]" + "[^" + goog.i18n.bidi.ltrChars_ + "]*$");
goog.i18n.bidi.endsWithLtr = function(str, opt_isHtml) {
    return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml))
};
goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;
goog.i18n.bidi.endsWithRtl = function(str, opt_isHtml) {
    return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml))
};
goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;
goog.i18n.bidi.rtlLocalesRe_ = new RegExp("^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|" + ".*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))" + "(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)", "i");
goog.i18n.bidi.isRtlLanguage = function(lang) {
    return goog.i18n.bidi.rtlLocalesRe_.test(lang)
};
goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
goog.i18n.bidi.guardBracketInText = function(s, opt_isRtlContext) {
    var useRtl = opt_isRtlContext === undefined ? goog.i18n.bidi.hasAnyRtl(s) : opt_isRtlContext;
    var mark = useRtl ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
    return s.replace(goog.i18n.bidi.bracketGuardTextRe_, mark + "$&" + mark)
};
goog.i18n.bidi.enforceRtlInHtml = function(html) {
    if (html.charAt(0) == "<") return html.replace(/<\w+/, "$& dir=rtl");
    return "\n<span dir=rtl>" + html + "</span>"
};
goog.i18n.bidi.enforceRtlInText = function(text) {
    return goog.i18n.bidi.Format.RLE + text + goog.i18n.bidi.Format.PDF
};
goog.i18n.bidi.enforceLtrInHtml = function(html) {
    if (html.charAt(0) == "<") return html.replace(/<\w+/, "$& dir=ltr");
    return "\n<span dir=ltr>" + html + "</span>"
};
goog.i18n.bidi.enforceLtrInText = function(text) {
    return goog.i18n.bidi.Format.LRE + text + goog.i18n.bidi.Format.PDF
};
goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;
goog.i18n.bidi.leftRe_ = /left/gi;
goog.i18n.bidi.rightRe_ = /right/gi;
goog.i18n.bidi.tempRe_ = /%%%%/g;
goog.i18n.bidi.mirrorCSS = function(cssStr) {
    return cssStr.replace(goog.i18n.bidi.dimensionsRe_, ":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_, "%%%%").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT)
};
goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;
goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;
goog.i18n.bidi.normalizeHebrewQuote = function(str) {
    return str.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, "$1\u05f4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, "$1\u05f3")
};
goog.i18n.bidi.wordSeparatorRe_ = /\s+/;
goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/;
goog.i18n.bidi.rtlDetectionThreshold_ = .4;
goog.i18n.bidi.estimateDirection = function(str, opt_isHtml) {
    var rtlCount = 0;
    var totalCount = 0;
    var hasWeaklyLtr = false;
    var tokens = goog.i18n.bidi.stripHtmlIfNeeded_(str, opt_isHtml).split(goog.i18n.bidi.wordSeparatorRe_);
    for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (goog.i18n.bidi.startsWithRtl(token)) {
            rtlCount++;
            totalCount++
        } else if (goog.i18n.bidi.isRequiredLtrRe_.test(token)) hasWeaklyLtr = true;
        else if (goog.i18n.bidi.hasAnyLtr(token)) totalCount++;
        else if (goog.i18n.bidi.hasNumeralsRe_.test(token)) hasWeaklyLtr =
            true
    }
    return totalCount == 0 ? hasWeaklyLtr ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : rtlCount / totalCount > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR
};
goog.i18n.bidi.detectRtlDirectionality = function(str, opt_isHtml) {
    return goog.i18n.bidi.estimateDirection(str, opt_isHtml) == goog.i18n.bidi.Dir.RTL
};
goog.i18n.bidi.setElementDirAndAlign = function(element, dir) {
    if (element) {
        var htmlElement = element;
        dir = goog.i18n.bidi.toDir(dir);
        if (dir) {
            htmlElement.style.textAlign = dir == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
            htmlElement.dir = dir == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr"
        }
    }
};
goog.i18n.bidi.setElementDirByTextDirectionality = function(element, text) {
    var htmlElement = element;
    switch (goog.i18n.bidi.estimateDirection(text)) {
        case goog.i18n.bidi.Dir.LTR:
            htmlElement.dir = "ltr";
            break;
        case goog.i18n.bidi.Dir.RTL:
            htmlElement.dir = "rtl";
            break;
        default:
            htmlElement.removeAttribute("dir")
    }
};
goog.i18n.bidi.DirectionalString = function() {};
goog.i18n.bidi.DirectionalString.prototype.implementsGoogI18nBidiDirectionalString;
goog.i18n.bidi.DirectionalString.prototype.getDirection;
goog.provide("goog.html.TrustedResourceUrl");
goog.require("goog.asserts");
goog.require("goog.i18n.bidi.Dir");
goog.require("goog.i18n.bidi.DirectionalString");
goog.require("goog.string.Const");
goog.require("goog.string.TypedString");
goog.html.TrustedResourceUrl = function() {
    this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = "";
    this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_
};
goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = true;
goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_
};
goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString = true;
goog.html.TrustedResourceUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR
};
goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(searchParams, opt_hashParams) {
    var url = goog.html.TrustedResourceUrl.unwrap(this);
    var parts = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(url);
    var urlBase = parts[1];
    var urlSearch = parts[2] || "";
    var urlHash = parts[3] || "";
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(urlBase + goog.html.TrustedResourceUrl.stringifyParams_("?", urlSearch, searchParams) + goog.html.TrustedResourceUrl.stringifyParams_("#",
        urlHash, opt_hashParams))
};
if (goog.DEBUG) goog.html.TrustedResourceUrl.prototype.toString = function() {
    return "TrustedResourceUrl{" + this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + "}"
};
goog.html.TrustedResourceUrl.unwrap = function(trustedResourceUrl) {
    if (trustedResourceUrl instanceof goog.html.TrustedResourceUrl && trustedResourceUrl.constructor === goog.html.TrustedResourceUrl && trustedResourceUrl.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) return trustedResourceUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
    else {
        goog.asserts.fail("expected object of type TrustedResourceUrl, got '" + trustedResourceUrl +
            "' of type " + goog.typeOf(trustedResourceUrl));
        return "type_error:TrustedResourceUrl"
    }
};
goog.html.TrustedResourceUrl.format = function(format, args) {
    var formatStr = goog.string.Const.unwrap(format);
    if (!goog.html.TrustedResourceUrl.BASE_URL_.test(formatStr)) throw new Error("Invalid TrustedResourceUrl format: " + formatStr);
    var result = formatStr.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(match, id) {
        if (!Object.prototype.hasOwnProperty.call(args, id)) throw new Error('Found marker, "' + id + '", in format string, "' + formatStr + '", but no valid label mapping found ' + "in args: " + JSON.stringify(args));
        var arg = args[id];
        if (arg instanceof goog.string.Const) return goog.string.Const.unwrap(arg);
        else return encodeURIComponent(String(arg))
    });
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(result)
};
goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g;
goog.html.TrustedResourceUrl.BASE_URL_ = new RegExp("^((https:)?//[0-9a-z.:[\\]-]+/" + "|/[^/\\\\]" + "|[^:/\\\\]+/" + "|[^:/\\\\]*[?#]" + "|about:blank#" + ")", "i");
goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ = /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
goog.html.TrustedResourceUrl.formatWithParams = function(format, args, searchParams, opt_hashParams) {
    var url = goog.html.TrustedResourceUrl.format(format, args);
    return url.cloneWithParams(searchParams, opt_hashParams)
};
goog.html.TrustedResourceUrl.fromConstant = function(url) {
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(url))
};
goog.html.TrustedResourceUrl.fromConstants = function(parts) {
    var unwrapped = "";
    for (var i = 0; i < parts.length; i++) unwrapped += goog.string.Const.unwrap(parts[i]);
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(unwrapped)
};
goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(url) {
    var trustedResourceUrl = new goog.html.TrustedResourceUrl;
    trustedResourceUrl.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = url;
    return trustedResourceUrl
};
goog.html.TrustedResourceUrl.stringifyParams_ = function(prefix, currentString, params) {
    if (params == null) return currentString;
    if (goog.isString(params)) return params ? prefix + encodeURIComponent(params) : "";
    for (var key in params) {
        var value = params[key];
        var outputValues = goog.isArray(value) ? value : [value];
        for (var i = 0; i < outputValues.length; i++) {
            var outputValue = outputValues[i];
            if (outputValue != null) {
                if (!currentString) currentString = prefix;
                currentString += (currentString.length > prefix.length ? "&" : "") + encodeURIComponent(key) +
                    "=" + encodeURIComponent(String(outputValue))
            }
        }
    }
    return currentString
};
goog.provide("goog.html.SafeUrl");
goog.require("goog.asserts");
goog.require("goog.fs.url");
goog.require("goog.html.TrustedResourceUrl");
goog.require("goog.i18n.bidi.Dir");
goog.require("goog.i18n.bidi.DirectionalString");
goog.require("goog.string");
goog.require("goog.string.Const");
goog.require("goog.string.TypedString");
goog.html.SafeUrl = function() {
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "";
    this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_
};
goog.html.SafeUrl.INNOCUOUS_STRING = "about:invalid#zClosurez";
goog.html.SafeUrl.prototype.implementsGoogStringTypedString = true;
goog.html.SafeUrl.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_
};
goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = true;
goog.html.SafeUrl.prototype.getDirection = function() {
    return goog.i18n.bidi.Dir.LTR
};
if (goog.DEBUG) goog.html.SafeUrl.prototype.toString = function() {
    return "SafeUrl{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}"
};
goog.html.SafeUrl.unwrap = function(safeUrl) {
    if (safeUrl instanceof goog.html.SafeUrl && safeUrl.constructor === goog.html.SafeUrl && safeUrl.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) return safeUrl.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
    else {
        goog.asserts.fail("expected object of type SafeUrl, got '" + safeUrl + "' of type " + goog.typeOf(safeUrl));
        return "type_error:SafeUrl"
    }
};
goog.html.SafeUrl.fromConstant = function(url) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(url))
};
goog.html.SAFE_MIME_TYPE_PATTERN_ = new RegExp("^(?:audio/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-wav|wav|webm)|" + "image/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|" + "text/csv|" + "video/(?:mpeg|mp4|ogg|webm|quicktime))$", "i");
goog.html.SafeUrl.fromBlob = function(blob) {
    var url = goog.html.SAFE_MIME_TYPE_PATTERN_.test(blob.type) ? goog.fs.url.createObjectUrl(blob) : goog.html.SafeUrl.INNOCUOUS_STRING;
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url)
};
goog.html.DATA_URL_PATTERN_ = /^data:([^;,]*);base64,[a-z0-9+\/]+=*$/i;
goog.html.SafeUrl.fromDataUrl = function(dataUrl) {
    var filteredDataUrl = dataUrl.replace(/(%0A|%0D)/g, "");
    var match = filteredDataUrl.match(goog.html.DATA_URL_PATTERN_);
    var valid = match && goog.html.SAFE_MIME_TYPE_PATTERN_.test(match[1]);
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(valid ? filteredDataUrl : goog.html.SafeUrl.INNOCUOUS_STRING)
};
goog.html.SafeUrl.fromTelUrl = function(telUrl) {
    if (!goog.string.caseInsensitiveStartsWith(telUrl, "tel:")) telUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(telUrl)
};
goog.html.SIP_URL_PATTERN_ = new RegExp("^sip[s]?:[+a-z0-9_.!$%&'*\\/=^`{|}~-]+@([a-z0-9-]+\\.)+[a-z0-9]{2,63}$", "i");
goog.html.SafeUrl.fromSipUrl = function(sipUrl) {
    if (!goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(sipUrl))) sipUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(sipUrl)
};
goog.html.SafeUrl.fromFacebookMessengerUrl = function(facebookMessengerUrl) {
    if (!goog.string.caseInsensitiveStartsWith(facebookMessengerUrl, "fb-messenger://share")) facebookMessengerUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(facebookMessengerUrl)
};
goog.html.SafeUrl.fromSmsUrl = function(smsUrl) {
    if (!goog.string.caseInsensitiveStartsWith(smsUrl, "sms:") || !goog.html.SafeUrl.isSmsUrlBodyValid_(smsUrl)) smsUrl = goog.html.SafeUrl.INNOCUOUS_STRING;
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(smsUrl)
};
goog.html.SafeUrl.isSmsUrlBodyValid_ = function(smsUrl) {
    var hash = smsUrl.indexOf("#");
    if (hash > 0) smsUrl = smsUrl.substring(0, hash);
    var bodyParams = smsUrl.match(/[?&]body=/gi);
    if (!bodyParams) return true;
    if (bodyParams.length > 1) return false;
    var bodyValue = smsUrl.match(/[?&]body=([^&]*)/)[1];
    if (!bodyValue) return true;
    try {
        decodeURIComponent(bodyValue)
    } catch (error) {
        return false
    }
    return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(bodyValue)
};
goog.html.SafeUrl.sanitizeChromeExtensionUrl = function(url, extensionId) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//, url, extensionId)
};
goog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(url, extensionId) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//, url, extensionId)
};
goog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(url, extensionId) {
    return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//, url, extensionId)
};
goog.html.SafeUrl.sanitizeExtensionUrl_ = function(scheme, url, extensionId) {
    var matches = scheme.exec(url);
    if (!matches) url = goog.html.SafeUrl.INNOCUOUS_STRING;
    else {
        var extractedExtensionId = matches[1];
        var acceptedExtensionIds;
        if (extensionId instanceof goog.string.Const) acceptedExtensionIds = [goog.string.Const.unwrap(extensionId)];
        else acceptedExtensionIds = extensionId.map(function unwrap(x) {
            return goog.string.Const.unwrap(x)
        });
        if (acceptedExtensionIds.indexOf(extractedExtensionId) == -1) url = goog.html.SafeUrl.INNOCUOUS_STRING
    }
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url)
};
goog.html.SafeUrl.fromTrustedResourceUrl = function(trustedResourceUrl) {
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(trustedResourceUrl))
};
goog.html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
goog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_;
goog.html.SafeUrl.sanitize = function(url) {
    if (url instanceof goog.html.SafeUrl) return url;
    else if (typeof url == "object" && url.implementsGoogStringTypedString) url = url.getTypedStringValue();
    else url = String(url);
    if (!goog.html.SAFE_URL_PATTERN_.test(url)) url = goog.html.SafeUrl.INNOCUOUS_STRING;
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url)
};
goog.html.SafeUrl.sanitizeAssertUnchanged = function(url) {
    if (url instanceof goog.html.SafeUrl) return url;
    else if (typeof url == "object" && url.implementsGoogStringTypedString) url = url.getTypedStringValue();
    else url = String(url);
    if (!goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(url), "%s does not match the safe URL pattern", url)) url = goog.html.SafeUrl.INNOCUOUS_STRING;
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url)
};
goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(url) {
    var safeUrl = new goog.html.SafeUrl;
    safeUrl.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = url;
    return safeUrl
};
goog.html.SafeUrl.ABOUT_BLANK = goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");
goog.provide("goog.html.SafeStyle");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.html.SafeUrl");
goog.require("goog.string");
goog.require("goog.string.Const");
goog.require("goog.string.TypedString");
goog.html.SafeStyle = function() {
    this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = "";
    this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_
};
goog.html.SafeStyle.prototype.implementsGoogStringTypedString = true;
goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeStyle.fromConstant = function(style) {
    var styleString = goog.string.Const.unwrap(style);
    if (styleString.length === 0) return goog.html.SafeStyle.EMPTY;
    goog.html.SafeStyle.checkStyle_(styleString);
    goog.asserts.assert(goog.string.endsWith(styleString, ";"), "Last character of style string is not ';': " + styleString);
    goog.asserts.assert(goog.string.contains(styleString, ":"), "Style string must contain at least one ':', to " + 'specify a "name: value" pair: ' + styleString);
    return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(styleString)
};
goog.html.SafeStyle.checkStyle_ = function(style) {
    goog.asserts.assert(!/[<>]/.test(style), "Forbidden characters in style string: " + style)
};
goog.html.SafeStyle.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleWrappedValue_
};
if (goog.DEBUG) goog.html.SafeStyle.prototype.toString = function() {
    return "SafeStyle{" + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ + "}"
};
goog.html.SafeStyle.unwrap = function(safeStyle) {
    if (safeStyle instanceof goog.html.SafeStyle && safeStyle.constructor === goog.html.SafeStyle && safeStyle.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) return safeStyle.privateDoNotAccessOrElseSafeStyleWrappedValue_;
    else {
        goog.asserts.fail("expected object of type SafeStyle, got '" + safeStyle + "' of type " + goog.typeOf(safeStyle));
        return "type_error:SafeStyle"
    }
};
goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function(style) {
    return (new goog.html.SafeStyle).initSecurityPrivateDoNotAccessOrElse_(style)
};
goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(style) {
    this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = style;
    return this
};
goog.html.SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");
goog.html.SafeStyle.INNOCUOUS_STRING = "zClosurez";
goog.html.SafeStyle.PropertyValue;
goog.html.SafeStyle.PropertyMap;
goog.html.SafeStyle.create = function(map) {
    var style = "";
    for (var name in map) {
        if (!/^[-_a-zA-Z0-9]+$/.test(name)) throw new Error("Name allows only [-_a-zA-Z0-9], got: " + name);
        var value = map[name];
        if (value == null) continue;
        if (goog.isArray(value)) value = goog.array.map(value, goog.html.SafeStyle.sanitizePropertyValue_).join(" ");
        else value = goog.html.SafeStyle.sanitizePropertyValue_(value);
        style += name + ":" + value + ";"
    }
    if (!style) return goog.html.SafeStyle.EMPTY;
    goog.html.SafeStyle.checkStyle_(style);
    return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style)
};
goog.html.SafeStyle.sanitizePropertyValue_ = function(value) {
    if (value instanceof goog.html.SafeUrl) {
        var url = goog.html.SafeUrl.unwrap(value);
        return 'url("' + url.replace(/</g, "%3c").replace(/[\\"]/g, "\\$&") + '")'
    }
    var result = value instanceof goog.string.Const ? goog.string.Const.unwrap(value) : goog.html.SafeStyle.sanitizePropertyValueString_(String(value));
    goog.asserts.assert(!/[{;}]/.test(result), "Value does not allow [{;}].");
    return result
};
goog.html.SafeStyle.sanitizePropertyValueString_ = function(value) {
    var valueWithoutFunctions = value.replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.URL_RE_, "url");
    if (!goog.html.SafeStyle.VALUE_RE_.test(valueWithoutFunctions)) {
        goog.asserts.fail("String value allows only " + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + " and simple functions, got: " + value);
        return goog.html.SafeStyle.INNOCUOUS_STRING
    } else if (goog.html.SafeStyle.COMMENT_RE_.test(value)) {
        goog.asserts.fail("String value disallows comments, got: " +
            value);
        return goog.html.SafeStyle.INNOCUOUS_STRING
    } else if (!goog.html.SafeStyle.hasBalancedQuotes_(value)) {
        goog.asserts.fail("String value requires balanced quotes, got: " + value);
        return goog.html.SafeStyle.INNOCUOUS_STRING
    } else if (!goog.html.SafeStyle.hasBalancedSquareBrackets_(value)) {
        goog.asserts.fail("String value requires balanced square brackets and one" + " identifier per pair of brackets, got: " + value);
        return goog.html.SafeStyle.INNOCUOUS_STRING
    }
    return goog.html.SafeStyle.sanitizeUrl_(value)
};
goog.html.SafeStyle.hasBalancedQuotes_ = function(value) {
    var outsideSingle = true;
    var outsideDouble = true;
    for (var i = 0; i < value.length; i++) {
        var c = value.charAt(i);
        if (c == "'" && outsideDouble) outsideSingle = !outsideSingle;
        else if (c == '"' && outsideSingle) outsideDouble = !outsideDouble
    }
    return outsideSingle && outsideDouble
};
goog.html.SafeStyle.hasBalancedSquareBrackets_ = function(value) {
    var outside = true;
    var tokenRe = /^[-_a-zA-Z0-9]$/;
    for (var i = 0; i < value.length; i++) {
        var c = value.charAt(i);
        if (c == "]") {
            if (outside) return false;
            outside = true
        } else if (c == "[") {
            if (!outside) return false;
            outside = false
        } else if (!outside && !tokenRe.test(c)) return false
    }
    return outside
};
goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ = "[-,.\"'%_!# a-zA-Z0-9\\[\\]]";
goog.html.SafeStyle.VALUE_RE_ = new RegExp("^" + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + "+$");
goog.html.SafeStyle.URL_RE_ = new RegExp("\\b(url\\([ \t\n]*)(" + "'[ -&(-\\[\\]-~]*'" + '|"[ !#-\\[\\]-~]*"' + "|[!#-&*-\\[\\]-~]*" + ")([ \t\n]*\\))", "g");
goog.html.SafeStyle.FUNCTIONS_RE_ = new RegExp("\\b(hsl|hsla|rgb|rgba|matrix|calc|minmax|fit-content|repeat|" + "(rotate|scale|translate)(X|Y|Z|3d)?)" + "\\([-+*/0-9a-z.%\\[\\], ]+\\)", "g");
goog.html.SafeStyle.COMMENT_RE_ = /\/\*/;
goog.html.SafeStyle.sanitizeUrl_ = function(value) {
    return value.replace(goog.html.SafeStyle.URL_RE_, function(match, before, url, after) {
        var quote = "";
        url = url.replace(/^(['"])(.*)\1$/, function(match, start, inside) {
            quote = start;
            return inside
        });
        var sanitized = goog.html.SafeUrl.sanitize(url).getTypedStringValue();
        return before + quote + sanitized + quote + after
    })
};
goog.html.SafeStyle.concat = function(var_args) {
    var style = "";
    var addArgument = function(argument) {
        if (goog.isArray(argument)) goog.array.forEach(argument, addArgument);
        else style += goog.html.SafeStyle.unwrap(argument)
    };
    goog.array.forEach(arguments, addArgument);
    if (!style) return goog.html.SafeStyle.EMPTY;
    return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style)
};
goog.provide("goog.html.SafeStyleSheet");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.html.SafeStyle");
goog.require("goog.object");
goog.require("goog.string");
goog.require("goog.string.Const");
goog.require("goog.string.TypedString");
goog.html.SafeStyleSheet = function() {
    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = "";
    this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_
};
goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString = true;
goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeStyleSheet.createRule = function(selector, style) {
    if (goog.string.contains(selector, "<")) throw new Error("Selector does not allow '<', got: " + selector);
    var selectorToCheck = selector.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, "");
    if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(selectorToCheck)) throw new Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and " + "strings, got: " + selector);
    if (!goog.html.SafeStyleSheet.hasBalancedBrackets_(selectorToCheck)) throw new Error("() and [] in selector must be balanced, got: " +
        selector);
    if (!(style instanceof goog.html.SafeStyle)) style = goog.html.SafeStyle.create(style);
    var styleSheet = selector + "{" + goog.html.SafeStyle.unwrap(style) + "}";
    return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet)
};
goog.html.SafeStyleSheet.hasBalancedBrackets_ = function(s) {
    var brackets = {
        "(": ")",
        "[": "]"
    };
    var expectedBrackets = [];
    for (var i = 0; i < s.length; i++) {
        var ch = s[i];
        if (brackets[ch]) expectedBrackets.push(brackets[ch]);
        else if (goog.object.contains(brackets, ch))
            if (expectedBrackets.pop() != ch) return false
    }
    return expectedBrackets.length == 0
};
goog.html.SafeStyleSheet.concat = function(var_args) {
    var result = "";
    var addArgument = function(argument) {
        if (goog.isArray(argument)) goog.array.forEach(argument, addArgument);
        else result += goog.html.SafeStyleSheet.unwrap(argument)
    };
    goog.array.forEach(arguments, addArgument);
    return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(result)
};
goog.html.SafeStyleSheet.fromConstant = function(styleSheet) {
    var styleSheetString = goog.string.Const.unwrap(styleSheet);
    if (styleSheetString.length === 0) return goog.html.SafeStyleSheet.EMPTY;
    goog.asserts.assert(!goog.string.contains(styleSheetString, "<"), "Forbidden '<' character in style sheet string: " + styleSheetString);
    return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheetString)
};
goog.html.SafeStyleSheet.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_
};
if (goog.DEBUG) goog.html.SafeStyleSheet.prototype.toString = function() {
    return "SafeStyleSheet{" + this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + "}"
};
goog.html.SafeStyleSheet.unwrap = function(safeStyleSheet) {
    if (safeStyleSheet instanceof goog.html.SafeStyleSheet && safeStyleSheet.constructor === goog.html.SafeStyleSheet && safeStyleSheet.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) return safeStyleSheet.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
    else {
        goog.asserts.fail("expected object of type SafeStyleSheet, got '" + safeStyleSheet + "' of type " + goog.typeOf(safeStyleSheet));
        return "type_error:SafeStyleSheet"
    }
};
goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function(styleSheet) {
    return (new goog.html.SafeStyleSheet).initSecurityPrivateDoNotAccessOrElse_(styleSheet)
};
goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(styleSheet) {
    this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = styleSheet;
    return this
};
goog.html.SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");
goog.provide("goog.html.SafeHtml");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.dom.TagName");
goog.require("goog.dom.tags");
goog.require("goog.html.SafeScript");
goog.require("goog.html.SafeStyle");
goog.require("goog.html.SafeStyleSheet");
goog.require("goog.html.SafeUrl");
goog.require("goog.html.TrustedResourceUrl");
goog.require("goog.i18n.bidi.Dir");
goog.require("goog.i18n.bidi.DirectionalString");
goog.require("goog.labs.userAgent.browser");
goog.require("goog.object");
goog.require("goog.string");
goog.require("goog.string.Const");
goog.require("goog.string.TypedString");
goog.html.SafeHtml = function() {
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "";
    this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
    this.dir_ = null
};
goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = true;
goog.html.SafeHtml.prototype.getDirection = function() {
    return this.dir_
};
goog.html.SafeHtml.prototype.implementsGoogStringTypedString = true;
goog.html.SafeHtml.prototype.getTypedStringValue = function() {
    return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_
};
if (goog.DEBUG) goog.html.SafeHtml.prototype.toString = function() {
    return "SafeHtml{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}"
};
goog.html.SafeHtml.unwrap = function(safeHtml) {
    if (safeHtml instanceof goog.html.SafeHtml && safeHtml.constructor === goog.html.SafeHtml && safeHtml.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_) return safeHtml.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
    else {
        goog.asserts.fail("expected object of type SafeHtml, got '" + safeHtml + "' of type " + goog.typeOf(safeHtml));
        return "type_error:SafeHtml"
    }
};
goog.html.SafeHtml.TextOrHtml_;
goog.html.SafeHtml.htmlEscape = function(textOrHtml) {
    if (textOrHtml instanceof goog.html.SafeHtml) return textOrHtml;
    var textIsObject = typeof textOrHtml == "object";
    var dir = null;
    if (textIsObject && textOrHtml.implementsGoogI18nBidiDirectionalString) dir = textOrHtml.getDirection();
    var textAsString;
    if (textIsObject && textOrHtml.implementsGoogStringTypedString) textAsString = textOrHtml.getTypedStringValue();
    else textAsString = String(textOrHtml);
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.htmlEscape(textAsString),
        dir)
};
goog.html.SafeHtml.htmlEscapePreservingNewlines = function(textOrHtml) {
    if (textOrHtml instanceof goog.html.SafeHtml) return textOrHtml;
    var html = goog.html.SafeHtml.htmlEscape(textOrHtml);
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.newLineToBr(goog.html.SafeHtml.unwrap(html)), html.getDirection())
};
goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function(textOrHtml) {
    if (textOrHtml instanceof goog.html.SafeHtml) return textOrHtml;
    var html = goog.html.SafeHtml.htmlEscape(textOrHtml);
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.whitespaceEscape(goog.html.SafeHtml.unwrap(html)), html.getDirection())
};
goog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape;
goog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/;
goog.html.SafeHtml.URL_ATTRIBUTES_ = goog.object.createSet("action", "cite", "data", "formaction", "href", "manifest", "poster", "src");
goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = goog.object.createSet(goog.dom.TagName.APPLET, goog.dom.TagName.BASE, goog.dom.TagName.EMBED, goog.dom.TagName.IFRAME, goog.dom.TagName.LINK, goog.dom.TagName.MATH, goog.dom.TagName.META, goog.dom.TagName.OBJECT, goog.dom.TagName.SCRIPT, goog.dom.TagName.STYLE, goog.dom.TagName.SVG, goog.dom.TagName.TEMPLATE);
goog.html.SafeHtml.AttributeValue;
goog.html.SafeHtml.create = function(tagName, opt_attributes, opt_content) {
    goog.html.SafeHtml.verifyTagName(String(tagName));
    return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(tagName), opt_attributes, opt_content)
};
goog.html.SafeHtml.verifyTagName = function(tagName) {
    if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(tagName)) throw new Error("Invalid tag name <" + tagName + ">.");
    if (tagName.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_) throw new Error("Tag name <" + tagName + "> is not allowed for SafeHtml.");
};
goog.html.SafeHtml.createIframe = function(opt_src, opt_srcdoc, opt_attributes, opt_content) {
    if (opt_src) goog.html.TrustedResourceUrl.unwrap(opt_src);
    var fixedAttributes = {};
    fixedAttributes["src"] = opt_src || null;
    fixedAttributes["srcdoc"] = opt_srcdoc && goog.html.SafeHtml.unwrap(opt_srcdoc);
    var defaultAttributes = {
        "sandbox": ""
    };
    var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, defaultAttributes, opt_attributes);
    return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe",
        attributes, opt_content)
};
goog.html.SafeHtml.createSandboxIframe = function(opt_src, opt_srcdoc, opt_attributes, opt_content) {
    if (!goog.html.SafeHtml.canUseSandboxIframe()) throw new Error("The browser does not support sandboxed iframes.");
    var fixedAttributes = {};
    if (opt_src) fixedAttributes["src"] = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(opt_src));
    else fixedAttributes["src"] = null;
    fixedAttributes["srcdoc"] = opt_srcdoc || null;
    fixedAttributes["sandbox"] = "";
    var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, {},
        opt_attributes);
    return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", attributes, opt_content)
};
goog.html.SafeHtml.canUseSandboxIframe = function() {
    return goog.global["HTMLIFrameElement"] && "sandbox" in goog.global["HTMLIFrameElement"].prototype
};
goog.html.SafeHtml.createScriptSrc = function(src, opt_attributes) {
    goog.html.TrustedResourceUrl.unwrap(src);
    var fixedAttributes = {
        "src": src
    };
    var defaultAttributes = {};
    var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, defaultAttributes, opt_attributes);
    return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", attributes)
};
goog.html.SafeHtml.createScript = function(script, opt_attributes) {
    for (var attr in opt_attributes) {
        var attrLower = attr.toLowerCase();
        if (attrLower == "language" || attrLower == "src" || attrLower == "text" || attrLower == "type") throw new Error('Cannot set "' + attrLower + '" attribute');
    }
    var content = "";
    script = goog.array.concat(script);
    for (var i = 0; i < script.length; i++) content += goog.html.SafeScript.unwrap(script[i]);
    var htmlContent = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content, goog.i18n.bidi.Dir.NEUTRAL);
    return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", opt_attributes, htmlContent)
};
goog.html.SafeHtml.createStyle = function(styleSheet, opt_attributes) {
    var fixedAttributes = {
        "type": "text/css"
    };
    var defaultAttributes = {};
    var attributes = goog.html.SafeHtml.combineAttributes(fixedAttributes, defaultAttributes, opt_attributes);
    var content = "";
    styleSheet = goog.array.concat(styleSheet);
    for (var i = 0; i < styleSheet.length; i++) content += goog.html.SafeStyleSheet.unwrap(styleSheet[i]);
    var htmlContent = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content, goog.i18n.bidi.Dir.NEUTRAL);
    return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style",
        attributes, htmlContent)
};
goog.html.SafeHtml.createMetaRefresh = function(url, opt_secs) {
    var unwrappedUrl = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(url));
    if (goog.labs.userAgent.browser.isIE() || goog.labs.userAgent.browser.isEdge())
        if (goog.string.contains(unwrappedUrl, ";")) unwrappedUrl = "'" + unwrappedUrl.replace(/'/g, "%27") + "'";
    var attributes = {
        "http-equiv": "refresh",
        "content": (opt_secs || 0) + "; url=" + unwrappedUrl
    };
    return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta", attributes)
};
goog.html.SafeHtml.getAttrNameAndValue_ = function(tagName, name, value) {
    if (value instanceof goog.string.Const) value = goog.string.Const.unwrap(value);
    else if (name.toLowerCase() == "style") value = goog.html.SafeHtml.getStyleValue_(value);
    else if (/^on/i.test(name)) throw new Error('Attribute "' + name + '" requires goog.string.Const value, "' + value + '" given.');
    else if (name.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_)
        if (value instanceof goog.html.TrustedResourceUrl) value = goog.html.TrustedResourceUrl.unwrap(value);
        else if (value instanceof goog.html.SafeUrl) value = goog.html.SafeUrl.unwrap(value);
    else if (goog.isString(value)) value = goog.html.SafeUrl.sanitize(value).getTypedStringValue();
    else throw new Error('Attribute "' + name + '" on tag "' + tagName + '" requires goog.html.SafeUrl, goog.string.Const, or string,' + ' value "' + value + '" given.');
    if (value.implementsGoogStringTypedString) value = value.getTypedStringValue();
    goog.asserts.assert(goog.isString(value) || goog.isNumber(value), "String or number value expected, got " +
        typeof value + " with value: " + value);
    return name + '="' + goog.string.htmlEscape(String(value)) + '"'
};
goog.html.SafeHtml.getStyleValue_ = function(value) {
    if (!goog.isObject(value)) throw new Error('The "style" attribute requires goog.html.SafeStyle or map ' + "of style properties, " + typeof value + " given: " + value);
    if (!(value instanceof goog.html.SafeStyle)) value = goog.html.SafeStyle.create(value);
    return goog.html.SafeStyle.unwrap(value)
};
goog.html.SafeHtml.createWithDir = function(dir, tagName, opt_attributes, opt_content) {
    var html = goog.html.SafeHtml.create(tagName, opt_attributes, opt_content);
    html.dir_ = dir;
    return html
};
goog.html.SafeHtml.concat = function(var_args) {
    var dir = goog.i18n.bidi.Dir.NEUTRAL;
    var content = "";
    var addArgument = function(argument) {
        if (goog.isArray(argument)) goog.array.forEach(argument, addArgument);
        else {
            var html = goog.html.SafeHtml.htmlEscape(argument);
            content += goog.html.SafeHtml.unwrap(html);
            var htmlDir = html.getDirection();
            if (dir == goog.i18n.bidi.Dir.NEUTRAL) dir = htmlDir;
            else if (htmlDir != goog.i18n.bidi.Dir.NEUTRAL && dir != htmlDir) dir = null
        }
    };
    goog.array.forEach(arguments, addArgument);
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(content,
        dir)
};
goog.html.SafeHtml.concatWithDir = function(dir, var_args) {
    var html = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
    html.dir_ = dir;
    return html
};
goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(html, dir) {
    return (new goog.html.SafeHtml).initSecurityPrivateDoNotAccessOrElse_(html, dir)
};
goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(html, dir) {
    this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = html;
    this.dir_ = dir;
    return this
};
goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function(tagName, opt_attributes, opt_content) {
    var dir = null;
    var result = "<" + tagName;
    result += goog.html.SafeHtml.stringifyAttributes(tagName, opt_attributes);
    var content = opt_content;
    if (!goog.isDefAndNotNull(content)) content = [];
    else if (!goog.isArray(content)) content = [content];
    if (goog.dom.tags.isVoidTag(tagName.toLowerCase())) {
        goog.asserts.assert(!content.length, "Void tag <" + tagName + "> does not allow content.");
        result += ">"
    } else {
        var html =
            goog.html.SafeHtml.concat(content);
        result += ">" + goog.html.SafeHtml.unwrap(html) + "</" + tagName + ">";
        dir = html.getDirection()
    }
    var dirAttribute = opt_attributes && opt_attributes["dir"];
    if (dirAttribute)
        if (/^(ltr|rtl|auto)$/i.test(dirAttribute)) dir = goog.i18n.bidi.Dir.NEUTRAL;
        else dir = null;
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(result, dir)
};
goog.html.SafeHtml.stringifyAttributes = function(tagName, opt_attributes) {
    var result = "";
    if (opt_attributes)
        for (var name in opt_attributes) {
            if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(name)) throw new Error('Invalid attribute name "' + name + '".');
            var value = opt_attributes[name];
            if (!goog.isDefAndNotNull(value)) continue;
            result += " " + goog.html.SafeHtml.getAttrNameAndValue_(tagName, name, value)
        }
    return result
};
goog.html.SafeHtml.combineAttributes = function(fixedAttributes, defaultAttributes, opt_attributes) {
    var combinedAttributes = {};
    var name;
    for (name in fixedAttributes) {
        goog.asserts.assert(name.toLowerCase() == name, "Must be lower case");
        combinedAttributes[name] = fixedAttributes[name]
    }
    for (name in defaultAttributes) {
        goog.asserts.assert(name.toLowerCase() == name, "Must be lower case");
        combinedAttributes[name] = defaultAttributes[name]
    }
    for (name in opt_attributes) {
        var nameLower = name.toLowerCase();
        if (nameLower in fixedAttributes) throw new Error('Cannot override "' +
            nameLower + '" attribute, got "' + name + '" with value "' + opt_attributes[name] + '"');
        if (nameLower in defaultAttributes) delete combinedAttributes[nameLower];
        combinedAttributes[name] = opt_attributes[name]
    }
    return combinedAttributes
};
goog.html.SafeHtml.DOCTYPE_HTML = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>", goog.i18n.bidi.Dir.NEUTRAL);
goog.html.SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("", goog.i18n.bidi.Dir.NEUTRAL);
goog.html.SafeHtml.BR = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>", goog.i18n.bidi.Dir.NEUTRAL);
goog.provide("goog.dom.safe");
goog.provide("goog.dom.safe.InsertAdjacentHtmlPosition");
goog.require("goog.asserts");
goog.require("goog.dom.asserts");
goog.require("goog.functions");
goog.require("goog.html.SafeHtml");
goog.require("goog.html.SafeScript");
goog.require("goog.html.SafeStyle");
goog.require("goog.html.SafeUrl");
goog.require("goog.html.TrustedResourceUrl");
goog.require("goog.string");
goog.require("goog.string.Const");
goog.dom.safe.InsertAdjacentHtmlPosition = {
    AFTERBEGIN: "afterbegin",
    AFTEREND: "afterend",
    BEFOREBEGIN: "beforebegin",
    BEFOREEND: "beforeend"
};
goog.dom.safe.insertAdjacentHtml = function(node, position, html) {
    node.insertAdjacentHTML(position, goog.html.SafeHtml.unwrap(html))
};
goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = {
    "MATH": true,
    "SCRIPT": true,
    "STYLE": true,
    "SVG": true,
    "TEMPLATE": true
};
goog.dom.safe.isInnerHtmlCleanupRecursive_ = goog.functions.cacheReturnValue(function() {
    if (goog.DEBUG && typeof document === "undefined") return false;
    var div = document.createElement("div");
    div.innerHTML = "<div><div></div></div>";
    if (goog.DEBUG && !div.firstChild) return false;
    var innerChild = div.firstChild.firstChild;
    div.innerHTML = "";
    return !innerChild.parentElement
});
goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(elem, html) {
    if (goog.dom.safe.isInnerHtmlCleanupRecursive_())
        while (elem.lastChild) elem.removeChild(elem.lastChild);
    elem.innerHTML = html
};
goog.dom.safe.setInnerHtml = function(elem, html) {
    if (goog.asserts.ENABLE_ASSERTS) {
        var tagName = elem.tagName.toUpperCase();
        if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[tagName]) throw new Error("goog.dom.safe.setInnerHtml cannot be used to set content of " + elem.tagName + ".");
    }
    goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(elem, goog.html.SafeHtml.unwrap(html))
};
goog.dom.safe.setOuterHtml = function(elem, html) {
    elem.outerHTML = goog.html.SafeHtml.unwrap(html)
};
goog.dom.safe.setFormElementAction = function(form, url) {
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    goog.dom.asserts.assertIsHTMLFormElement(form).action = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.setButtonFormAction = function(button, url) {
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    goog.dom.asserts.assertIsHTMLButtonElement(button).formAction = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.setInputFormAction = function(input, url) {
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    goog.dom.asserts.assertIsHTMLInputElement(input).formAction = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.setStyle = function(elem, style) {
    elem.style.cssText = goog.html.SafeStyle.unwrap(style)
};
goog.dom.safe.documentWrite = function(doc, html) {
    doc.write(goog.html.SafeHtml.unwrap(html))
};
goog.dom.safe.setAnchorHref = function(anchor, url) {
    goog.dom.asserts.assertIsHTMLAnchorElement(anchor);
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    anchor.href = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.setImageSrc = function(imageElement, url) {
    goog.dom.asserts.assertIsHTMLImageElement(imageElement);
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    imageElement.src = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.setAudioSrc = function(audioElement, url) {
    goog.dom.asserts.assertIsHTMLAudioElement(audioElement);
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    audioElement.src = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.setVideoSrc = function(videoElement, url) {
    goog.dom.asserts.assertIsHTMLVideoElement(videoElement);
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    videoElement.src = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.setEmbedSrc = function(embed, url) {
    goog.dom.asserts.assertIsHTMLEmbedElement(embed);
    embed.src = goog.html.TrustedResourceUrl.unwrap(url)
};
goog.dom.safe.setFrameSrc = function(frame, url) {
    goog.dom.asserts.assertIsHTMLFrameElement(frame);
    frame.src = goog.html.TrustedResourceUrl.unwrap(url)
};
goog.dom.safe.setIframeSrc = function(iframe, url) {
    goog.dom.asserts.assertIsHTMLIFrameElement(iframe);
    iframe.src = goog.html.TrustedResourceUrl.unwrap(url)
};
goog.dom.safe.setIframeSrcdoc = function(iframe, html) {
    goog.dom.asserts.assertIsHTMLIFrameElement(iframe);
    iframe.srcdoc = goog.html.SafeHtml.unwrap(html)
};
goog.dom.safe.setLinkHrefAndRel = function(link, url, rel) {
    goog.dom.asserts.assertIsHTMLLinkElement(link);
    link.rel = rel;
    if (goog.string.caseInsensitiveContains(rel, "stylesheet")) {
        goog.asserts.assert(url instanceof goog.html.TrustedResourceUrl, 'URL must be TrustedResourceUrl because "rel" contains "stylesheet"');
        link.href = goog.html.TrustedResourceUrl.unwrap(url)
    } else if (url instanceof goog.html.TrustedResourceUrl) link.href = goog.html.TrustedResourceUrl.unwrap(url);
    else if (url instanceof goog.html.SafeUrl) link.href =
        goog.html.SafeUrl.unwrap(url);
    else link.href = goog.html.SafeUrl.sanitizeAssertUnchanged(url).getTypedStringValue()
};
goog.dom.safe.setObjectData = function(object, url) {
    goog.dom.asserts.assertIsHTMLObjectElement(object);
    object.data = goog.html.TrustedResourceUrl.unwrap(url)
};
goog.dom.safe.setScriptSrc = function(script, url) {
    goog.dom.asserts.assertIsHTMLScriptElement(script);
    script.src = goog.html.TrustedResourceUrl.unwrap(url);
    var nonce = goog.getScriptNonce();
    if (nonce) script.setAttribute("nonce", nonce)
};
goog.dom.safe.setScriptContent = function(script, content) {
    goog.dom.asserts.assertIsHTMLScriptElement(script);
    script.text = goog.html.SafeScript.unwrap(content);
    var nonce = goog.getScriptNonce();
    if (nonce) script.setAttribute("nonce", nonce)
};
goog.dom.safe.setLocationHref = function(loc, url) {
    goog.dom.asserts.assertIsLocation(loc);
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    loc.href = goog.html.SafeUrl.unwrap(safeUrl)
};
goog.dom.safe.assignLocation = function(loc, url) {
    goog.dom.asserts.assertIsLocation(loc);
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    loc.assign(goog.html.SafeUrl.unwrap(safeUrl))
};
goog.dom.safe.replaceLocation = function(loc, url) {
    goog.dom.asserts.assertIsLocation(loc);
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    loc.replace(goog.html.SafeUrl.unwrap(safeUrl))
};
goog.dom.safe.openInWindow = function(url, opt_openerWin, opt_name, opt_specs, opt_replace) {
    var safeUrl;
    if (url instanceof goog.html.SafeUrl) safeUrl = url;
    else safeUrl = goog.html.SafeUrl.sanitizeAssertUnchanged(url);
    var win = opt_openerWin || window;
    return win.open(goog.html.SafeUrl.unwrap(safeUrl), opt_name ? goog.string.Const.unwrap(opt_name) : "", opt_specs, opt_replace)
};
goog.provide("goog.html.uncheckedconversions");
goog.require("goog.asserts");
goog.require("goog.html.SafeHtml");
goog.require("goog.html.SafeScript");
goog.require("goog.html.SafeStyle");
goog.require("goog.html.SafeStyleSheet");
goog.require("goog.html.SafeUrl");
goog.require("goog.html.TrustedResourceUrl");
goog.require("goog.string");
goog.require("goog.string.Const");
goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = function(justification, html, opt_dir) {
    goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
    goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
    return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(html, opt_dir || null)
};
goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = function(justification, script) {
    goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
    goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
    return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(script)
};
goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = function(justification, style) {
    goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
    goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
    return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(style)
};
goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = function(justification, styleSheet) {
    goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
    goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
    return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(styleSheet)
};
goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = function(justification, url) {
    goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
    goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
    return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(url)
};
goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(justification, url) {
    goog.asserts.assertString(goog.string.Const.unwrap(justification), "must provide justification");
    goog.asserts.assert(!goog.string.isEmptyOrWhitespace(goog.string.Const.unwrap(justification)), "must provide non-empty justification");
    return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(url)
};
goog.provide("goog.math.Size");
goog.math.Size = function(width, height) {
    this.width = width;
    this.height = height
};
goog.math.Size.equals = function(a, b) {
    if (a == b) return true;
    if (!a || !b) return false;
    return a.width == b.width && a.height == b.height
};
goog.math.Size.prototype.clone = function() {
    return new goog.math.Size(this.width, this.height)
};
if (goog.DEBUG) goog.math.Size.prototype.toString = function() {
    return "(" + this.width + " x " + this.height + ")"
};
goog.math.Size.prototype.getLongest = function() {
    return Math.max(this.width, this.height)
};
goog.math.Size.prototype.getShortest = function() {
    return Math.min(this.width, this.height)
};
goog.math.Size.prototype.area = function() {
    return this.width * this.height
};
goog.math.Size.prototype.perimeter = function() {
    return (this.width + this.height) * 2
};
goog.math.Size.prototype.aspectRatio = function() {
    return this.width / this.height
};
goog.math.Size.prototype.isEmpty = function() {
    return !this.area()
};
goog.math.Size.prototype.ceil = function() {
    this.width = Math.ceil(this.width);
    this.height = Math.ceil(this.height);
    return this
};
goog.math.Size.prototype.fitsInside = function(target) {
    return this.width <= target.width && this.height <= target.height
};
goog.math.Size.prototype.floor = function() {
    this.width = Math.floor(this.width);
    this.height = Math.floor(this.height);
    return this
};
goog.math.Size.prototype.round = function() {
    this.width = Math.round(this.width);
    this.height = Math.round(this.height);
    return this
};
goog.math.Size.prototype.scale = function(sx, opt_sy) {
    var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
    this.width *= sx;
    this.height *= sy;
    return this
};
goog.math.Size.prototype.scaleToCover = function(target) {
    var s = this.aspectRatio() <= target.aspectRatio() ? target.width / this.width : target.height / this.height;
    return this.scale(s)
};
goog.math.Size.prototype.scaleToFit = function(target) {
    var s = this.aspectRatio() > target.aspectRatio() ? target.width / this.width : target.height / this.height;
    return this.scale(s)
};
goog.provide("goog.dom");
goog.provide("goog.dom.Appendable");
goog.provide("goog.dom.DomHelper");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.dom.BrowserFeature");
goog.require("goog.dom.NodeType");
goog.require("goog.dom.TagName");
goog.require("goog.dom.safe");
goog.require("goog.html.SafeHtml");
goog.require("goog.html.uncheckedconversions");
goog.require("goog.math.Coordinate");
goog.require("goog.math.Size");
goog.require("goog.object");
goog.require("goog.string");
goog.require("goog.string.Unicode");
goog.require("goog.userAgent");
goog.define("goog.dom.ASSUME_QUIRKS_MODE", false);
goog.define("goog.dom.ASSUME_STANDARDS_MODE", false);
goog.dom.COMPAT_MODE_KNOWN_ = goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;
goog.dom.getDomHelper = function(opt_element) {
    return opt_element ? new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) : goog.dom.defaultDomHelper_ || (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper)
};
goog.dom.defaultDomHelper_;
goog.dom.getDocument = function() {
    return document
};
goog.dom.getElement = function(element) {
    return goog.dom.getElementHelper_(document, element)
};
goog.dom.getElementHelper_ = function(doc, element) {
    return goog.isString(element) ? doc.getElementById(element) : element
};
goog.dom.getRequiredElement = function(id) {
    return goog.dom.getRequiredElementHelper_(document, id)
};
goog.dom.getRequiredElementHelper_ = function(doc, id) {
    goog.asserts.assertString(id);
    var element = goog.dom.getElementHelper_(doc, id);
    element = goog.asserts.assertElement(element, "No element found with id: " + id);
    return element
};
goog.dom.$ = goog.dom.getElement;
goog.dom.getElementsByTagName = function(tagName, opt_parent) {
    var parent = opt_parent || document;
    return parent.getElementsByTagName(String(tagName))
};
goog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
    return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class, opt_el)
};
goog.dom.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
    return goog.dom.getElementByTagNameAndClass_(document, opt_tag, opt_class, opt_el)
};
goog.dom.getElementsByClass = function(className, opt_el) {
    var parent = opt_el || document;
    if (goog.dom.canUseQuerySelector_(parent)) return parent.querySelectorAll("." + className);
    return goog.dom.getElementsByTagNameAndClass_(document, "*", className, opt_el)
};
goog.dom.getElementByClass = function(className, opt_el) {
    var parent = opt_el || document;
    var retVal = null;
    if (parent.getElementsByClassName) retVal = parent.getElementsByClassName(className)[0];
    else retVal = goog.dom.getElementByTagNameAndClass_(document, "*", className, opt_el);
    return retVal || null
};
goog.dom.getRequiredElementByClass = function(className, opt_root) {
    var retValue = goog.dom.getElementByClass(className, opt_root);
    return goog.asserts.assert(retValue, "No element found with className: " + className)
};
goog.dom.canUseQuerySelector_ = function(parent) {
    return !!(parent.querySelectorAll && parent.querySelector)
};
goog.dom.getElementsByTagNameAndClass_ = function(doc, opt_tag, opt_class, opt_el) {
    var parent = opt_el || doc;
    var tagName = opt_tag && opt_tag != "*" ? String(opt_tag).toUpperCase() : "";
    if (goog.dom.canUseQuerySelector_(parent) && (tagName || opt_class)) {
        var query = tagName + (opt_class ? "." + opt_class : "");
        return parent.querySelectorAll(query)
    }
    if (opt_class && parent.getElementsByClassName) {
        var els = parent.getElementsByClassName(opt_class);
        if (tagName) {
            var arrayLike = {};
            var len = 0;
            for (var i = 0, el; el = els[i]; i++)
                if (tagName == el.nodeName) arrayLike[len++] =
                    el;
            arrayLike.length = len;
            return arrayLike
        } else return els
    }
    var els = parent.getElementsByTagName(tagName || "*");
    if (opt_class) {
        var arrayLike = {};
        var len = 0;
        for (var i = 0, el; el = els[i]; i++) {
            var className = el.className;
            if (typeof className.split == "function" && goog.array.contains(className.split(/\s+/), opt_class)) arrayLike[len++] = el
        }
        arrayLike.length = len;
        return arrayLike
    } else return els
};
goog.dom.getElementByTagNameAndClass_ = function(doc, opt_tag, opt_class, opt_el) {
    var parent = opt_el || doc;
    var tag = opt_tag && opt_tag != "*" ? String(opt_tag).toUpperCase() : "";
    if (goog.dom.canUseQuerySelector_(parent) && (tag || opt_class)) return parent.querySelector(tag + (opt_class ? "." + opt_class : ""));
    var elements = goog.dom.getElementsByTagNameAndClass_(doc, opt_tag, opt_class, opt_el);
    return elements[0] || null
};
goog.dom.$$ = goog.dom.getElementsByTagNameAndClass;
goog.dom.setProperties = function(element, properties) {
    goog.object.forEach(properties, function(val, key) {
        if (val && typeof val == "object" && val.implementsGoogStringTypedString) val = val.getTypedStringValue();
        if (key == "style") element.style.cssText = val;
        else if (key == "class") element.className = val;
        else if (key == "for") element.htmlFor = val;
        else if (goog.dom.DIRECT_ATTRIBUTE_MAP_.hasOwnProperty(key)) element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
        else if (goog.string.startsWith(key, "aria-") || goog.string.startsWith(key,
                "data-")) element.setAttribute(key, val);
        else element[key] = val
    })
};
goog.dom.DIRECT_ATTRIBUTE_MAP_ = {
    "cellpadding": "cellPadding",
    "cellspacing": "cellSpacing",
    "colspan": "colSpan",
    "frameborder": "frameBorder",
    "height": "height",
    "maxlength": "maxLength",
    "nonce": "nonce",
    "role": "role",
    "rowspan": "rowSpan",
    "type": "type",
    "usemap": "useMap",
    "valign": "vAlign",
    "width": "width"
};
goog.dom.getViewportSize = function(opt_window) {
    return goog.dom.getViewportSize_(opt_window || window)
};
goog.dom.getViewportSize_ = function(win) {
    var doc = win.document;
    var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;
    return new goog.math.Size(el.clientWidth, el.clientHeight)
};
goog.dom.getDocumentHeight = function() {
    return goog.dom.getDocumentHeight_(window)
};
goog.dom.getDocumentHeightForWindow = function(win) {
    return goog.dom.getDocumentHeight_(win)
};
goog.dom.getDocumentHeight_ = function(win) {
    var doc = win.document;
    var height = 0;
    if (doc) {
        var body = doc.body;
        var docEl = doc.documentElement;
        if (!(docEl && body)) return 0;
        var vh = goog.dom.getViewportSize_(win).height;
        if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) height = docEl.scrollHeight != vh ? docEl.scrollHeight : docEl.offsetHeight;
        else {
            var sh = docEl.scrollHeight;
            var oh = docEl.offsetHeight;
            if (docEl.clientHeight != oh) {
                sh = body.scrollHeight;
                oh = body.offsetHeight
            }
            if (sh > vh) height = sh > oh ? sh : oh;
            else height = sh < oh ? sh :
                oh
        }
    }
    return height
};
goog.dom.getPageScroll = function(opt_window) {
    var win = opt_window || goog.global || window;
    return goog.dom.getDomHelper(win.document).getDocumentScroll()
};
goog.dom.getDocumentScroll = function() {
    return goog.dom.getDocumentScroll_(document)
};
goog.dom.getDocumentScroll_ = function(doc) {
    var el = goog.dom.getDocumentScrollElement_(doc);
    var win = goog.dom.getWindow_(doc);
    if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher("10") && win.pageYOffset != el.scrollTop) return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);
    return new goog.math.Coordinate(win.pageXOffset || el.scrollLeft, win.pageYOffset || el.scrollTop)
};
goog.dom.getDocumentScrollElement = function() {
    return goog.dom.getDocumentScrollElement_(document)
};
goog.dom.getDocumentScrollElement_ = function(doc) {
    if (doc.scrollingElement) return doc.scrollingElement;
    if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) return doc.documentElement;
    return doc.body || doc.documentElement
};
goog.dom.getWindow = function(opt_doc) {
    return opt_doc ? goog.dom.getWindow_(opt_doc) : window
};
goog.dom.getWindow_ = function(doc) {
    return doc.parentWindow || doc.defaultView
};
goog.dom.createDom = function(tagName, opt_attributes, var_args) {
    return goog.dom.createDom_(document, arguments)
};
goog.dom.createDom_ = function(doc, args) {
    var tagName = String(args[0]);
    var attributes = args[1];
    if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes && (attributes.name || attributes.type)) {
        var tagNameArr = ["<", tagName];
        if (attributes.name) tagNameArr.push(' name="', goog.string.htmlEscape(attributes.name), '"');
        if (attributes.type) {
            tagNameArr.push(' type="', goog.string.htmlEscape(attributes.type), '"');
            var clone = {};
            goog.object.extend(clone, attributes);
            delete clone["type"];
            attributes = clone
        }
        tagNameArr.push(">");
        tagName = tagNameArr.join("")
    }
    var element = doc.createElement(tagName);
    if (attributes)
        if (goog.isString(attributes)) element.className = attributes;
        else if (goog.isArray(attributes)) element.className = attributes.join(" ");
    else goog.dom.setProperties(element, attributes);
    if (args.length > 2) goog.dom.append_(doc, element, args, 2);
    return element
};
goog.dom.append_ = function(doc, parent, args, startIndex) {
    function childHandler(child) {
        if (child) parent.appendChild(goog.isString(child) ? doc.createTextNode(child) : child)
    }
    for (var i = startIndex; i < args.length; i++) {
        var arg = args[i];
        if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) goog.array.forEach(goog.dom.isNodeList(arg) ? goog.array.toArray(arg) : arg, childHandler);
        else childHandler(arg)
    }
};
goog.dom.$dom = goog.dom.createDom;
goog.dom.createElement = function(name) {
    return goog.dom.createElement_(document, name)
};
goog.dom.createElement_ = function(doc, name) {
    return doc.createElement(String(name))
};
goog.dom.createTextNode = function(content) {
    return document.createTextNode(String(content))
};
goog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {
    return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp)
};
goog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {
    var table = goog.dom.createElement_(doc, goog.dom.TagName.TABLE);
    var tbody = table.appendChild(goog.dom.createElement_(doc, goog.dom.TagName.TBODY));
    for (var i = 0; i < rows; i++) {
        var tr = goog.dom.createElement_(doc, goog.dom.TagName.TR);
        for (var j = 0; j < columns; j++) {
            var td = goog.dom.createElement_(doc, goog.dom.TagName.TD);
            if (fillWithNbsp) goog.dom.setTextContent(td, goog.string.Unicode.NBSP);
            tr.appendChild(td)
        }
        tbody.appendChild(tr)
    }
    return table
};
goog.dom.constHtmlToNode = function(var_args) {
    var stringArray = goog.array.map(arguments, goog.string.Const.unwrap);
    var safeHtml = goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Constant HTML string, that gets turned into a " + "Node later, so it will be automatically balanced."), stringArray.join(""));
    return goog.dom.safeHtmlToNode(safeHtml)
};
goog.dom.safeHtmlToNode = function(html) {
    return goog.dom.safeHtmlToNode_(document, html)
};
goog.dom.safeHtmlToNode_ = function(doc, html) {
    var tempDiv = goog.dom.createElement_(doc, goog.dom.TagName.DIV);
    if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {
        goog.dom.safe.setInnerHtml(tempDiv, goog.html.SafeHtml.concat(goog.html.SafeHtml.BR, html));
        tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild))
    } else goog.dom.safe.setInnerHtml(tempDiv, html);
    return goog.dom.childrenToNode_(doc, tempDiv)
};
goog.dom.childrenToNode_ = function(doc, tempDiv) {
    if (tempDiv.childNodes.length == 1) return tempDiv.removeChild(goog.asserts.assert(tempDiv.firstChild));
    else {
        var fragment = doc.createDocumentFragment();
        while (tempDiv.firstChild) fragment.appendChild(tempDiv.firstChild);
        return fragment
    }
};
goog.dom.isCss1CompatMode = function() {
    return goog.dom.isCss1CompatMode_(document)
};
goog.dom.isCss1CompatMode_ = function(doc) {
    if (goog.dom.COMPAT_MODE_KNOWN_) return goog.dom.ASSUME_STANDARDS_MODE;
    return doc.compatMode == "CSS1Compat"
};
goog.dom.canHaveChildren = function(node) {
    if (node.nodeType != goog.dom.NodeType.ELEMENT) return false;
    switch (node.tagName) {
        case String(goog.dom.TagName.APPLET):
        case String(goog.dom.TagName.AREA):
        case String(goog.dom.TagName.BASE):
        case String(goog.dom.TagName.BR):
        case String(goog.dom.TagName.COL):
        case String(goog.dom.TagName.COMMAND):
        case String(goog.dom.TagName.EMBED):
        case String(goog.dom.TagName.FRAME):
        case String(goog.dom.TagName.HR):
        case String(goog.dom.TagName.IMG):
        case String(goog.dom.TagName.INPUT):
        case String(goog.dom.TagName.IFRAME):
        case String(goog.dom.TagName.ISINDEX):
        case String(goog.dom.TagName.KEYGEN):
        case String(goog.dom.TagName.LINK):
        case String(goog.dom.TagName.NOFRAMES):
        case String(goog.dom.TagName.NOSCRIPT):
        case String(goog.dom.TagName.META):
        case String(goog.dom.TagName.OBJECT):
        case String(goog.dom.TagName.PARAM):
        case String(goog.dom.TagName.SCRIPT):
        case String(goog.dom.TagName.SOURCE):
        case String(goog.dom.TagName.STYLE):
        case String(goog.dom.TagName.TRACK):
        case String(goog.dom.TagName.WBR):
            return false
    }
    return true
};
goog.dom.appendChild = function(parent, child) {
    goog.asserts.assert(parent != null && child != null, "goog.dom.appendChild expects non-null arguments");
    parent.appendChild(child)
};
goog.dom.append = function(parent, var_args) {
    goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1)
};
goog.dom.removeChildren = function(node) {
    var child;
    while (child = node.firstChild) node.removeChild(child)
};
goog.dom.insertSiblingBefore = function(newNode, refNode) {
    goog.asserts.assert(newNode != null && refNode != null, "goog.dom.insertSiblingBefore expects non-null arguments");
    if (refNode.parentNode) refNode.parentNode.insertBefore(newNode, refNode)
};
goog.dom.insertSiblingAfter = function(newNode, refNode) {
    goog.asserts.assert(newNode != null && refNode != null, "goog.dom.insertSiblingAfter expects non-null arguments");
    if (refNode.parentNode) refNode.parentNode.insertBefore(newNode, refNode.nextSibling)
};
goog.dom.insertChildAt = function(parent, child, index) {
    goog.asserts.assert(parent != null, "goog.dom.insertChildAt expects a non-null parent");
    parent.insertBefore(child, parent.childNodes[index] || null)
};
goog.dom.removeNode = function(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null
};
goog.dom.replaceNode = function(newNode, oldNode) {
    goog.asserts.assert(newNode != null && oldNode != null, "goog.dom.replaceNode expects non-null arguments");
    var parent = oldNode.parentNode;
    if (parent) parent.replaceChild(newNode, oldNode)
};
goog.dom.flattenElement = function(element) {
    var child, parent = element.parentNode;
    if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT)
        if (element.removeNode) return element.removeNode(false);
        else {
            while (child = element.firstChild) parent.insertBefore(child, element);
            return goog.dom.removeNode(element)
        }
};
goog.dom.getChildren = function(element) {
    if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE && element.children != undefined) return element.children;
    return goog.array.filter(element.childNodes, function(node) {
        return node.nodeType == goog.dom.NodeType.ELEMENT
    })
};
goog.dom.getFirstElementChild = function(node) {
    if (goog.isDef(node.firstElementChild)) return node.firstElementChild;
    return goog.dom.getNextElementNode_(node.firstChild, true)
};
goog.dom.getLastElementChild = function(node) {
    if (goog.isDef(node.lastElementChild)) return node.lastElementChild;
    return goog.dom.getNextElementNode_(node.lastChild, false)
};
goog.dom.getNextElementSibling = function(node) {
    if (goog.isDef(node.nextElementSibling)) return node.nextElementSibling;
    return goog.dom.getNextElementNode_(node.nextSibling, true)
};
goog.dom.getPreviousElementSibling = function(node) {
    if (goog.isDef(node.previousElementSibling)) return node.previousElementSibling;
    return goog.dom.getNextElementNode_(node.previousSibling, false)
};
goog.dom.getNextElementNode_ = function(node, forward) {
    while (node && node.nodeType != goog.dom.NodeType.ELEMENT) node = forward ? node.nextSibling : node.previousSibling;
    return node
};
goog.dom.getNextNode = function(node) {
    if (!node) return null;
    if (node.firstChild) return node.firstChild;
    while (node && !node.nextSibling) node = node.parentNode;
    return node ? node.nextSibling : null
};
goog.dom.getPreviousNode = function(node) {
    if (!node) return null;
    if (!node.previousSibling) return node.parentNode;
    node = node.previousSibling;
    while (node && node.lastChild) node = node.lastChild;
    return node
};
goog.dom.isNodeLike = function(obj) {
    return goog.isObject(obj) && obj.nodeType > 0
};
goog.dom.isElement = function(obj) {
    return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT
};
goog.dom.isWindow = function(obj) {
    return goog.isObject(obj) && obj["window"] == obj
};
goog.dom.getParentElement = function(element) {
    var parent;
    if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {
        var isIe9 = goog.userAgent.IE && goog.userAgent.isVersionOrHigher("9") && !goog.userAgent.isVersionOrHigher("10");
        if (!(isIe9 && goog.global["SVGElement"] && element instanceof goog.global["SVGElement"])) {
            parent = element.parentElement;
            if (parent) return parent
        }
    }
    parent = element.parentNode;
    return goog.dom.isElement(parent) ? parent : null
};
goog.dom.contains = function(parent, descendant) {
    if (!parent || !descendant) return false;
    if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) return parent == descendant || parent.contains(descendant);
    if (typeof parent.compareDocumentPosition != "undefined") return parent == descendant || Boolean(parent.compareDocumentPosition(descendant) & 16);
    while (descendant && parent != descendant) descendant = descendant.parentNode;
    return descendant == parent
};
goog.dom.compareNodeOrder = function(node1, node2) {
    if (node1 == node2) return 0;
    if (node1.compareDocumentPosition) return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
    if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
        if (node1.nodeType == goog.dom.NodeType.DOCUMENT) return -1;
        if (node2.nodeType == goog.dom.NodeType.DOCUMENT) return 1
    }
    if ("sourceIndex" in node1 || node1.parentNode && "sourceIndex" in node1.parentNode) {
        var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
        var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;
        if (isElement1 && isElement2) return node1.sourceIndex - node2.sourceIndex;
        else {
            var parent1 = node1.parentNode;
            var parent2 = node2.parentNode;
            if (parent1 == parent2) return goog.dom.compareSiblingOrder_(node1, node2);
            if (!isElement1 && goog.dom.contains(parent1, node2)) return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
            if (!isElement2 && goog.dom.contains(parent2, node1)) return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
            return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) - (isElement2 ? node2.sourceIndex :
                parent2.sourceIndex)
        }
    }
    var doc = goog.dom.getOwnerDocument(node1);
    var range1, range2;
    range1 = doc.createRange();
    range1.selectNode(node1);
    range1.collapse(true);
    range2 = doc.createRange();
    range2.selectNode(node2);
    range2.collapse(true);
    return range1.compareBoundaryPoints(goog.global["Range"].START_TO_END, range2)
};
goog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {
    var parent = textNode.parentNode;
    if (parent == node) return -1;
    var sibling = node;
    while (sibling.parentNode != parent) sibling = sibling.parentNode;
    return goog.dom.compareSiblingOrder_(sibling, textNode)
};
goog.dom.compareSiblingOrder_ = function(node1, node2) {
    var s = node2;
    while (s = s.previousSibling)
        if (s == node1) return -1;
    return 1
};
goog.dom.findCommonAncestor = function(var_args) {
    var i, count = arguments.length;
    if (!count) return null;
    else if (count == 1) return arguments[0];
    var paths = [];
    var minLength = Infinity;
    for (i = 0; i < count; i++) {
        var ancestors = [];
        var node = arguments[i];
        while (node) {
            ancestors.unshift(node);
            node = node.parentNode
        }
        paths.push(ancestors);
        minLength = Math.min(minLength, ancestors.length)
    }
    var output = null;
    for (i = 0; i < minLength; i++) {
        var first = paths[0][i];
        for (var j = 1; j < count; j++)
            if (first != paths[j][i]) return output;
        output = first
    }
    return output
};
goog.dom.getOwnerDocument = function(node) {
    goog.asserts.assert(node, "Node cannot be null or undefined.");
    return node.nodeType == goog.dom.NodeType.DOCUMENT ? node : node.ownerDocument || node.document
};
goog.dom.getFrameContentDocument = function(frame) {
    return frame.contentDocument || frame.contentWindow.document
};
goog.dom.getFrameContentWindow = function(frame) {
    try {
        return frame.contentWindow || (frame.contentDocument ? goog.dom.getWindow(frame.contentDocument) : null)
    } catch (e) {}
    return null
};
goog.dom.setTextContent = function(node, text) {
    goog.asserts.assert(node != null, "goog.dom.setTextContent expects a non-null value for node");
    if ("textContent" in node) node.textContent = text;
    else if (node.nodeType == goog.dom.NodeType.TEXT) node.data = String(text);
    else if (node.firstChild && node.firstChild.nodeType == goog.dom.NodeType.TEXT) {
        while (node.lastChild != node.firstChild) node.removeChild(goog.asserts.assert(node.lastChild));
        node.firstChild.data = String(text)
    } else {
        goog.dom.removeChildren(node);
        var doc = goog.dom.getOwnerDocument(node);
        node.appendChild(doc.createTextNode(String(text)))
    }
};
goog.dom.getOuterHtml = function(element) {
    goog.asserts.assert(element !== null, "goog.dom.getOuterHtml expects a non-null value for element");
    if ("outerHTML" in element) return element.outerHTML;
    else {
        var doc = goog.dom.getOwnerDocument(element);
        var div = goog.dom.createElement_(doc, goog.dom.TagName.DIV);
        div.appendChild(element.cloneNode(true));
        return div.innerHTML
    }
};
goog.dom.findNode = function(root, p) {
    var rv = [];
    var found = goog.dom.findNodes_(root, p, rv, true);
    return found ? rv[0] : undefined
};
goog.dom.findNodes = function(root, p) {
    var rv = [];
    goog.dom.findNodes_(root, p, rv, false);
    return rv
};
goog.dom.findNodes_ = function(root, p, rv, findOne) {
    if (root != null) {
        var child = root.firstChild;
        while (child) {
            if (p(child)) {
                rv.push(child);
                if (findOne) return true
            }
            if (goog.dom.findNodes_(child, p, rv, findOne)) return true;
            child = child.nextSibling
        }
    }
    return false
};
goog.dom.TAGS_TO_IGNORE_ = {
    "SCRIPT": 1,
    "STYLE": 1,
    "HEAD": 1,
    "IFRAME": 1,
    "OBJECT": 1
};
goog.dom.PREDEFINED_TAG_VALUES_ = {
    "IMG": " ",
    "BR": "\n"
};
goog.dom.isFocusableTabIndex = function(element) {
    return goog.dom.hasSpecifiedTabIndex_(element) && goog.dom.isTabIndexFocusable_(element)
};
goog.dom.setFocusableTabIndex = function(element, enable) {
    if (enable) element.tabIndex = 0;
    else {
        element.tabIndex = -1;
        element.removeAttribute("tabIndex")
    }
};
goog.dom.isFocusable = function(element) {
    var focusable;
    if (goog.dom.nativelySupportsFocus_(element)) focusable = !element.disabled && (!goog.dom.hasSpecifiedTabIndex_(element) || goog.dom.isTabIndexFocusable_(element));
    else focusable = goog.dom.isFocusableTabIndex(element);
    return focusable && goog.userAgent.IE ? goog.dom.hasNonZeroBoundingRect_(element) : focusable
};
goog.dom.hasSpecifiedTabIndex_ = function(element) {
    if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("9")) {
        var attrNode = element.getAttributeNode("tabindex");
        return goog.isDefAndNotNull(attrNode) && attrNode.specified
    } else return element.hasAttribute("tabindex")
};
goog.dom.isTabIndexFocusable_ = function(element) {
    var index = element.tabIndex;
    return goog.isNumber(index) && index >= 0 && index < 32768
};
goog.dom.nativelySupportsFocus_ = function(element) {
    return element.tagName == goog.dom.TagName.A || element.tagName == goog.dom.TagName.INPUT || element.tagName == goog.dom.TagName.TEXTAREA || element.tagName == goog.dom.TagName.SELECT || element.tagName == goog.dom.TagName.BUTTON
};
goog.dom.hasNonZeroBoundingRect_ = function(element) {
    var rect;
    if (!goog.isFunction(element["getBoundingClientRect"]) || goog.userAgent.IE && element.parentElement == null) rect = {
        "height": element.offsetHeight,
        "width": element.offsetWidth
    };
    else rect = element.getBoundingClientRect();
    return goog.isDefAndNotNull(rect) && rect.height > 0 && rect.width > 0
};
goog.dom.getTextContent = function(node) {
    var textContent;
    if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && node !== null && "innerText" in node) textContent = goog.string.canonicalizeNewlines(node.innerText);
    else {
        var buf = [];
        goog.dom.getTextContent_(node, buf, true);
        textContent = buf.join("")
    }
    textContent = textContent.replace(/ \xAD /g, " ").replace(/\xAD/g, "");
    textContent = textContent.replace(/\u200B/g, "");
    if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) textContent = textContent.replace(/ +/g, " ");
    if (textContent != " ") textContent =
        textContent.replace(/^\s*/, "");
    return textContent
};
goog.dom.getRawTextContent = function(node) {
    var buf = [];
    goog.dom.getTextContent_(node, buf, false);
    return buf.join("")
};
goog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {
    if (node.nodeName in goog.dom.TAGS_TO_IGNORE_);
    else if (node.nodeType == goog.dom.NodeType.TEXT)
        if (normalizeWhitespace) buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ""));
        else buf.push(node.nodeValue);
    else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
    else {
        var child = node.firstChild;
        while (child) {
            goog.dom.getTextContent_(child, buf, normalizeWhitespace);
            child = child.nextSibling
        }
    }
};
goog.dom.getNodeTextLength = function(node) {
    return goog.dom.getTextContent(node).length
};
goog.dom.getNodeTextOffset = function(node, opt_offsetParent) {
    var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;
    var buf = [];
    while (node && node != root) {
        var cur = node;
        while (cur = cur.previousSibling) buf.unshift(goog.dom.getTextContent(cur));
        node = node.parentNode
    }
    return goog.string.trimLeft(buf.join("")).replace(/ +/g, " ").length
};
goog.dom.getNodeAtOffset = function(parent, offset, opt_result) {
    var stack = [parent],
        pos = 0,
        cur = null;
    while (stack.length > 0 && pos < offset) {
        cur = stack.pop();
        if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_);
        else if (cur.nodeType == goog.dom.NodeType.TEXT) {
            var text = cur.nodeValue.replace(/(\r\n|\r|\n)/g, "").replace(/ +/g, " ");
            pos += text.length
        } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;
        else
            for (var i = cur.childNodes.length - 1; i >= 0; i--) stack.push(cur.childNodes[i])
    }
    if (goog.isObject(opt_result)) {
        opt_result.remainder =
            cur ? cur.nodeValue.length + offset - pos - 1 : 0;
        opt_result.node = cur
    }
    return cur
};
goog.dom.isNodeList = function(val) {
    if (val && typeof val.length == "number")
        if (goog.isObject(val)) return typeof val.item == "function" || typeof val.item == "string";
        else if (goog.isFunction(val)) return typeof val.item == "function";
    return false
};
goog.dom.getAncestorByTagNameAndClass = function(element, opt_tag, opt_class, opt_maxSearchSteps) {
    if (!opt_tag && !opt_class) return null;
    var tagName = opt_tag ? String(opt_tag).toUpperCase() : null;
    return goog.dom.getAncestor(element, function(node) {
        return (!tagName || node.nodeName == tagName) && (!opt_class || goog.isString(node.className) && goog.array.contains(node.className.split(/\s+/), opt_class))
    }, true, opt_maxSearchSteps)
};
goog.dom.getAncestorByClass = function(element, className, opt_maxSearchSteps) {
    return goog.dom.getAncestorByTagNameAndClass(element, null, className, opt_maxSearchSteps)
};
goog.dom.getAncestor = function(element, matcher, opt_includeNode, opt_maxSearchSteps) {
    if (element && !opt_includeNode) element = element.parentNode;
    var steps = 0;
    while (element && (opt_maxSearchSteps == null || steps <= opt_maxSearchSteps)) {
        goog.asserts.assert(element.name != "parentNode");
        if (matcher(element)) return element;
        element = element.parentNode;
        steps++
    }
    return null
};
goog.dom.getActiveElement = function(doc) {
    try {
        var activeElement = doc && doc.activeElement;
        return activeElement && activeElement.nodeName ? activeElement : null
    } catch (e) {
        return null
    }
};
goog.dom.getPixelRatio = function() {
    var win = goog.dom.getWindow();
    if (goog.isDef(win.devicePixelRatio)) return win.devicePixelRatio;
    else if (win.matchMedia) return goog.dom.matchesPixelRatio_(3) || goog.dom.matchesPixelRatio_(2) || goog.dom.matchesPixelRatio_(1.5) || goog.dom.matchesPixelRatio_(1) || .75;
    return 1
};
goog.dom.matchesPixelRatio_ = function(pixelRatio) {
    var win = goog.dom.getWindow();
    var dpiPerDppx = 96;
    var query = "(min-resolution: " + pixelRatio + "dppx)," + "(min--moz-device-pixel-ratio: " + pixelRatio + ")," + "(min-resolution: " + pixelRatio * dpiPerDppx + "dpi)";
    return win.matchMedia(query).matches ? pixelRatio : 0
};
goog.dom.getCanvasContext2D = function(canvas) {
    return canvas.getContext("2d")
};
goog.dom.DomHelper = function(opt_document) {
    this.document_ = opt_document || goog.global.document || document
};
goog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;
goog.dom.DomHelper.prototype.setDocument = function(document) {
    this.document_ = document
};
goog.dom.DomHelper.prototype.getDocument = function() {
    return this.document_
};
goog.dom.DomHelper.prototype.getElement = function(element) {
    return goog.dom.getElementHelper_(this.document_, element)
};
goog.dom.DomHelper.prototype.getRequiredElement = function(id) {
    return goog.dom.getRequiredElementHelper_(this.document_, id)
};
goog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;
goog.dom.DomHelper.prototype.getElementsByTagName = function(tagName, opt_parent) {
    var parent = opt_parent || this.document_;
    return parent.getElementsByTagName(String(tagName))
};
goog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
    return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag, opt_class, opt_el)
};
goog.dom.DomHelper.prototype.getElementByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
    return goog.dom.getElementByTagNameAndClass_(this.document_, opt_tag, opt_class, opt_el)
};
goog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {
    var doc = opt_el || this.document_;
    return goog.dom.getElementsByClass(className, doc)
};
goog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {
    var doc = opt_el || this.document_;
    return goog.dom.getElementByClass(className, doc)
};
goog.dom.DomHelper.prototype.getRequiredElementByClass = function(className, opt_root) {
    var root = opt_root || this.document_;
    return goog.dom.getRequiredElementByClass(className, root)
};
goog.dom.DomHelper.prototype.$$ = goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;
goog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;
goog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {
    return goog.dom.getViewportSize(opt_window || this.getWindow())
};
goog.dom.DomHelper.prototype.getDocumentHeight = function() {
    return goog.dom.getDocumentHeight_(this.getWindow())
};
goog.dom.Appendable;
goog.dom.DomHelper.prototype.createDom = function(tagName, opt_attributes, var_args) {
    return goog.dom.createDom_(this.document_, arguments)
};
goog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;
goog.dom.DomHelper.prototype.createElement = function(name) {
    return goog.dom.createElement_(this.document_, name)
};
goog.dom.DomHelper.prototype.createTextNode = function(content) {
    return this.document_.createTextNode(String(content))
};
goog.dom.DomHelper.prototype.createTable = function(rows, columns, opt_fillWithNbsp) {
    return goog.dom.createTable_(this.document_, rows, columns, !!opt_fillWithNbsp)
};
goog.dom.DomHelper.prototype.safeHtmlToNode = function(html) {
    return goog.dom.safeHtmlToNode_(this.document_, html)
};
goog.dom.DomHelper.prototype.isCss1CompatMode = function() {
    return goog.dom.isCss1CompatMode_(this.document_)
};
goog.dom.DomHelper.prototype.getWindow = function() {
    return goog.dom.getWindow_(this.document_)
};
goog.dom.DomHelper.prototype.getDocumentScrollElement = function() {
    return goog.dom.getDocumentScrollElement_(this.document_)
};
goog.dom.DomHelper.prototype.getDocumentScroll = function() {
    return goog.dom.getDocumentScroll_(this.document_)
};
goog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {
    return goog.dom.getActiveElement(opt_doc || this.document_)
};
goog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;
goog.dom.DomHelper.prototype.append = goog.dom.append;
goog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;
goog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;
goog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;
goog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;
goog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;
goog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;
goog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;
goog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;
goog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;
goog.dom.DomHelper.prototype.getFirstElementChild = goog.dom.getFirstElementChild;
goog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;
goog.dom.DomHelper.prototype.getNextElementSibling = goog.dom.getNextElementSibling;
goog.dom.DomHelper.prototype.getPreviousElementSibling = goog.dom.getPreviousElementSibling;
goog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;
goog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;
goog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;
goog.dom.DomHelper.prototype.isElement = goog.dom.isElement;
goog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;
goog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;
goog.dom.DomHelper.prototype.contains = goog.dom.contains;
goog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;
goog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;
goog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;
goog.dom.DomHelper.prototype.getFrameContentDocument = goog.dom.getFrameContentDocument;
goog.dom.DomHelper.prototype.getFrameContentWindow = goog.dom.getFrameContentWindow;
goog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;
goog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;
goog.dom.DomHelper.prototype.findNode = goog.dom.findNode;
goog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;
goog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;
goog.dom.DomHelper.prototype.setFocusableTabIndex = goog.dom.setFocusableTabIndex;
goog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;
goog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;
goog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;
goog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;
goog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;
goog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;
goog.dom.DomHelper.prototype.getAncestorByTagNameAndClass = goog.dom.getAncestorByTagNameAndClass;
goog.dom.DomHelper.prototype.getAncestorByClass = goog.dom.getAncestorByClass;
goog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;
goog.dom.DomHelper.prototype.getCanvasContext2D = goog.dom.getCanvasContext2D;
goog.provide("goog.dom.vendor");
goog.require("goog.string");
goog.require("goog.userAgent");
goog.dom.vendor.getVendorJsPrefix = function() {
    if (goog.userAgent.WEBKIT) return "Webkit";
    else if (goog.userAgent.GECKO) return "Moz";
    else if (goog.userAgent.IE) return "ms";
    else if (goog.userAgent.OPERA) return "O";
    return null
};
goog.dom.vendor.getVendorPrefix = function() {
    if (goog.userAgent.WEBKIT) return "-webkit";
    else if (goog.userAgent.GECKO) return "-moz";
    else if (goog.userAgent.IE) return "-ms";
    else if (goog.userAgent.OPERA) return "-o";
    return null
};
goog.dom.vendor.getPrefixedPropertyName = function(propertyName, opt_object) {
    if (opt_object && propertyName in opt_object) return propertyName;
    var prefix = goog.dom.vendor.getVendorJsPrefix();
    if (prefix) {
        prefix = prefix.toLowerCase();
        var prefixedPropertyName = prefix + goog.string.toTitleCase(propertyName);
        return !goog.isDef(opt_object) || prefixedPropertyName in opt_object ? prefixedPropertyName : null
    }
    return null
};
goog.dom.vendor.getPrefixedEventType = function(eventType) {
    var prefix = goog.dom.vendor.getVendorJsPrefix() || "";
    return (prefix + eventType).toLowerCase()
};
goog.provide("goog.math.Box");
goog.require("goog.asserts");
goog.require("goog.math.Coordinate");
goog.math.Box = function(top, right, bottom, left) {
    this.top = top;
    this.right = right;
    this.bottom = bottom;
    this.left = left
};
goog.math.Box.boundingBox = function(var_args) {
    var box = new goog.math.Box(arguments[0].y, arguments[0].x, arguments[0].y, arguments[0].x);
    for (var i = 1; i < arguments.length; i++) box.expandToIncludeCoordinate(arguments[i]);
    return box
};
goog.math.Box.prototype.getWidth = function() {
    return this.right - this.left
};
goog.math.Box.prototype.getHeight = function() {
    return this.bottom - this.top
};
goog.math.Box.prototype.clone = function() {
    return new goog.math.Box(this.top, this.right, this.bottom, this.left)
};
if (goog.DEBUG) goog.math.Box.prototype.toString = function() {
    return "(" + this.top + "t, " + this.right + "r, " + this.bottom + "b, " + this.left + "l)"
};
goog.math.Box.prototype.contains = function(other) {
    return goog.math.Box.contains(this, other)
};
goog.math.Box.prototype.expand = function(top, opt_right, opt_bottom, opt_left) {
    if (goog.isObject(top)) {
        this.top -= top.top;
        this.right += top.right;
        this.bottom += top.bottom;
        this.left -= top.left
    } else {
        this.top -= top;
        this.right += Number(opt_right);
        this.bottom += Number(opt_bottom);
        this.left -= Number(opt_left)
    }
    return this
};
goog.math.Box.prototype.expandToInclude = function(box) {
    this.left = Math.min(this.left, box.left);
    this.top = Math.min(this.top, box.top);
    this.right = Math.max(this.right, box.right);
    this.bottom = Math.max(this.bottom, box.bottom)
};
goog.math.Box.prototype.expandToIncludeCoordinate = function(coord) {
    this.top = Math.min(this.top, coord.y);
    this.right = Math.max(this.right, coord.x);
    this.bottom = Math.max(this.bottom, coord.y);
    this.left = Math.min(this.left, coord.x)
};
goog.math.Box.equals = function(a, b) {
    if (a == b) return true;
    if (!a || !b) return false;
    return a.top == b.top && a.right == b.right && a.bottom == b.bottom && a.left == b.left
};
goog.math.Box.contains = function(box, other) {
    if (!box || !other) return false;
    if (other instanceof goog.math.Box) return other.left >= box.left && other.right <= box.right && other.top >= box.top && other.bottom <= box.bottom;
    return other.x >= box.left && other.x <= box.right && other.y >= box.top && other.y <= box.bottom
};
goog.math.Box.relativePositionX = function(box, coord) {
    if (coord.x < box.left) return coord.x - box.left;
    else if (coord.x > box.right) return coord.x - box.right;
    return 0
};
goog.math.Box.relativePositionY = function(box, coord) {
    if (coord.y < box.top) return coord.y - box.top;
    else if (coord.y > box.bottom) return coord.y - box.bottom;
    return 0
};
goog.math.Box.distance = function(box, coord) {
    var x = goog.math.Box.relativePositionX(box, coord);
    var y = goog.math.Box.relativePositionY(box, coord);
    return Math.sqrt(x * x + y * y)
};
goog.math.Box.intersects = function(a, b) {
    return a.left <= b.right && b.left <= a.right && a.top <= b.bottom && b.top <= a.bottom
};
goog.math.Box.intersectsWithPadding = function(a, b, padding) {
    return a.left <= b.right + padding && b.left <= a.right + padding && a.top <= b.bottom + padding && b.top <= a.bottom + padding
};
goog.math.Box.prototype.ceil = function() {
    this.top = Math.ceil(this.top);
    this.right = Math.ceil(this.right);
    this.bottom = Math.ceil(this.bottom);
    this.left = Math.ceil(this.left);
    return this
};
goog.math.Box.prototype.floor = function() {
    this.top = Math.floor(this.top);
    this.right = Math.floor(this.right);
    this.bottom = Math.floor(this.bottom);
    this.left = Math.floor(this.left);
    return this
};
goog.math.Box.prototype.round = function() {
    this.top = Math.round(this.top);
    this.right = Math.round(this.right);
    this.bottom = Math.round(this.bottom);
    this.left = Math.round(this.left);
    return this
};
goog.math.Box.prototype.translate = function(tx, opt_ty) {
    if (tx instanceof goog.math.Coordinate) {
        this.left += tx.x;
        this.right += tx.x;
        this.top += tx.y;
        this.bottom += tx.y
    } else {
        goog.asserts.assertNumber(tx);
        this.left += tx;
        this.right += tx;
        if (goog.isNumber(opt_ty)) {
            this.top += opt_ty;
            this.bottom += opt_ty
        }
    }
    return this
};
goog.math.Box.prototype.scale = function(sx, opt_sy) {
    var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
    this.left *= sx;
    this.right *= sx;
    this.top *= sy;
    this.bottom *= sy;
    return this
};
goog.provide("goog.math.IRect");
goog.math.IRect = function() {};
goog.math.IRect.prototype.left;
goog.math.IRect.prototype.top;
goog.math.IRect.prototype.width;
goog.math.IRect.prototype.height;
goog.provide("goog.math.Rect");
goog.require("goog.asserts");
goog.require("goog.math.Box");
goog.require("goog.math.Coordinate");
goog.require("goog.math.IRect");
goog.require("goog.math.Size");
goog.math.Rect = function(x, y, w, h) {
    this.left = x;
    this.top = y;
    this.width = w;
    this.height = h
};
goog.math.Rect.prototype.clone = function() {
    return new goog.math.Rect(this.left, this.top, this.width, this.height)
};
goog.math.Rect.prototype.toBox = function() {
    var right = this.left + this.width;
    var bottom = this.top + this.height;
    return new goog.math.Box(this.top, right, bottom, this.left)
};
goog.math.Rect.createFromPositionAndSize = function(position, size) {
    return new goog.math.Rect(position.x, position.y, size.width, size.height)
};
goog.math.Rect.createFromBox = function(box) {
    return new goog.math.Rect(box.left, box.top, box.right - box.left, box.bottom - box.top)
};
if (goog.DEBUG) goog.math.Rect.prototype.toString = function() {
    return "(" + this.left + ", " + this.top + " - " + this.width + "w x " + this.height + "h)"
};
goog.math.Rect.equals = function(a, b) {
    if (a == b) return true;
    if (!a || !b) return false;
    return a.left == b.left && a.width == b.width && a.top == b.top && a.height == b.height
};
goog.math.Rect.prototype.intersection = function(rect) {
    var x0 = Math.max(this.left, rect.left);
    var x1 = Math.min(this.left + this.width, rect.left + rect.width);
    if (x0 <= x1) {
        var y0 = Math.max(this.top, rect.top);
        var y1 = Math.min(this.top + this.height, rect.top + rect.height);
        if (y0 <= y1) {
            this.left = x0;
            this.top = y0;
            this.width = x1 - x0;
            this.height = y1 - y0;
            return true
        }
    }
    return false
};
goog.math.Rect.intersection = function(a, b) {
    var x0 = Math.max(a.left, b.left);
    var x1 = Math.min(a.left + a.width, b.left + b.width);
    if (x0 <= x1) {
        var y0 = Math.max(a.top, b.top);
        var y1 = Math.min(a.top + a.height, b.top + b.height);
        if (y0 <= y1) return new goog.math.Rect(x0, y0, x1 - x0, y1 - y0)
    }
    return null
};
goog.math.Rect.intersects = function(a, b) {
    return a.left <= b.left + b.width && b.left <= a.left + a.width && a.top <= b.top + b.height && b.top <= a.top + a.height
};
goog.math.Rect.prototype.intersects = function(rect) {
    return goog.math.Rect.intersects(this, rect)
};
goog.math.Rect.difference = function(a, b) {
    var intersection = goog.math.Rect.intersection(a, b);
    if (!intersection || !intersection.height || !intersection.width) return [a.clone()];
    var result = [];
    var top = a.top;
    var height = a.height;
    var ar = a.left + a.width;
    var ab = a.top + a.height;
    var br = b.left + b.width;
    var bb = b.top + b.height;
    if (b.top > a.top) {
        result.push(new goog.math.Rect(a.left, a.top, a.width, b.top - a.top));
        top = b.top;
        height -= b.top - a.top
    }
    if (bb < ab) {
        result.push(new goog.math.Rect(a.left, bb, a.width, ab - bb));
        height = bb - top
    }
    if (b.left >
        a.left) result.push(new goog.math.Rect(a.left, top, b.left - a.left, height));
    if (br < ar) result.push(new goog.math.Rect(br, top, ar - br, height));
    return result
};
goog.math.Rect.prototype.difference = function(rect) {
    return goog.math.Rect.difference(this, rect)
};
goog.math.Rect.prototype.boundingRect = function(rect) {
    var right = Math.max(this.left + this.width, rect.left + rect.width);
    var bottom = Math.max(this.top + this.height, rect.top + rect.height);
    this.left = Math.min(this.left, rect.left);
    this.top = Math.min(this.top, rect.top);
    this.width = right - this.left;
    this.height = bottom - this.top
};
goog.math.Rect.boundingRect = function(a, b) {
    if (!a || !b) return null;
    var newRect = new goog.math.Rect(a.left, a.top, a.width, a.height);
    newRect.boundingRect(b);
    return newRect
};
goog.math.Rect.prototype.contains = function(another) {
    if (another instanceof goog.math.Coordinate) return another.x >= this.left && another.x <= this.left + this.width && another.y >= this.top && another.y <= this.top + this.height;
    else return this.left <= another.left && this.left + this.width >= another.left + another.width && this.top <= another.top && this.top + this.height >= another.top + another.height
};
goog.math.Rect.prototype.squaredDistance = function(point) {
    var dx = point.x < this.left ? this.left - point.x : Math.max(point.x - (this.left + this.width), 0);
    var dy = point.y < this.top ? this.top - point.y : Math.max(point.y - (this.top + this.height), 0);
    return dx * dx + dy * dy
};
goog.math.Rect.prototype.distance = function(point) {
    return Math.sqrt(this.squaredDistance(point))
};
goog.math.Rect.prototype.getSize = function() {
    return new goog.math.Size(this.width, this.height)
};
goog.math.Rect.prototype.getTopLeft = function() {
    return new goog.math.Coordinate(this.left, this.top)
};
goog.math.Rect.prototype.getCenter = function() {
    return new goog.math.Coordinate(this.left + this.width / 2, this.top + this.height / 2)
};
goog.math.Rect.prototype.getBottomRight = function() {
    return new goog.math.Coordinate(this.left + this.width, this.top + this.height)
};
goog.math.Rect.prototype.ceil = function() {
    this.left = Math.ceil(this.left);
    this.top = Math.ceil(this.top);
    this.width = Math.ceil(this.width);
    this.height = Math.ceil(this.height);
    return this
};
goog.math.Rect.prototype.floor = function() {
    this.left = Math.floor(this.left);
    this.top = Math.floor(this.top);
    this.width = Math.floor(this.width);
    this.height = Math.floor(this.height);
    return this
};
goog.math.Rect.prototype.round = function() {
    this.left = Math.round(this.left);
    this.top = Math.round(this.top);
    this.width = Math.round(this.width);
    this.height = Math.round(this.height);
    return this
};
goog.math.Rect.prototype.translate = function(tx, opt_ty) {
    if (tx instanceof goog.math.Coordinate) {
        this.left += tx.x;
        this.top += tx.y
    } else {
        this.left += goog.asserts.assertNumber(tx);
        if (goog.isNumber(opt_ty)) this.top += opt_ty
    }
    return this
};
goog.math.Rect.prototype.scale = function(sx, opt_sy) {
    var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
    this.left *= sx;
    this.width *= sx;
    this.top *= sy;
    this.height *= sy;
    return this
};
goog.provide("goog.style");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.dom");
goog.require("goog.dom.NodeType");
goog.require("goog.dom.TagName");
goog.require("goog.dom.vendor");
goog.require("goog.html.SafeStyleSheet");
goog.require("goog.math.Box");
goog.require("goog.math.Coordinate");
goog.require("goog.math.Rect");
goog.require("goog.math.Size");
goog.require("goog.object");
goog.require("goog.reflect");
goog.require("goog.string");
goog.require("goog.userAgent");
goog.forwardDeclare("goog.events.Event");
goog.style.setStyle = function(element, style, opt_value) {
    if (goog.isString(style)) goog.style.setStyle_(element, opt_value, style);
    else
        for (var key in style) goog.style.setStyle_(element, style[key], key)
};
goog.style.setStyle_ = function(element, value, style) {
    var propertyName = goog.style.getVendorJsStyleName_(element, style);
    if (propertyName) element.style[propertyName] = value
};
goog.style.styleNameCache_ = {};
goog.style.getVendorJsStyleName_ = function(element, style) {
    var propertyName = goog.style.styleNameCache_[style];
    if (!propertyName) {
        var camelStyle = goog.string.toCamelCase(style);
        propertyName = camelStyle;
        if (element.style[camelStyle] === undefined) {
            var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() + goog.string.toTitleCase(camelStyle);
            if (element.style[prefixedStyle] !== undefined) propertyName = prefixedStyle
        }
        goog.style.styleNameCache_[style] = propertyName
    }
    return propertyName
};
goog.style.getVendorStyleName_ = function(element, style) {
    var camelStyle = goog.string.toCamelCase(style);
    if (element.style[camelStyle] === undefined) {
        var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() + goog.string.toTitleCase(camelStyle);
        if (element.style[prefixedStyle] !== undefined) return goog.dom.vendor.getVendorPrefix() + "-" + style
    }
    return style
};
goog.style.getStyle = function(element, property) {
    var styleValue = element.style[goog.string.toCamelCase(property)];
    if (typeof styleValue !== "undefined") return styleValue;
    return element.style[goog.style.getVendorJsStyleName_(element, property)] || ""
};
goog.style.getComputedStyle = function(element, property) {
    var doc = goog.dom.getOwnerDocument(element);
    if (doc.defaultView && doc.defaultView.getComputedStyle) {
        var styles = doc.defaultView.getComputedStyle(element, null);
        if (styles) return styles[property] || styles.getPropertyValue(property) || ""
    }
    return ""
};
goog.style.getCascadedStyle = function(element, style) {
    return element.currentStyle ? element.currentStyle[style] : null
};
goog.style.getStyle_ = function(element, style) {
    return goog.style.getComputedStyle(element, style) || goog.style.getCascadedStyle(element, style) || element.style && element.style[style]
};
goog.style.getComputedBoxSizing = function(element) {
    return goog.style.getStyle_(element, "boxSizing") || goog.style.getStyle_(element, "MozBoxSizing") || goog.style.getStyle_(element, "WebkitBoxSizing") || null
};
goog.style.getComputedPosition = function(element) {
    return goog.style.getStyle_(element, "position")
};
goog.style.getBackgroundColor = function(element) {
    return goog.style.getStyle_(element, "backgroundColor")
};
goog.style.getComputedOverflowX = function(element) {
    return goog.style.getStyle_(element, "overflowX")
};
goog.style.getComputedOverflowY = function(element) {
    return goog.style.getStyle_(element, "overflowY")
};
goog.style.getComputedZIndex = function(element) {
    return goog.style.getStyle_(element, "zIndex")
};
goog.style.getComputedTextAlign = function(element) {
    return goog.style.getStyle_(element, "textAlign")
};
goog.style.getComputedCursor = function(element) {
    return goog.style.getStyle_(element, "cursor")
};
goog.style.getComputedTransform = function(element) {
    var property = goog.style.getVendorStyleName_(element, "transform");
    return goog.style.getStyle_(element, property) || goog.style.getStyle_(element, "transform")
};
goog.style.setPosition = function(el, arg1, opt_arg2) {
    var x, y;
    if (arg1 instanceof goog.math.Coordinate) {
        x = arg1.x;
        y = arg1.y
    } else {
        x = arg1;
        y = opt_arg2
    }
    el.style.left = goog.style.getPixelStyleValue_(x, false);
    el.style.top = goog.style.getPixelStyleValue_(y, false)
};
goog.style.getPosition = function(element) {
    return new goog.math.Coordinate(element.offsetLeft, element.offsetTop)
};
goog.style.getClientViewportElement = function(opt_node) {
    var doc;
    if (opt_node) doc = goog.dom.getOwnerDocument(opt_node);
    else doc = goog.dom.getDocument();
    if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) && !goog.dom.getDomHelper(doc).isCss1CompatMode()) return doc.body;
    return doc.documentElement
};
goog.style.getViewportPageOffset = function(doc) {
    var body = doc.body;
    var documentElement = doc.documentElement;
    var scrollLeft = body.scrollLeft || documentElement.scrollLeft;
    var scrollTop = body.scrollTop || documentElement.scrollTop;
    return new goog.math.Coordinate(scrollLeft, scrollTop)
};
goog.style.getBoundingClientRect_ = function(el) {
    var rect;
    try {
        rect = el.getBoundingClientRect()
    } catch (e) {
        return {
            "left": 0,
            "top": 0,
            "right": 0,
            "bottom": 0
        }
    }
    if (goog.userAgent.IE && el.ownerDocument.body) {
        var doc = el.ownerDocument;
        rect.left -= doc.documentElement.clientLeft + doc.body.clientLeft;
        rect.top -= doc.documentElement.clientTop + doc.body.clientTop
    }
    return rect
};
goog.style.getOffsetParent = function(element) {
    if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(8)) {
        goog.asserts.assert(element && "offsetParent" in element);
        return element.offsetParent
    }
    var doc = goog.dom.getOwnerDocument(element);
    var positionStyle = goog.style.getStyle_(element, "position");
    var skipStatic = positionStyle == "fixed" || positionStyle == "absolute";
    for (var parent = element.parentNode; parent && parent != doc; parent = parent.parentNode) {
        if (parent.nodeType == goog.dom.NodeType.DOCUMENT_FRAGMENT && parent.host) parent =
            parent.host;
        positionStyle = goog.style.getStyle_(parent, "position");
        skipStatic = skipStatic && positionStyle == "static" && parent != doc.documentElement && parent != doc.body;
        if (!skipStatic && (parent.scrollWidth > parent.clientWidth || parent.scrollHeight > parent.clientHeight || positionStyle == "fixed" || positionStyle == "absolute" || positionStyle == "relative")) return parent
    }
    return null
};
goog.style.getVisibleRectForElement = function(element) {
    var visibleRect = new goog.math.Box(0, Infinity, Infinity, 0);
    var dom = goog.dom.getDomHelper(element);
    var body = dom.getDocument().body;
    var documentElement = dom.getDocument().documentElement;
    var scrollEl = dom.getDocumentScrollElement();
    for (var el = element; el = goog.style.getOffsetParent(el);)
        if ((!goog.userAgent.IE || el.clientWidth != 0) && (!goog.userAgent.WEBKIT || el.clientHeight != 0 || el != body) && (el != body && el != documentElement && goog.style.getStyle_(el, "overflow") !=
                "visible")) {
            var pos = goog.style.getPageOffset(el);
            var client = goog.style.getClientLeftTop(el);
            pos.x += client.x;
            pos.y += client.y;
            visibleRect.top = Math.max(visibleRect.top, pos.y);
            visibleRect.right = Math.min(visibleRect.right, pos.x + el.clientWidth);
            visibleRect.bottom = Math.min(visibleRect.bottom, pos.y + el.clientHeight);
            visibleRect.left = Math.max(visibleRect.left, pos.x)
        } var scrollX = scrollEl.scrollLeft,
        scrollY = scrollEl.scrollTop;
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top,
        scrollY);
    var winSize = dom.getViewportSize();
    visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
    return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null
};
goog.style.getContainerOffsetToScrollInto = function(element, opt_container, opt_center) {
    var container = opt_container || goog.dom.getDocumentScrollElement();
    var elementPos = goog.style.getPageOffset(element);
    var containerPos = goog.style.getPageOffset(container);
    var containerBorder = goog.style.getBorderBox(container);
    if (container == goog.dom.getDocumentScrollElement()) {
        var relX = elementPos.x - container.scrollLeft;
        var relY = elementPos.y - container.scrollTop;
        if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(10)) {
            relX +=
                containerBorder.left;
            relY += containerBorder.top
        }
    } else {
        var relX = elementPos.x - containerPos.x - containerBorder.left;
        var relY = elementPos.y - containerPos.y - containerBorder.top
    }
    var elementSize = goog.style.getSizeWithDisplay_(element);
    var spaceX = container.clientWidth - elementSize.width;
    var spaceY = container.clientHeight - elementSize.height;
    var scrollLeft = container.scrollLeft;
    var scrollTop = container.scrollTop;
    if (opt_center) {
        scrollLeft += relX - spaceX / 2;
        scrollTop += relY - spaceY / 2
    } else {
        scrollLeft += Math.min(relX, Math.max(relX -
            spaceX, 0));
        scrollTop += Math.min(relY, Math.max(relY - spaceY, 0))
    }
    return new goog.math.Coordinate(scrollLeft, scrollTop)
};
goog.style.scrollIntoContainerView = function(element, opt_container, opt_center) {
    var container = opt_container || goog.dom.getDocumentScrollElement();
    var offset = goog.style.getContainerOffsetToScrollInto(element, container, opt_center);
    container.scrollLeft = offset.x;
    container.scrollTop = offset.y
};
goog.style.getClientLeftTop = function(el) {
    return new goog.math.Coordinate(el.clientLeft, el.clientTop)
};
goog.style.getPageOffset = function(el) {
    var doc = goog.dom.getOwnerDocument(el);
    goog.asserts.assertObject(el, "Parameter is required");
    var pos = new goog.math.Coordinate(0, 0);
    var viewportElement = goog.style.getClientViewportElement(doc);
    if (el == viewportElement) return pos;
    var box = goog.style.getBoundingClientRect_(el);
    var scrollCoord = goog.dom.getDomHelper(doc).getDocumentScroll();
    pos.x = box.left + scrollCoord.x;
    pos.y = box.top + scrollCoord.y;
    return pos
};
goog.style.getPageOffsetLeft = function(el) {
    return goog.style.getPageOffset(el).x
};
goog.style.getPageOffsetTop = function(el) {
    return goog.style.getPageOffset(el).y
};
goog.style.getFramedPageOffset = function(el, relativeWin) {
    var position = new goog.math.Coordinate(0, 0);
    var currentWin = goog.dom.getWindow(goog.dom.getOwnerDocument(el));
    if (!goog.reflect.canAccessProperty(currentWin, "parent")) return position;
    var currentEl = el;
    do {
        var offset = currentWin == relativeWin ? goog.style.getPageOffset(currentEl) : goog.style.getClientPositionForElement_(goog.asserts.assert(currentEl));
        position.x += offset.x;
        position.y += offset.y
    } while (currentWin && currentWin != relativeWin && currentWin != currentWin.parent &&
        (currentEl = currentWin.frameElement) && (currentWin = currentWin.parent));
    return position
};
goog.style.translateRectForAnotherFrame = function(rect, origBase, newBase) {
    if (origBase.getDocument() != newBase.getDocument()) {
        var body = origBase.getDocument().body;
        var pos = goog.style.getFramedPageOffset(body, newBase.getWindow());
        pos = goog.math.Coordinate.difference(pos, goog.style.getPageOffset(body));
        if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) && !origBase.isCss1CompatMode()) pos = goog.math.Coordinate.difference(pos, origBase.getDocumentScroll());
        rect.left += pos.x;
        rect.top += pos.y
    }
};
goog.style.getRelativePosition = function(a, b) {
    var ap = goog.style.getClientPosition(a);
    var bp = goog.style.getClientPosition(b);
    return new goog.math.Coordinate(ap.x - bp.x, ap.y - bp.y)
};
goog.style.getClientPositionForElement_ = function(el) {
    var box = goog.style.getBoundingClientRect_(el);
    return new goog.math.Coordinate(box.left, box.top)
};
goog.style.getClientPosition = function(el) {
    goog.asserts.assert(el);
    if (el.nodeType == goog.dom.NodeType.ELEMENT) return goog.style.getClientPositionForElement_(el);
    else {
        var targetEvent = el.changedTouches ? el.changedTouches[0] : el;
        return new goog.math.Coordinate(targetEvent.clientX, targetEvent.clientY)
    }
};
goog.style.setPageOffset = function(el, x, opt_y) {
    var cur = goog.style.getPageOffset(el);
    if (x instanceof goog.math.Coordinate) {
        opt_y = x.y;
        x = x.x
    }
    var dx = goog.asserts.assertNumber(x) - cur.x;
    var dy = Number(opt_y) - cur.y;
    goog.style.setPosition(el, el.offsetLeft + dx, el.offsetTop + dy)
};
goog.style.setSize = function(element, w, opt_h) {
    var h;
    if (w instanceof goog.math.Size) {
        h = w.height;
        w = w.width
    } else {
        if (opt_h == undefined) throw new Error("missing height argument");
        h = opt_h
    }
    goog.style.setWidth(element, w);
    goog.style.setHeight(element, h)
};
goog.style.getPixelStyleValue_ = function(value, round) {
    if (typeof value == "number") value = (round ? Math.round(value) : value) + "px";
    return value
};
goog.style.setHeight = function(element, height) {
    element.style.height = goog.style.getPixelStyleValue_(height, true)
};
goog.style.setWidth = function(element, width) {
    element.style.width = goog.style.getPixelStyleValue_(width, true)
};
goog.style.getSize = function(element) {
    return goog.style.evaluateWithTemporaryDisplay_(goog.style.getSizeWithDisplay_, element)
};
goog.style.evaluateWithTemporaryDisplay_ = function(fn, element) {
    if (goog.style.getStyle_(element, "display") != "none") return fn(element);
    var style = element.style;
    var originalDisplay = style.display;
    var originalVisibility = style.visibility;
    var originalPosition = style.position;
    style.visibility = "hidden";
    style.position = "absolute";
    style.display = "inline";
    var retVal = fn(element);
    style.display = originalDisplay;
    style.position = originalPosition;
    style.visibility = originalVisibility;
    return retVal
};
goog.style.getSizeWithDisplay_ = function(element) {
    var offsetWidth = element.offsetWidth;
    var offsetHeight = element.offsetHeight;
    var webkitOffsetsZero = goog.userAgent.WEBKIT && !offsetWidth && !offsetHeight;
    if ((!goog.isDef(offsetWidth) || webkitOffsetsZero) && element.getBoundingClientRect) {
        var clientRect = goog.style.getBoundingClientRect_(element);
        return new goog.math.Size(clientRect.right - clientRect.left, clientRect.bottom - clientRect.top)
    }
    return new goog.math.Size(offsetWidth, offsetHeight)
};
goog.style.getTransformedSize = function(element) {
    if (!element.getBoundingClientRect) return null;
    var clientRect = goog.style.evaluateWithTemporaryDisplay_(goog.style.getBoundingClientRect_, element);
    return new goog.math.Size(clientRect.right - clientRect.left, clientRect.bottom - clientRect.top)
};
goog.style.getBounds = function(element) {
    var o = goog.style.getPageOffset(element);
    var s = goog.style.getSize(element);
    return new goog.math.Rect(o.x, o.y, s.width, s.height)
};
goog.style.toCamelCase = function(selector) {
    return goog.string.toCamelCase(String(selector))
};
goog.style.toSelectorCase = function(selector) {
    return goog.string.toSelectorCase(selector)
};
goog.style.getOpacity = function(el) {
    goog.asserts.assert(el);
    var style = el.style;
    var result = "";
    if ("opacity" in style) result = style.opacity;
    else if ("MozOpacity" in style) result = style.MozOpacity;
    else if ("filter" in style) {
        var match = style.filter.match(/alpha\(opacity=([\d.]+)\)/);
        if (match) result = String(match[1] / 100)
    }
    return result == "" ? result : Number(result)
};
goog.style.setOpacity = function(el, alpha) {
    goog.asserts.assert(el);
    var style = el.style;
    if ("opacity" in style) style.opacity = alpha;
    else if ("MozOpacity" in style) style.MozOpacity = alpha;
    else if ("filter" in style)
        if (alpha === "") style.filter = "";
        else style.filter = "alpha(opacity=" + Number(alpha) * 100 + ")"
};
goog.style.setTransparentBackgroundImage = function(el, src) {
    var style = el.style;
    if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("8")) style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(" + 'src="' + src + '", sizingMethod="crop")';
    else {
        style.backgroundImage = "url(" + src + ")";
        style.backgroundPosition = "top left";
        style.backgroundRepeat = "no-repeat"
    }
};
goog.style.clearTransparentBackgroundImage = function(el) {
    var style = el.style;
    if ("filter" in style) style.filter = "";
    else style.backgroundImage = "none"
};
goog.style.showElement = function(el, display) {
    goog.style.setElementShown(el, display)
};
goog.style.setElementShown = function(el, isShown) {
    el.style.display = isShown ? "" : "none"
};
goog.style.isElementShown = function(el) {
    return el.style.display != "none"
};
goog.style.installSafeStyleSheet = function(safeStyleSheet, opt_node) {
    var dh = goog.dom.getDomHelper(opt_node);
    var doc = dh.getDocument();
    if (goog.userAgent.IE && doc.createStyleSheet) {
        var styleSheet = doc.createStyleSheet();
        goog.style.setSafeStyleSheet(styleSheet, safeStyleSheet);
        return styleSheet
    } else {
        var head = dh.getElementsByTagNameAndClass(goog.dom.TagName.HEAD)[0];
        if (!head) {
            var body = dh.getElementsByTagNameAndClass(goog.dom.TagName.BODY)[0];
            head = dh.createDom(goog.dom.TagName.HEAD);
            body.parentNode.insertBefore(head,
                body)
        }
        var el = dh.createDom(goog.dom.TagName.STYLE);
        goog.style.setSafeStyleSheet(el, safeStyleSheet);
        dh.appendChild(head, el);
        return el
    }
};
goog.style.uninstallStyles = function(styleSheet) {
    var node = styleSheet.ownerNode || styleSheet.owningElement || styleSheet;
    goog.dom.removeNode(node)
};
goog.style.setSafeStyleSheet = function(element, safeStyleSheet) {
    var stylesString = goog.html.SafeStyleSheet.unwrap(safeStyleSheet);
    if (goog.userAgent.IE && goog.isDef(element.cssText)) element.cssText = stylesString;
    else element.innerHTML = stylesString
};
goog.style.setPreWrap = function(el) {
    var style = el.style;
    if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("8")) {
        style.whiteSpace = "pre";
        style.wordWrap = "break-word"
    } else if (goog.userAgent.GECKO) style.whiteSpace = "-moz-pre-wrap";
    else style.whiteSpace = "pre-wrap"
};
goog.style.setInlineBlock = function(el) {
    var style = el.style;
    style.position = "relative";
    if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("8")) {
        style.zoom = "1";
        style.display = "inline"
    } else style.display = "inline-block"
};
goog.style.isRightToLeft = function(el) {
    return "rtl" == goog.style.getStyle_(el, "direction")
};
goog.style.unselectableStyle_ = goog.userAgent.GECKO ? "MozUserSelect" : goog.userAgent.WEBKIT || goog.userAgent.EDGE ? "WebkitUserSelect" : null;
goog.style.isUnselectable = function(el) {
    if (goog.style.unselectableStyle_) return el.style[goog.style.unselectableStyle_].toLowerCase() == "none";
    else if (goog.userAgent.IE || goog.userAgent.OPERA) return el.getAttribute("unselectable") == "on";
    return false
};
goog.style.setUnselectable = function(el, unselectable, opt_noRecurse) {
    var descendants = !opt_noRecurse ? el.getElementsByTagName("*") : null;
    var name = goog.style.unselectableStyle_;
    if (name) {
        var value = unselectable ? "none" : "";
        if (el.style) el.style[name] = value;
        if (descendants)
            for (var i = 0, descendant; descendant = descendants[i]; i++)
                if (descendant.style) descendant.style[name] = value
    } else if (goog.userAgent.IE || goog.userAgent.OPERA) {
        var value = unselectable ? "on" : "";
        el.setAttribute("unselectable", value);
        if (descendants)
            for (var i =
                    0, descendant; descendant = descendants[i]; i++) descendant.setAttribute("unselectable", value)
    }
};
goog.style.getBorderBoxSize = function(element) {
    return new goog.math.Size(element.offsetWidth, element.offsetHeight)
};
goog.style.setBorderBoxSize = function(element, size) {
    var doc = goog.dom.getOwnerDocument(element);
    var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();
    if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("10") && (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher("8"))) {
        var style = element.style;
        if (isCss1CompatMode) {
            var paddingBox = goog.style.getPaddingBox(element);
            var borderBox = goog.style.getBorderBox(element);
            style.pixelWidth = size.width - borderBox.left - paddingBox.left - paddingBox.right -
                borderBox.right;
            style.pixelHeight = size.height - borderBox.top - paddingBox.top - paddingBox.bottom - borderBox.bottom
        } else {
            style.pixelWidth = size.width;
            style.pixelHeight = size.height
        }
    } else goog.style.setBoxSizingSize_(element, size, "border-box")
};
goog.style.getContentBoxSize = function(element) {
    var doc = goog.dom.getOwnerDocument(element);
    var ieCurrentStyle = goog.userAgent.IE && element.currentStyle;
    if (ieCurrentStyle && goog.dom.getDomHelper(doc).isCss1CompatMode() && ieCurrentStyle.width != "auto" && ieCurrentStyle.height != "auto" && !ieCurrentStyle.boxSizing) {
        var width = goog.style.getIePixelValue_(element, ieCurrentStyle.width, "width", "pixelWidth");
        var height = goog.style.getIePixelValue_(element, ieCurrentStyle.height, "height", "pixelHeight");
        return new goog.math.Size(width,
            height)
    } else {
        var borderBoxSize = goog.style.getBorderBoxSize(element);
        var paddingBox = goog.style.getPaddingBox(element);
        var borderBox = goog.style.getBorderBox(element);
        return new goog.math.Size(borderBoxSize.width - borderBox.left - paddingBox.left - paddingBox.right - borderBox.right, borderBoxSize.height - borderBox.top - paddingBox.top - paddingBox.bottom - borderBox.bottom)
    }
};
goog.style.setContentBoxSize = function(element, size) {
    var doc = goog.dom.getOwnerDocument(element);
    var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();
    if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("10") && (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher("8"))) {
        var style = element.style;
        if (isCss1CompatMode) {
            style.pixelWidth = size.width;
            style.pixelHeight = size.height
        } else {
            var paddingBox = goog.style.getPaddingBox(element);
            var borderBox = goog.style.getBorderBox(element);
            style.pixelWidth =
                size.width + borderBox.left + paddingBox.left + paddingBox.right + borderBox.right;
            style.pixelHeight = size.height + borderBox.top + paddingBox.top + paddingBox.bottom + borderBox.bottom
        }
    } else goog.style.setBoxSizingSize_(element, size, "content-box")
};
goog.style.setBoxSizingSize_ = function(element, size, boxSizing) {
    var style = element.style;
    if (goog.userAgent.GECKO) style.MozBoxSizing = boxSizing;
    else if (goog.userAgent.WEBKIT) style.WebkitBoxSizing = boxSizing;
    else style.boxSizing = boxSizing;
    style.width = Math.max(size.width, 0) + "px";
    style.height = Math.max(size.height, 0) + "px"
};
goog.style.getIePixelValue_ = function(element, value, name, pixelName) {
    if (/^\d+px?$/.test(value)) return parseInt(value, 10);
    else {
        var oldStyleValue = element.style[name];
        var oldRuntimeValue = element.runtimeStyle[name];
        element.runtimeStyle[name] = element.currentStyle[name];
        element.style[name] = value;
        var pixelValue = element.style[pixelName];
        element.style[name] = oldStyleValue;
        element.runtimeStyle[name] = oldRuntimeValue;
        return +pixelValue
    }
};
goog.style.getIePixelDistance_ = function(element, propName) {
    var value = goog.style.getCascadedStyle(element, propName);
    return value ? goog.style.getIePixelValue_(element, value, "left", "pixelLeft") : 0
};
goog.style.getBox_ = function(element, stylePrefix) {
    if (goog.userAgent.IE) {
        var left = goog.style.getIePixelDistance_(element, stylePrefix + "Left");
        var right = goog.style.getIePixelDistance_(element, stylePrefix + "Right");
        var top = goog.style.getIePixelDistance_(element, stylePrefix + "Top");
        var bottom = goog.style.getIePixelDistance_(element, stylePrefix + "Bottom");
        return new goog.math.Box(top, right, bottom, left)
    } else {
        var left = goog.style.getComputedStyle(element, stylePrefix + "Left");
        var right = goog.style.getComputedStyle(element,
            stylePrefix + "Right");
        var top = goog.style.getComputedStyle(element, stylePrefix + "Top");
        var bottom = goog.style.getComputedStyle(element, stylePrefix + "Bottom");
        return new goog.math.Box(parseFloat(top), parseFloat(right), parseFloat(bottom), parseFloat(left))
    }
};
goog.style.getPaddingBox = function(element) {
    return goog.style.getBox_(element, "padding")
};
goog.style.getMarginBox = function(element) {
    return goog.style.getBox_(element, "margin")
};
goog.style.ieBorderWidthKeywords_ = {
    "thin": 2,
    "medium": 4,
    "thick": 6
};
goog.style.getIePixelBorder_ = function(element, prop) {
    if (goog.style.getCascadedStyle(element, prop + "Style") == "none") return 0;
    var width = goog.style.getCascadedStyle(element, prop + "Width");
    if (width in goog.style.ieBorderWidthKeywords_) return goog.style.ieBorderWidthKeywords_[width];
    return goog.style.getIePixelValue_(element, width, "left", "pixelLeft")
};
goog.style.getBorderBox = function(element) {
    if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
        var left = goog.style.getIePixelBorder_(element, "borderLeft");
        var right = goog.style.getIePixelBorder_(element, "borderRight");
        var top = goog.style.getIePixelBorder_(element, "borderTop");
        var bottom = goog.style.getIePixelBorder_(element, "borderBottom");
        return new goog.math.Box(top, right, bottom, left)
    } else {
        var left = goog.style.getComputedStyle(element, "borderLeftWidth");
        var right = goog.style.getComputedStyle(element,
            "borderRightWidth");
        var top = goog.style.getComputedStyle(element, "borderTopWidth");
        var bottom = goog.style.getComputedStyle(element, "borderBottomWidth");
        return new goog.math.Box(parseFloat(top), parseFloat(right), parseFloat(bottom), parseFloat(left))
    }
};
goog.style.getFontFamily = function(el) {
    var doc = goog.dom.getOwnerDocument(el);
    var font = "";
    if (doc.body.createTextRange && goog.dom.contains(doc, el)) {
        var range = doc.body.createTextRange();
        range.moveToElementText(el);
        try {
            font = range.queryCommandValue("FontName")
        } catch (e) {
            font = ""
        }
    }
    if (!font) font = goog.style.getStyle_(el, "fontFamily");
    var fontsArray = font.split(",");
    if (fontsArray.length > 1) font = fontsArray[0];
    return goog.string.stripQuotes(font, "\"'")
};
goog.style.lengthUnitRegex_ = /[^\d]+$/;
goog.style.getLengthUnits = function(value) {
    var units = value.match(goog.style.lengthUnitRegex_);
    return units && units[0] || null
};
goog.style.ABSOLUTE_CSS_LENGTH_UNITS_ = {
    "cm": 1,
    "in": 1,
    "mm": 1,
    "pc": 1,
    "pt": 1
};
goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_ = {
    "em": 1,
    "ex": 1
};
goog.style.getFontSize = function(el) {
    var fontSize = goog.style.getStyle_(el, "fontSize");
    var sizeUnits = goog.style.getLengthUnits(fontSize);
    if (fontSize && "px" == sizeUnits) return parseInt(fontSize, 10);
    if (goog.userAgent.IE)
        if (String(sizeUnits) in goog.style.ABSOLUTE_CSS_LENGTH_UNITS_) return goog.style.getIePixelValue_(el, fontSize, "left", "pixelLeft");
        else if (el.parentNode && el.parentNode.nodeType == goog.dom.NodeType.ELEMENT && String(sizeUnits) in goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_) {
        var parentElement = el.parentNode;
        var parentSize = goog.style.getStyle_(parentElement, "fontSize");
        return goog.style.getIePixelValue_(parentElement, fontSize == parentSize ? "1em" : fontSize, "left", "pixelLeft")
    }
    var sizeElement = goog.dom.createDom(goog.dom.TagName.SPAN, {
        "style": "visibility:hidden;position:absolute;" + "line-height:0;padding:0;margin:0;border:0;height:1em;"
    });
    goog.dom.appendChild(el, sizeElement);
    fontSize = sizeElement.offsetHeight;
    goog.dom.removeNode(sizeElement);
    return fontSize
};
goog.style.parseStyleAttribute = function(value) {
    var result = {};
    goog.array.forEach(value.split(/\s*;\s*/), function(pair) {
        var keyValue = pair.match(/\s*([\w-]+)\s*:(.+)/);
        if (keyValue) {
            var styleName = keyValue[1];
            var styleValue = goog.string.trim(keyValue[2]);
            result[goog.string.toCamelCase(styleName.toLowerCase())] = styleValue
        }
    });
    return result
};
goog.style.toStyleAttribute = function(obj) {
    var buffer = [];
    goog.object.forEach(obj, function(value, key) {
        buffer.push(goog.string.toSelectorCase(key), ":", value, ";")
    });
    return buffer.join("")
};
goog.style.setFloat = function(el, value) {
    el.style[goog.userAgent.IE ? "styleFloat" : "cssFloat"] = value
};
goog.style.getFloat = function(el) {
    return el.style[goog.userAgent.IE ? "styleFloat" : "cssFloat"] || ""
};
goog.style.getScrollbarWidth = function(opt_className) {
    var outerDiv = goog.dom.createElement(goog.dom.TagName.DIV);
    if (opt_className) outerDiv.className = opt_className;
    outerDiv.style.cssText = "overflow:auto;" + "position:absolute;top:0;width:100px;height:100px";
    var innerDiv = goog.dom.createElement(goog.dom.TagName.DIV);
    goog.style.setSize(innerDiv, "200px", "200px");
    outerDiv.appendChild(innerDiv);
    goog.dom.appendChild(goog.dom.getDocument().body, outerDiv);
    var width = outerDiv.offsetWidth - outerDiv.clientWidth;
    goog.dom.removeNode(outerDiv);
    return width
};
goog.style.MATRIX_TRANSLATION_REGEX_ = new RegExp("matrix\\([0-9\\.\\-]+, [0-9\\.\\-]+, " + "[0-9\\.\\-]+, [0-9\\.\\-]+, " + "([0-9\\.\\-]+)p?x?, ([0-9\\.\\-]+)p?x?\\)");
goog.style.getCssTranslation = function(element) {
    var transform = goog.style.getComputedTransform(element);
    if (!transform) return new goog.math.Coordinate(0, 0);
    var matches = transform.match(goog.style.MATRIX_TRANSLATION_REGEX_);
    if (!matches) return new goog.math.Coordinate(0, 0);
    return new goog.math.Coordinate(parseFloat(matches[1]), parseFloat(matches[2]))
};
goog.provide("goog.events.EventHandler");
goog.require("goog.Disposable");
goog.require("goog.events");
goog.require("goog.object");
goog.forwardDeclare("goog.events.EventWrapper");
goog.events.EventHandler = function(opt_scope) {
    goog.Disposable.call(this);
    this.handler_ = opt_scope;
    this.keys_ = {}
};
goog.inherits(goog.events.EventHandler, goog.Disposable);
goog.events.EventHandler.typeArray_ = [];
goog.events.EventHandler.prototype.listen = function(src, type, opt_fn, opt_options) {
    var self = this;
    return self.listen_(src, type, opt_fn, opt_options)
};
goog.events.EventHandler.prototype.listenWithScope = function(src, type, fn, options, scope) {
    var self = this;
    return self.listen_(src, type, fn, options, scope)
};
goog.events.EventHandler.prototype.listen_ = function(src, type, opt_fn, opt_options, opt_scope) {
    var self = this;
    if (!goog.isArray(type)) {
        if (type) goog.events.EventHandler.typeArray_[0] = type.toString();
        type = goog.events.EventHandler.typeArray_
    }
    for (var i = 0; i < type.length; i++) {
        var listenerObj = goog.events.listen(src, type[i], opt_fn || self.handleEvent, opt_options || false, opt_scope || self.handler_ || self);
        if (!listenerObj) return self;
        var key = listenerObj.key;
        self.keys_[key] = listenerObj
    }
    return self
};
goog.events.EventHandler.prototype.listenOnce = function(src, type, opt_fn, opt_options) {
    var self = this;
    return self.listenOnce_(src, type, opt_fn, opt_options)
};
goog.events.EventHandler.prototype.listenOnceWithScope = function(src, type, fn, capture, scope) {
    var self = this;
    return self.listenOnce_(src, type, fn, capture, scope)
};
goog.events.EventHandler.prototype.listenOnce_ = function(src, type, opt_fn, opt_options, opt_scope) {
    var self = this;
    if (goog.isArray(type))
        for (var i = 0; i < type.length; i++) self.listenOnce_(src, type[i], opt_fn, opt_options, opt_scope);
    else {
        var listenerObj = goog.events.listenOnce(src, type, opt_fn || self.handleEvent, opt_options, opt_scope || self.handler_ || self);
        if (!listenerObj) return self;
        var key = listenerObj.key;
        self.keys_[key] = listenerObj
    }
    return self
};
goog.events.EventHandler.prototype.listenWithWrapper = function(src, wrapper, listener, opt_capt) {
    var self = this;
    return self.listenWithWrapper_(src, wrapper, listener, opt_capt)
};
goog.events.EventHandler.prototype.listenWithWrapperAndScope = function(src, wrapper, listener, capture, scope) {
    var self = this;
    return self.listenWithWrapper_(src, wrapper, listener, capture, scope)
};
goog.events.EventHandler.prototype.listenWithWrapper_ = function(src, wrapper, listener, opt_capt, opt_scope) {
    var self = this;
    wrapper.listen(src, listener, opt_capt, opt_scope || self.handler_ || self, self);
    return self
};
goog.events.EventHandler.prototype.getListenerCount = function() {
    var count = 0;
    for (var key in this.keys_)
        if (Object.prototype.hasOwnProperty.call(this.keys_, key)) count++;
    return count
};
goog.events.EventHandler.prototype.unlisten = function(src, type, opt_fn, opt_options, opt_scope) {
    var self = this;
    if (goog.isArray(type))
        for (var i = 0; i < type.length; i++) self.unlisten(src, type[i], opt_fn, opt_options, opt_scope);
    else {
        var capture = goog.isObject(opt_options) ? !!opt_options.capture : !!opt_options;
        var listener = goog.events.getListener(src, type, opt_fn || self.handleEvent, capture, opt_scope || self.handler_ || self);
        if (listener) {
            goog.events.unlistenByKey(listener);
            delete self.keys_[listener.key]
        }
    }
    return self
};
goog.events.EventHandler.prototype.unlistenWithWrapper = function(src, wrapper, listener, opt_capt, opt_scope) {
    var self = this;
    wrapper.unlisten(src, listener, opt_capt, opt_scope || self.handler_ || self, self);
    return self
};
goog.events.EventHandler.prototype.removeAll = function() {
    goog.object.forEach(this.keys_, function(listenerObj, key) {
        if (this.keys_.hasOwnProperty(key)) goog.events.unlistenByKey(listenerObj)
    }, this);
    this.keys_ = {}
};
goog.events.EventHandler.prototype.disposeInternal = function() {
    goog.events.EventHandler.superClass_.disposeInternal.call(this);
    this.removeAll()
};
goog.events.EventHandler.prototype.handleEvent = function(e) {
    throw new Error("EventHandler.handleEvent not implemented");
};
goog.provide("goog.events.EventTarget");
goog.require("goog.Disposable");
goog.require("goog.asserts");
goog.require("goog.events");
goog.require("goog.events.Event");
goog.require("goog.events.Listenable");
goog.require("goog.events.ListenerMap");
goog.require("goog.object");
goog.events.EventTarget = function() {
    goog.Disposable.call(this);
    this.eventTargetListeners_ = new goog.events.ListenerMap(this);
    this.actualEventTarget_ = this;
    this.parentEventTarget_ = null
};
goog.inherits(goog.events.EventTarget, goog.Disposable);
goog.events.Listenable.addImplementation(goog.events.EventTarget);
goog.events.EventTarget.MAX_ANCESTORS_ = 1E3;
goog.events.EventTarget.prototype.getParentEventTarget = function() {
    return this.parentEventTarget_
};
goog.events.EventTarget.prototype.setParentEventTarget = function(parent) {
    this.parentEventTarget_ = parent
};
goog.events.EventTarget.prototype.addEventListener = function(type, handler, opt_capture, opt_handlerScope) {
    goog.events.listen(this, type, handler, opt_capture, opt_handlerScope)
};
goog.events.EventTarget.prototype.removeEventListener = function(type, handler, opt_capture, opt_handlerScope) {
    goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope)
};
goog.events.EventTarget.prototype.dispatchEvent = function(e) {
    this.assertInitialized_();
    var ancestorsTree, ancestor = this.getParentEventTarget();
    if (ancestor) {
        ancestorsTree = [];
        var ancestorCount = 1;
        for (; ancestor; ancestor = ancestor.getParentEventTarget()) {
            ancestorsTree.push(ancestor);
            goog.asserts.assert(++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_, "infinite loop")
        }
    }
    return goog.events.EventTarget.dispatchEventInternal_(this.actualEventTarget_, e, ancestorsTree)
};
goog.events.EventTarget.prototype.disposeInternal = function() {
    goog.events.EventTarget.superClass_.disposeInternal.call(this);
    this.removeAllListeners();
    this.parentEventTarget_ = null
};
goog.events.EventTarget.prototype.listen = function(type, listener, opt_useCapture, opt_listenerScope) {
    this.assertInitialized_();
    return this.eventTargetListeners_.add(String(type), listener, false, opt_useCapture, opt_listenerScope)
};
goog.events.EventTarget.prototype.listenOnce = function(type, listener, opt_useCapture, opt_listenerScope) {
    return this.eventTargetListeners_.add(String(type), listener, true, opt_useCapture, opt_listenerScope)
};
goog.events.EventTarget.prototype.unlisten = function(type, listener, opt_useCapture, opt_listenerScope) {
    return this.eventTargetListeners_.remove(String(type), listener, opt_useCapture, opt_listenerScope)
};
goog.events.EventTarget.prototype.unlistenByKey = function(key) {
    return this.eventTargetListeners_.removeByKey(key)
};
goog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {
    if (!this.eventTargetListeners_) return 0;
    return this.eventTargetListeners_.removeAll(opt_type)
};
goog.events.EventTarget.prototype.fireListeners = function(type, capture, eventObject) {
    var listenerArray = this.eventTargetListeners_.listeners[String(type)];
    if (!listenerArray) return true;
    listenerArray = listenerArray.concat();
    var rv = true;
    for (var i = 0; i < listenerArray.length; ++i) {
        var listener = listenerArray[i];
        if (listener && !listener.removed && listener.capture == capture) {
            var listenerFn = listener.listener;
            var listenerHandler = listener.handler || listener.src;
            if (listener.callOnce) this.unlistenByKey(listener);
            rv = listenerFn.call(listenerHandler,
                eventObject) !== false && rv
        }
    }
    return rv && eventObject.returnValue_ != false
};
goog.events.EventTarget.prototype.getListeners = function(type, capture) {
    return this.eventTargetListeners_.getListeners(String(type), capture)
};
goog.events.EventTarget.prototype.getListener = function(type, listener, capture, opt_listenerScope) {
    return this.eventTargetListeners_.getListener(String(type), listener, capture, opt_listenerScope)
};
goog.events.EventTarget.prototype.hasListener = function(opt_type, opt_capture) {
    var id = goog.isDef(opt_type) ? String(opt_type) : undefined;
    return this.eventTargetListeners_.hasListener(id, opt_capture)
};
goog.events.EventTarget.prototype.setTargetForTesting = function(target) {
    this.actualEventTarget_ = target
};
goog.events.EventTarget.prototype.assertInitialized_ = function() {
    goog.asserts.assert(this.eventTargetListeners_, "Event target is not initialized. Did you call the superclass " + "(goog.events.EventTarget) constructor?")
};
goog.events.EventTarget.dispatchEventInternal_ = function(target, e, opt_ancestorsTree) {
    var type = e.type || e;
    if (goog.isString(e)) e = new goog.events.Event(e, target);
    else if (!(e instanceof goog.events.Event)) {
        var oldEvent = e;
        e = new goog.events.Event(type, target);
        goog.object.extend(e, oldEvent)
    } else e.target = e.target || target;
    var rv = true,
        currentTarget;
    if (opt_ancestorsTree)
        for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ && i >= 0; i--) {
            currentTarget = e.currentTarget = opt_ancestorsTree[i];
            rv = currentTarget.fireListeners(type,
                true, e) && rv
        }
    if (!e.propagationStopped_) {
        currentTarget = e.currentTarget = target;
        rv = currentTarget.fireListeners(type, true, e) && rv;
        if (!e.propagationStopped_) rv = currentTarget.fireListeners(type, false, e) && rv
    }
    if (opt_ancestorsTree)
        for (i = 0; !e.propagationStopped_ && i < opt_ancestorsTree.length; i++) {
            currentTarget = e.currentTarget = opt_ancestorsTree[i];
            rv = currentTarget.fireListeners(type, false, e) && rv
        }
    return rv
};
goog.provide("goog.ui.IdGenerator");
goog.ui.IdGenerator = function() {};
goog.addSingletonGetter(goog.ui.IdGenerator);
goog.ui.IdGenerator.prototype.nextId_ = 0;
goog.ui.IdGenerator.prototype.idPrefix_ = "";
goog.ui.IdGenerator.prototype.setIdPrefix = function(idPrefix) {
    this.idPrefix_ = idPrefix
};
goog.ui.IdGenerator.prototype.getNextUniqueId = function() {
    return this.idPrefix_ + ":" + (this.nextId_++).toString(36)
};
goog.provide("goog.ui.Component");
goog.provide("goog.ui.Component.Error");
goog.provide("goog.ui.Component.EventType");
goog.provide("goog.ui.Component.State");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.dom");
goog.require("goog.dom.NodeType");
goog.require("goog.dom.TagName");
goog.require("goog.events.EventHandler");
goog.require("goog.events.EventTarget");
goog.require("goog.object");
goog.require("goog.style");
goog.require("goog.ui.IdGenerator");
goog.ui.Component = function(opt_domHelper) {
    goog.events.EventTarget.call(this);
    this.dom_ = opt_domHelper || goog.dom.getDomHelper();
    this.rightToLeft_ = goog.ui.Component.defaultRightToLeft_;
    this.id_ = null;
    this.inDocument_ = false;
    this.element_ = null;
    this.googUiComponentHandler_ = void 0;
    this.model_ = null;
    this.parent_ = null;
    this.children_ = null;
    this.childIndex_ = null;
    this.wasDecorated_ = false;
    this.pointerEventsEnabled_ = false
};
goog.inherits(goog.ui.Component, goog.events.EventTarget);
goog.define("goog.ui.Component.ALLOW_DETACHED_DECORATION", false);
goog.ui.Component.prototype.idGenerator_ = goog.ui.IdGenerator.getInstance();
goog.define("goog.ui.Component.DEFAULT_BIDI_DIR", 0);
goog.ui.Component.defaultRightToLeft_ = goog.ui.Component.DEFAULT_BIDI_DIR == 1 ? false : goog.ui.Component.DEFAULT_BIDI_DIR == -1 ? true : null;
goog.ui.Component.EventType = {
    BEFORE_SHOW: "beforeshow",
    SHOW: "show",
    HIDE: "hide",
    DISABLE: "disable",
    ENABLE: "enable",
    HIGHLIGHT: "highlight",
    UNHIGHLIGHT: "unhighlight",
    ACTIVATE: "activate",
    DEACTIVATE: "deactivate",
    SELECT: "select",
    UNSELECT: "unselect",
    CHECK: "check",
    UNCHECK: "uncheck",
    FOCUS: "focus",
    BLUR: "blur",
    OPEN: "open",
    CLOSE: "close",
    ENTER: "enter",
    LEAVE: "leave",
    ACTION: "action",
    CHANGE: "change"
};
goog.ui.Component.Error = {
    NOT_SUPPORTED: "Method not supported",
    DECORATE_INVALID: "Invalid element to decorate",
    ALREADY_RENDERED: "Component already rendered",
    PARENT_UNABLE_TO_BE_SET: "Unable to set parent component",
    CHILD_INDEX_OUT_OF_BOUNDS: "Child component index out of bounds",
    NOT_OUR_CHILD: "Child is not in parent component",
    NOT_IN_DOCUMENT: "Operation not supported while component is not in document",
    STATE_INVALID: "Invalid component state"
};
goog.ui.Component.State = {
    ALL: 255,
    DISABLED: 1,
    HOVER: 2,
    ACTIVE: 4,
    SELECTED: 8,
    CHECKED: 16,
    FOCUSED: 32,
    OPENED: 64
};
goog.ui.Component.getStateTransitionEvent = function(state, isEntering) {
    switch (state) {
        case goog.ui.Component.State.DISABLED:
            return isEntering ? goog.ui.Component.EventType.DISABLE : goog.ui.Component.EventType.ENABLE;
        case goog.ui.Component.State.HOVER:
            return isEntering ? goog.ui.Component.EventType.HIGHLIGHT : goog.ui.Component.EventType.UNHIGHLIGHT;
        case goog.ui.Component.State.ACTIVE:
            return isEntering ? goog.ui.Component.EventType.ACTIVATE : goog.ui.Component.EventType.DEACTIVATE;
        case goog.ui.Component.State.SELECTED:
            return isEntering ?
                goog.ui.Component.EventType.SELECT : goog.ui.Component.EventType.UNSELECT;
        case goog.ui.Component.State.CHECKED:
            return isEntering ? goog.ui.Component.EventType.CHECK : goog.ui.Component.EventType.UNCHECK;
        case goog.ui.Component.State.FOCUSED:
            return isEntering ? goog.ui.Component.EventType.FOCUS : goog.ui.Component.EventType.BLUR;
        case goog.ui.Component.State.OPENED:
            return isEntering ? goog.ui.Component.EventType.OPEN : goog.ui.Component.EventType.CLOSE;
        default:
    }
    throw new Error(goog.ui.Component.Error.STATE_INVALID);
};
goog.ui.Component.setDefaultRightToLeft = function(rightToLeft) {
    goog.ui.Component.defaultRightToLeft_ = rightToLeft
};
goog.ui.Component.prototype.getId = function() {
    return this.id_ || (this.id_ = this.idGenerator_.getNextUniqueId())
};
goog.ui.Component.prototype.setId = function(id) {
    if (this.parent_ && this.parent_.childIndex_) {
        goog.object.remove(this.parent_.childIndex_, this.id_);
        goog.object.add(this.parent_.childIndex_, id, this)
    }
    this.id_ = id
};
goog.ui.Component.prototype.getElement = function() {
    return this.element_
};
goog.ui.Component.prototype.getElementStrict = function() {
    var el = this.element_;
    goog.asserts.assert(el, "Can not call getElementStrict before rendering/decorating.");
    return el
};
goog.ui.Component.prototype.setElementInternal = function(element) {
    this.element_ = element
};
goog.ui.Component.prototype.getElementsByClass = function(className) {
    return this.element_ ? this.dom_.getElementsByClass(className, this.element_) : []
};
goog.ui.Component.prototype.getElementByClass = function(className) {
    return this.element_ ? this.dom_.getElementByClass(className, this.element_) : null
};
goog.ui.Component.prototype.getRequiredElementByClass = function(className) {
    var el = this.getElementByClass(className);
    goog.asserts.assert(el, "Expected element in component with class: %s", className);
    return el
};
goog.ui.Component.prototype.getHandler = function() {
    var self = this;
    if (!self.googUiComponentHandler_) self.googUiComponentHandler_ = new goog.events.EventHandler(self);
    return goog.asserts.assert(self.googUiComponentHandler_)
};
goog.ui.Component.prototype.setParent = function(parent) {
    if (this == parent) throw new Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
    if (parent && this.parent_ && this.id_ && this.parent_.getChild(this.id_) && this.parent_ != parent) throw new Error(goog.ui.Component.Error.PARENT_UNABLE_TO_BE_SET);
    this.parent_ = parent;
    goog.ui.Component.superClass_.setParentEventTarget.call(this, parent)
};
goog.ui.Component.prototype.getParent = function() {
    return this.parent_
};
goog.ui.Component.prototype.setParentEventTarget = function(parent) {
    if (this.parent_ && this.parent_ != parent) throw new Error(goog.ui.Component.Error.NOT_SUPPORTED);
    goog.ui.Component.superClass_.setParentEventTarget.call(this, parent)
};
goog.ui.Component.prototype.getDomHelper = function() {
    return this.dom_
};
goog.ui.Component.prototype.isInDocument = function() {
    return this.inDocument_
};
goog.ui.Component.prototype.createDom = function() {
    this.element_ = this.dom_.createElement(goog.dom.TagName.DIV)
};
goog.ui.Component.prototype.render = function(opt_parentElement) {
    this.render_(opt_parentElement)
};
goog.ui.Component.prototype.renderBefore = function(sibling) {
    this.render_(sibling.parentNode, sibling)
};
goog.ui.Component.prototype.render_ = function(opt_parentElement, opt_beforeNode) {
    if (this.inDocument_) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    if (!this.element_) this.createDom();
    if (opt_parentElement) opt_parentElement.insertBefore(this.element_, opt_beforeNode || null);
    else this.dom_.getDocument().body.appendChild(this.element_);
    if (!this.parent_ || this.parent_.isInDocument()) this.enterDocument()
};
goog.ui.Component.prototype.decorate = function(element) {
    if (this.inDocument_) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    else if (element && this.canDecorate(element)) {
        this.wasDecorated_ = true;
        var doc = goog.dom.getOwnerDocument(element);
        if (!this.dom_ || this.dom_.getDocument() != doc) this.dom_ = goog.dom.getDomHelper(element);
        this.decorateInternal(element);
        if (!goog.ui.Component.ALLOW_DETACHED_DECORATION || goog.dom.contains(doc, element)) this.enterDocument()
    } else throw new Error(goog.ui.Component.Error.DECORATE_INVALID);
};
goog.ui.Component.prototype.canDecorate = function(element) {
    return true
};
goog.ui.Component.prototype.wasDecorated = function() {
    return this.wasDecorated_
};
goog.ui.Component.prototype.decorateInternal = function(element) {
    this.element_ = element
};
goog.ui.Component.prototype.enterDocument = function() {
    this.inDocument_ = true;
    this.forEachChild(function(child) {
        if (!child.isInDocument() && child.getElement()) child.enterDocument()
    })
};
goog.ui.Component.prototype.exitDocument = function() {
    this.forEachChild(function(child) {
        if (child.isInDocument()) child.exitDocument()
    });
    if (this.googUiComponentHandler_) this.googUiComponentHandler_.removeAll();
    this.inDocument_ = false
};
goog.ui.Component.prototype.disposeInternal = function() {
    if (this.inDocument_) this.exitDocument();
    if (this.googUiComponentHandler_) {
        this.googUiComponentHandler_.dispose();
        delete this.googUiComponentHandler_
    }
    this.forEachChild(function(child) {
        child.dispose()
    });
    if (!this.wasDecorated_ && this.element_) goog.dom.removeNode(this.element_);
    this.children_ = null;
    this.childIndex_ = null;
    this.element_ = null;
    this.model_ = null;
    this.parent_ = null;
    goog.ui.Component.superClass_.disposeInternal.call(this)
};
goog.ui.Component.prototype.makeId = function(idFragment) {
    return this.getId() + "." + idFragment
};
goog.ui.Component.prototype.makeIds = function(object) {
    var ids = {};
    for (var key in object) ids[key] = this.makeId(object[key]);
    return ids
};
goog.ui.Component.prototype.getModel = function() {
    return this.model_
};
goog.ui.Component.prototype.setModel = function(obj) {
    this.model_ = obj
};
goog.ui.Component.prototype.getFragmentFromId = function(id) {
    return id.substring(this.getId().length + 1)
};
goog.ui.Component.prototype.getElementByFragment = function(idFragment) {
    if (!this.inDocument_) throw new Error(goog.ui.Component.Error.NOT_IN_DOCUMENT);
    return this.dom_.getElement(this.makeId(idFragment))
};
goog.ui.Component.prototype.addChild = function(child, opt_render) {
    this.addChildAt(child, this.getChildCount(), opt_render)
};
goog.ui.Component.prototype.addChildAt = function(child, index, opt_render) {
    goog.asserts.assert(!!child, "Provided element must not be null.");
    if (child.inDocument_ && (opt_render || !this.inDocument_)) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    if (index < 0 || index > this.getChildCount()) throw new Error(goog.ui.Component.Error.CHILD_INDEX_OUT_OF_BOUNDS);
    if (!this.childIndex_ || !this.children_) {
        this.childIndex_ = {};
        this.children_ = []
    }
    if (child.getParent() == this) {
        goog.object.set(this.childIndex_, child.getId(),
            child);
        goog.array.remove(this.children_, child)
    } else goog.object.add(this.childIndex_, child.getId(), child);
    child.setParent(this);
    goog.array.insertAt(this.children_, child, index);
    if (child.inDocument_ && this.inDocument_ && child.getParent() == this) {
        var contentElement = this.getContentElement();
        var insertBeforeElement = contentElement.childNodes[index] || null;
        if (insertBeforeElement != child.getElement()) contentElement.insertBefore(child.getElement(), insertBeforeElement)
    } else if (opt_render) {
        if (!this.element_) this.createDom();
        var sibling = this.getChildAt(index + 1);
        child.render_(this.getContentElement(), sibling ? sibling.element_ : null)
    } else if (this.inDocument_ && !child.inDocument_ && child.element_ && child.element_.parentNode && child.element_.parentNode.nodeType == goog.dom.NodeType.ELEMENT) child.enterDocument()
};
goog.ui.Component.prototype.getContentElement = function() {
    return this.element_
};
goog.ui.Component.prototype.isRightToLeft = function() {
    if (this.rightToLeft_ == null) this.rightToLeft_ = goog.style.isRightToLeft(this.inDocument_ ? this.element_ : this.dom_.getDocument().body);
    return this.rightToLeft_
};
goog.ui.Component.prototype.setRightToLeft = function(rightToLeft) {
    if (this.inDocument_) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    this.rightToLeft_ = rightToLeft
};
goog.ui.Component.prototype.hasChildren = function() {
    return !!this.children_ && this.children_.length != 0
};
goog.ui.Component.prototype.getChildCount = function() {
    return this.children_ ? this.children_.length : 0
};
goog.ui.Component.prototype.getChildIds = function() {
    var ids = [];
    this.forEachChild(function(child) {
        ids.push(child.getId())
    });
    return ids
};
goog.ui.Component.prototype.getChild = function(id) {
    return this.childIndex_ && id ? goog.object.get(this.childIndex_, id) || null : null
};
goog.ui.Component.prototype.getChildAt = function(index) {
    return this.children_ ? this.children_[index] || null : null
};
goog.ui.Component.prototype.forEachChild = function(f, opt_obj) {
    if (this.children_) goog.array.forEach(this.children_, f, opt_obj)
};
goog.ui.Component.prototype.indexOfChild = function(child) {
    return this.children_ && child ? goog.array.indexOf(this.children_, child) : -1
};
goog.ui.Component.prototype.removeChild = function(child, opt_unrender) {
    if (child) {
        var id = goog.isString(child) ? child : child.getId();
        child = this.getChild(id);
        if (id && child) {
            goog.object.remove(this.childIndex_, id);
            goog.array.remove(this.children_, child);
            if (opt_unrender) {
                child.exitDocument();
                if (child.element_) goog.dom.removeNode(child.element_)
            }
            child.setParent(null)
        }
    }
    if (!child) throw new Error(goog.ui.Component.Error.NOT_OUR_CHILD);
    return child
};
goog.ui.Component.prototype.removeChildAt = function(index, opt_unrender) {
    return this.removeChild(this.getChildAt(index), opt_unrender)
};
goog.ui.Component.prototype.removeChildren = function(opt_unrender) {
    var removedChildren = [];
    while (this.hasChildren()) removedChildren.push(this.removeChildAt(0, opt_unrender));
    return removedChildren
};
goog.ui.Component.prototype.pointerEventsEnabled = function() {
    return this.pointerEventsEnabled_
};
goog.ui.Component.prototype.setPointerEventsEnabled = function(enable) {
    if (this.inDocument_) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    this.pointerEventsEnabled_ = enable
};
goog.provide("goog.a11y.aria.Role");
goog.a11y.aria.Role = {
    ALERT: "alert",
    ALERTDIALOG: "alertdialog",
    APPLICATION: "application",
    ARTICLE: "article",
    BANNER: "banner",
    BUTTON: "button",
    CHECKBOX: "checkbox",
    COLUMNHEADER: "columnheader",
    COMBOBOX: "combobox",
    COMPLEMENTARY: "complementary",
    CONTENTINFO: "contentinfo",
    DEFINITION: "definition",
    DIALOG: "dialog",
    DIRECTORY: "directory",
    DOCUMENT: "document",
    FORM: "form",
    GRID: "grid",
    GRIDCELL: "gridcell",
    GROUP: "group",
    HEADING: "heading",
    IMG: "img",
    LINK: "link",
    LIST: "list",
    LISTBOX: "listbox",
    LISTITEM: "listitem",
    LOG: "log",
    MAIN: "main",
    MARQUEE: "marquee",
    MATH: "math",
    MENU: "menu",
    MENUBAR: "menubar",
    MENU_ITEM: "menuitem",
    MENU_ITEM_CHECKBOX: "menuitemcheckbox",
    MENU_ITEM_RADIO: "menuitemradio",
    NAVIGATION: "navigation",
    NOTE: "note",
    OPTION: "option",
    PRESENTATION: "presentation",
    PROGRESSBAR: "progressbar",
    RADIO: "radio",
    RADIOGROUP: "radiogroup",
    REGION: "region",
    ROW: "row",
    ROWGROUP: "rowgroup",
    ROWHEADER: "rowheader",
    SCROLLBAR: "scrollbar",
    SEARCH: "search",
    SEPARATOR: "separator",
    SLIDER: "slider",
    SPINBUTTON: "spinbutton",
    STATUS: "status",
    TAB: "tab",
    TAB_LIST: "tablist",
    TAB_PANEL: "tabpanel",
    TEXTBOX: "textbox",
    TEXTINFO: "textinfo",
    TIMER: "timer",
    TOOLBAR: "toolbar",
    TOOLTIP: "tooltip",
    TREE: "tree",
    TREEGRID: "treegrid",
    TREEITEM: "treeitem"
};
goog.provide("goog.a11y.aria.AutoCompleteValues");
goog.provide("goog.a11y.aria.CheckedValues");
goog.provide("goog.a11y.aria.DropEffectValues");
goog.provide("goog.a11y.aria.ExpandedValues");
goog.provide("goog.a11y.aria.GrabbedValues");
goog.provide("goog.a11y.aria.InvalidValues");
goog.provide("goog.a11y.aria.LivePriority");
goog.provide("goog.a11y.aria.OrientationValues");
goog.provide("goog.a11y.aria.PressedValues");
goog.provide("goog.a11y.aria.RelevantValues");
goog.provide("goog.a11y.aria.SelectedValues");
goog.provide("goog.a11y.aria.SortValues");
goog.provide("goog.a11y.aria.State");
goog.a11y.aria.State = {
    ACTIVEDESCENDANT: "activedescendant",
    ATOMIC: "atomic",
    AUTOCOMPLETE: "autocomplete",
    BUSY: "busy",
    CHECKED: "checked",
    COLINDEX: "colindex",
    CONTROLS: "controls",
    DESCRIBEDBY: "describedby",
    DISABLED: "disabled",
    DROPEFFECT: "dropeffect",
    EXPANDED: "expanded",
    FLOWTO: "flowto",
    GRABBED: "grabbed",
    HASPOPUP: "haspopup",
    HIDDEN: "hidden",
    INVALID: "invalid",
    LABEL: "label",
    LABELLEDBY: "labelledby",
    LEVEL: "level",
    LIVE: "live",
    MULTILINE: "multiline",
    MULTISELECTABLE: "multiselectable",
    ORIENTATION: "orientation",
    OWNS: "owns",
    POSINSET: "posinset",
    PRESSED: "pressed",
    READONLY: "readonly",
    RELEVANT: "relevant",
    REQUIRED: "required",
    ROWINDEX: "rowindex",
    SELECTED: "selected",
    SETSIZE: "setsize",
    SORT: "sort",
    VALUEMAX: "valuemax",
    VALUEMIN: "valuemin",
    VALUENOW: "valuenow",
    VALUETEXT: "valuetext"
};
goog.a11y.aria.AutoCompleteValues = {
    INLINE: "inline",
    LIST: "list",
    BOTH: "both",
    NONE: "none"
};
goog.a11y.aria.DropEffectValues = {
    COPY: "copy",
    MOVE: "move",
    LINK: "link",
    EXECUTE: "execute",
    POPUP: "popup",
    NONE: "none"
};
goog.a11y.aria.LivePriority = {
    OFF: "off",
    POLITE: "polite",
    ASSERTIVE: "assertive"
};
goog.a11y.aria.OrientationValues = {
    VERTICAL: "vertical",
    HORIZONTAL: "horizontal"
};
goog.a11y.aria.RelevantValues = {
    ADDITIONS: "additions",
    REMOVALS: "removals",
    TEXT: "text",
    ALL: "all"
};
goog.a11y.aria.SortValues = {
    ASCENDING: "ascending",
    DESCENDING: "descending",
    NONE: "none",
    OTHER: "other"
};
goog.a11y.aria.CheckedValues = {
    TRUE: "true",
    FALSE: "false",
    MIXED: "mixed",
    UNDEFINED: "undefined"
};
goog.a11y.aria.ExpandedValues = {
    TRUE: "true",
    FALSE: "false",
    UNDEFINED: "undefined"
};
goog.a11y.aria.GrabbedValues = {
    TRUE: "true",
    FALSE: "false",
    UNDEFINED: "undefined"
};
goog.a11y.aria.InvalidValues = {
    FALSE: "false",
    TRUE: "true",
    GRAMMAR: "grammar",
    SPELLING: "spelling"
};
goog.a11y.aria.PressedValues = {
    TRUE: "true",
    FALSE: "false",
    MIXED: "mixed",
    UNDEFINED: "undefined"
};
goog.a11y.aria.SelectedValues = {
    TRUE: "true",
    FALSE: "false",
    UNDEFINED: "undefined"
};
goog.provide("goog.a11y.aria.datatables");
goog.require("goog.a11y.aria.State");
goog.require("goog.object");
goog.a11y.aria.DefaultStateValueMap_;
goog.a11y.aria.datatables.getDefaultValuesMap = function() {
    if (!goog.a11y.aria.DefaultStateValueMap_) goog.a11y.aria.DefaultStateValueMap_ = goog.object.create(goog.a11y.aria.State.ATOMIC, false, goog.a11y.aria.State.AUTOCOMPLETE, "none", goog.a11y.aria.State.DROPEFFECT, "none", goog.a11y.aria.State.HASPOPUP, false, goog.a11y.aria.State.LIVE, "off", goog.a11y.aria.State.MULTILINE, false, goog.a11y.aria.State.MULTISELECTABLE, false, goog.a11y.aria.State.ORIENTATION, "vertical", goog.a11y.aria.State.READONLY, false, goog.a11y.aria.State.RELEVANT,
        "additions text", goog.a11y.aria.State.REQUIRED, false, goog.a11y.aria.State.SORT, "none", goog.a11y.aria.State.BUSY, false, goog.a11y.aria.State.DISABLED, false, goog.a11y.aria.State.HIDDEN, false, goog.a11y.aria.State.INVALID, "false");
    return goog.a11y.aria.DefaultStateValueMap_
};
goog.provide("goog.a11y.aria");
goog.require("goog.a11y.aria.Role");
goog.require("goog.a11y.aria.State");
goog.require("goog.a11y.aria.datatables");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.dom");
goog.require("goog.dom.TagName");
goog.require("goog.object");
goog.require("goog.string");
goog.a11y.aria.ARIA_PREFIX_ = "aria-";
goog.a11y.aria.ROLE_ATTRIBUTE_ = "role";
goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_ = goog.object.createSet([goog.dom.TagName.A, goog.dom.TagName.AREA, goog.dom.TagName.BUTTON, goog.dom.TagName.HEAD, goog.dom.TagName.INPUT, goog.dom.TagName.LINK, goog.dom.TagName.MENU, goog.dom.TagName.META, goog.dom.TagName.OPTGROUP, goog.dom.TagName.OPTION, goog.dom.TagName.PROGRESS, goog.dom.TagName.STYLE, goog.dom.TagName.SELECT, goog.dom.TagName.SOURCE, goog.dom.TagName.TEXTAREA, goog.dom.TagName.TITLE, goog.dom.TagName.TRACK]);
goog.a11y.aria.CONTAINER_ROLES_ = [goog.a11y.aria.Role.COMBOBOX, goog.a11y.aria.Role.GRID, goog.a11y.aria.Role.GROUP, goog.a11y.aria.Role.LISTBOX, goog.a11y.aria.Role.MENU, goog.a11y.aria.Role.MENUBAR, goog.a11y.aria.Role.RADIOGROUP, goog.a11y.aria.Role.ROW, goog.a11y.aria.Role.ROWGROUP, goog.a11y.aria.Role.TAB_LIST, goog.a11y.aria.Role.TEXTBOX, goog.a11y.aria.Role.TOOLBAR, goog.a11y.aria.Role.TREE, goog.a11y.aria.Role.TREEGRID];
goog.a11y.aria.setRole = function(element, roleName) {
    if (!roleName) goog.a11y.aria.removeRole(element);
    else {
        if (goog.asserts.ENABLE_ASSERTS) goog.asserts.assert(goog.object.containsValue(goog.a11y.aria.Role, roleName), "No such ARIA role " + roleName);
        element.setAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_, roleName)
    }
};
goog.a11y.aria.getRole = function(element) {
    var role = element.getAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_);
    return role || null
};
goog.a11y.aria.removeRole = function(element) {
    element.removeAttribute(goog.a11y.aria.ROLE_ATTRIBUTE_)
};
goog.a11y.aria.setState = function(element, stateName, value) {
    if (goog.isArray(value)) value = value.join(" ");
    var attrStateName = goog.a11y.aria.getAriaAttributeName_(stateName);
    if (value === "" || value == undefined) {
        var defaultValueMap = goog.a11y.aria.datatables.getDefaultValuesMap();
        if (stateName in defaultValueMap) element.setAttribute(attrStateName, defaultValueMap[stateName]);
        else element.removeAttribute(attrStateName)
    } else element.setAttribute(attrStateName, value)
};
goog.a11y.aria.toggleState = function(el, attr) {
    var val = goog.a11y.aria.getState(el, attr);
    if (!goog.string.isEmptyOrWhitespace(goog.string.makeSafe(val)) && !(val == "true" || val == "false")) {
        goog.a11y.aria.removeState(el, attr);
        return
    }
    goog.a11y.aria.setState(el, attr, val == "true" ? "false" : "true")
};
goog.a11y.aria.removeState = function(element, stateName) {
    element.removeAttribute(goog.a11y.aria.getAriaAttributeName_(stateName))
};
goog.a11y.aria.getState = function(element, stateName) {
    var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
    var isNullOrUndefined = attr == null || attr == undefined;
    return isNullOrUndefined ? "" : String(attr)
};
goog.a11y.aria.getActiveDescendant = function(element) {
    var id = goog.a11y.aria.getState(element, goog.a11y.aria.State.ACTIVEDESCENDANT);
    return goog.dom.getOwnerDocument(element).getElementById(id)
};
goog.a11y.aria.setActiveDescendant = function(element, activeElement) {
    var id = "";
    if (activeElement) {
        id = activeElement.id;
        goog.asserts.assert(id, "The active element should have an id.")
    }
    goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, id)
};
goog.a11y.aria.getLabel = function(element) {
    return goog.a11y.aria.getState(element, goog.a11y.aria.State.LABEL)
};
goog.a11y.aria.setLabel = function(element, label) {
    goog.a11y.aria.setState(element, goog.a11y.aria.State.LABEL, label)
};
goog.a11y.aria.assertRoleIsSetInternalUtil = function(element, allowedRoles) {
    if (goog.a11y.aria.TAGS_WITH_ASSUMED_ROLES_[element.tagName]) return;
    var elementRole = goog.a11y.aria.getRole(element);
    goog.asserts.assert(elementRole != null, "The element ARIA role cannot be null.");
    goog.asserts.assert(goog.array.contains(allowedRoles, elementRole), "Non existing or incorrect role set for element." + 'The role set is "' + elementRole + '". The role should be any of "' + allowedRoles + '". Check the ARIA specification for more details ' +
        "http://www.w3.org/TR/wai-aria/roles.")
};
goog.a11y.aria.getStateBoolean = function(element, stateName) {
    var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
    goog.asserts.assert(goog.isBoolean(attr) || attr == null || attr == "true" || attr == "false");
    if (attr == null) return attr;
    return goog.isBoolean(attr) ? attr : attr == "true"
};
goog.a11y.aria.getStateNumber = function(element, stateName) {
    var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
    goog.asserts.assert((attr == null || !isNaN(Number(attr))) && !goog.isBoolean(attr));
    return attr == null ? null : Number(attr)
};
goog.a11y.aria.getStateString = function(element, stateName) {
    var attr = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
    goog.asserts.assert((attr == null || goog.isString(attr)) && (attr == "" || isNaN(Number(attr))) && attr != "true" && attr != "false");
    return attr == null || attr == "" ? null : attr
};
goog.a11y.aria.getStringArrayStateInternalUtil = function(element, stateName) {
    var attrValue = element.getAttribute(goog.a11y.aria.getAriaAttributeName_(stateName));
    return goog.a11y.aria.splitStringOnWhitespace_(attrValue)
};
goog.a11y.aria.hasState = function(element, stateName) {
    return element.hasAttribute(goog.a11y.aria.getAriaAttributeName_(stateName))
};
goog.a11y.aria.isContainerRole = function(element) {
    var role = goog.a11y.aria.getRole(element);
    return goog.array.contains(goog.a11y.aria.CONTAINER_ROLES_, role)
};
goog.a11y.aria.splitStringOnWhitespace_ = function(stringValue) {
    return stringValue ? stringValue.split(/\s+/) : []
};
goog.a11y.aria.getAriaAttributeName_ = function(ariaName) {
    if (goog.asserts.ENABLE_ASSERTS) {
        goog.asserts.assert(ariaName, "ARIA attribute cannot be empty.");
        goog.asserts.assert(goog.object.containsValue(goog.a11y.aria.State, ariaName), "No such ARIA attribute " + ariaName)
    }
    return goog.a11y.aria.ARIA_PREFIX_ + ariaName
};
goog.provide("goog.events.KeyCodes");
goog.require("goog.userAgent");
goog.forwardDeclare("goog.events.BrowserEvent");
goog.events.KeyCodes = {
    WIN_KEY_FF_LINUX: 0,
    MAC_ENTER: 3,
    BACKSPACE: 8,
    TAB: 9,
    NUM_CENTER: 12,
    ENTER: 13,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    PAUSE: 19,
    CAPS_LOCK: 20,
    ESC: 27,
    SPACE: 32,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PLUS_SIGN: 43,
    PRINT_SCREEN: 44,
    INSERT: 45,
    DELETE: 46,
    ZERO: 48,
    ONE: 49,
    TWO: 50,
    THREE: 51,
    FOUR: 52,
    FIVE: 53,
    SIX: 54,
    SEVEN: 55,
    EIGHT: 56,
    NINE: 57,
    FF_SEMICOLON: 59,
    FF_EQUALS: 61,
    FF_DASH: 173,
    FF_HASH: 163,
    QUESTION_MARK: 63,
    AT_SIGN: 64,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    META: 91,
    WIN_KEY_RIGHT: 92,
    CONTEXT_MENU: 93,
    NUM_ZERO: 96,
    NUM_ONE: 97,
    NUM_TWO: 98,
    NUM_THREE: 99,
    NUM_FOUR: 100,
    NUM_FIVE: 101,
    NUM_SIX: 102,
    NUM_SEVEN: 103,
    NUM_EIGHT: 104,
    NUM_NINE: 105,
    NUM_MULTIPLY: 106,
    NUM_PLUS: 107,
    NUM_MINUS: 109,
    NUM_PERIOD: 110,
    NUM_DIVISION: 111,
    F1: 112,
    F2: 113,
    F3: 114,
    F4: 115,
    F5: 116,
    F6: 117,
    F7: 118,
    F8: 119,
    F9: 120,
    F10: 121,
    F11: 122,
    F12: 123,
    NUMLOCK: 144,
    SCROLL_LOCK: 145,
    FIRST_MEDIA_KEY: 166,
    LAST_MEDIA_KEY: 183,
    SEMICOLON: 186,
    DASH: 189,
    EQUALS: 187,
    COMMA: 188,
    PERIOD: 190,
    SLASH: 191,
    APOSTROPHE: 192,
    TILDE: 192,
    SINGLE_QUOTE: 222,
    OPEN_SQUARE_BRACKET: 219,
    BACKSLASH: 220,
    CLOSE_SQUARE_BRACKET: 221,
    WIN_KEY: 224,
    MAC_FF_META: 224,
    MAC_WK_CMD_LEFT: 91,
    MAC_WK_CMD_RIGHT: 93,
    WIN_IME: 229,
    VK_NONAME: 252,
    PHANTOM: 255
};
goog.events.KeyCodes.isTextModifyingKeyEvent = function(e) {
    if (e.altKey && !e.ctrlKey || e.metaKey || e.keyCode >= goog.events.KeyCodes.F1 && e.keyCode <= goog.events.KeyCodes.F12) return false;
    switch (e.keyCode) {
        case goog.events.KeyCodes.ALT:
        case goog.events.KeyCodes.CAPS_LOCK:
        case goog.events.KeyCodes.CONTEXT_MENU:
        case goog.events.KeyCodes.CTRL:
        case goog.events.KeyCodes.DOWN:
        case goog.events.KeyCodes.END:
        case goog.events.KeyCodes.ESC:
        case goog.events.KeyCodes.HOME:
        case goog.events.KeyCodes.INSERT:
        case goog.events.KeyCodes.LEFT:
        case goog.events.KeyCodes.MAC_FF_META:
        case goog.events.KeyCodes.META:
        case goog.events.KeyCodes.NUMLOCK:
        case goog.events.KeyCodes.NUM_CENTER:
        case goog.events.KeyCodes.PAGE_DOWN:
        case goog.events.KeyCodes.PAGE_UP:
        case goog.events.KeyCodes.PAUSE:
        case goog.events.KeyCodes.PHANTOM:
        case goog.events.KeyCodes.PRINT_SCREEN:
        case goog.events.KeyCodes.RIGHT:
        case goog.events.KeyCodes.SCROLL_LOCK:
        case goog.events.KeyCodes.SHIFT:
        case goog.events.KeyCodes.UP:
        case goog.events.KeyCodes.VK_NONAME:
        case goog.events.KeyCodes.WIN_KEY:
        case goog.events.KeyCodes.WIN_KEY_RIGHT:
            return false;
        case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
            return !goog.userAgent.GECKO;
        default:
            return e.keyCode < goog.events.KeyCodes.FIRST_MEDIA_KEY || e.keyCode > goog.events.KeyCodes.LAST_MEDIA_KEY
    }
};
goog.events.KeyCodes.firesKeyPressEvent = function(keyCode, opt_heldKeyCode, opt_shiftKey, opt_ctrlKey, opt_altKey, opt_metaKey) {
    if (goog.userAgent.WEBKIT && !goog.userAgent.isVersionOrHigher("525")) return true;
    if (goog.userAgent.MAC && opt_altKey) return goog.events.KeyCodes.isCharacterKey(keyCode);
    if (opt_altKey && !opt_ctrlKey) return false;
    if (!goog.userAgent.GECKO) {
        if (goog.isNumber(opt_heldKeyCode)) opt_heldKeyCode = goog.events.KeyCodes.normalizeKeyCode(opt_heldKeyCode);
        var heldKeyIsModifier = opt_heldKeyCode == goog.events.KeyCodes.CTRL ||
            opt_heldKeyCode == goog.events.KeyCodes.ALT || goog.userAgent.MAC && opt_heldKeyCode == goog.events.KeyCodes.META;
        var modifiedShiftKey = opt_heldKeyCode == goog.events.KeyCodes.SHIFT && (opt_ctrlKey || opt_metaKey);
        if ((!opt_shiftKey || goog.userAgent.MAC) && heldKeyIsModifier || goog.userAgent.MAC && modifiedShiftKey) return false
    }
    if ((goog.userAgent.WEBKIT || goog.userAgent.EDGE) && opt_ctrlKey && opt_shiftKey) switch (keyCode) {
        case goog.events.KeyCodes.BACKSLASH:
        case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
        case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
        case goog.events.KeyCodes.TILDE:
        case goog.events.KeyCodes.SEMICOLON:
        case goog.events.KeyCodes.DASH:
        case goog.events.KeyCodes.EQUALS:
        case goog.events.KeyCodes.COMMA:
        case goog.events.KeyCodes.PERIOD:
        case goog.events.KeyCodes.SLASH:
        case goog.events.KeyCodes.APOSTROPHE:
        case goog.events.KeyCodes.SINGLE_QUOTE:
            return false
    }
    if (goog.userAgent.IE &&
        opt_ctrlKey && opt_heldKeyCode == keyCode) return false;
    switch (keyCode) {
        case goog.events.KeyCodes.ENTER:
            if (goog.userAgent.GECKO) {
                if (opt_metaKey || opt_altKey) return false;
                return !(opt_shiftKey && opt_ctrlKey)
            } else return true;
        case goog.events.KeyCodes.ESC:
            return !(goog.userAgent.WEBKIT || goog.userAgent.EDGE || goog.userAgent.GECKO)
    }
    if (goog.userAgent.GECKO && (opt_ctrlKey || opt_altKey || opt_metaKey)) return false;
    else return goog.events.KeyCodes.isCharacterKey(keyCode)
};
goog.events.KeyCodes.isCharacterKey = function(keyCode) {
    if (keyCode >= goog.events.KeyCodes.ZERO && keyCode <= goog.events.KeyCodes.NINE) return true;
    if (keyCode >= goog.events.KeyCodes.NUM_ZERO && keyCode <= goog.events.KeyCodes.NUM_MULTIPLY) return true;
    if (keyCode >= goog.events.KeyCodes.A && keyCode <= goog.events.KeyCodes.Z) return true;
    if ((goog.userAgent.WEBKIT || goog.userAgent.EDGE) && keyCode == 0) return true;
    switch (keyCode) {
        case goog.events.KeyCodes.SPACE:
        case goog.events.KeyCodes.PLUS_SIGN:
        case goog.events.KeyCodes.QUESTION_MARK:
        case goog.events.KeyCodes.AT_SIGN:
        case goog.events.KeyCodes.NUM_PLUS:
        case goog.events.KeyCodes.NUM_MINUS:
        case goog.events.KeyCodes.NUM_PERIOD:
        case goog.events.KeyCodes.NUM_DIVISION:
        case goog.events.KeyCodes.SEMICOLON:
        case goog.events.KeyCodes.FF_SEMICOLON:
        case goog.events.KeyCodes.DASH:
        case goog.events.KeyCodes.EQUALS:
        case goog.events.KeyCodes.FF_EQUALS:
        case goog.events.KeyCodes.COMMA:
        case goog.events.KeyCodes.PERIOD:
        case goog.events.KeyCodes.SLASH:
        case goog.events.KeyCodes.APOSTROPHE:
        case goog.events.KeyCodes.SINGLE_QUOTE:
        case goog.events.KeyCodes.OPEN_SQUARE_BRACKET:
        case goog.events.KeyCodes.BACKSLASH:
        case goog.events.KeyCodes.CLOSE_SQUARE_BRACKET:
        case goog.events.KeyCodes.FF_HASH:
            return true;
        default:
            return false
    }
};
goog.events.KeyCodes.normalizeKeyCode = function(keyCode) {
    if (goog.userAgent.GECKO) return goog.events.KeyCodes.normalizeGeckoKeyCode(keyCode);
    else if (goog.userAgent.MAC && goog.userAgent.WEBKIT) return goog.events.KeyCodes.normalizeMacWebKitKeyCode(keyCode);
    else return keyCode
};
goog.events.KeyCodes.normalizeGeckoKeyCode = function(keyCode) {
    switch (keyCode) {
        case goog.events.KeyCodes.FF_EQUALS:
            return goog.events.KeyCodes.EQUALS;
        case goog.events.KeyCodes.FF_SEMICOLON:
            return goog.events.KeyCodes.SEMICOLON;
        case goog.events.KeyCodes.FF_DASH:
            return goog.events.KeyCodes.DASH;
        case goog.events.KeyCodes.MAC_FF_META:
            return goog.events.KeyCodes.META;
        case goog.events.KeyCodes.WIN_KEY_FF_LINUX:
            return goog.events.KeyCodes.WIN_KEY;
        default:
            return keyCode
    }
};
goog.events.KeyCodes.normalizeMacWebKitKeyCode = function(keyCode) {
    switch (keyCode) {
        case goog.events.KeyCodes.MAC_WK_CMD_RIGHT:
            return goog.events.KeyCodes.META;
        default:
            return keyCode
    }
};
goog.provide("goog.events.KeyEvent");
goog.provide("goog.events.KeyHandler");
goog.provide("goog.events.KeyHandler.EventType");
goog.require("goog.events");
goog.require("goog.events.BrowserEvent");
goog.require("goog.events.EventTarget");
goog.require("goog.events.EventType");
goog.require("goog.events.KeyCodes");
goog.require("goog.userAgent");
goog.events.KeyHandler = function(opt_element, opt_capture) {
    goog.events.EventTarget.call(this);
    if (opt_element) this.attach(opt_element, opt_capture)
};
goog.inherits(goog.events.KeyHandler, goog.events.EventTarget);
goog.events.KeyHandler.prototype.element_ = null;
goog.events.KeyHandler.prototype.keyPressKey_ = null;
goog.events.KeyHandler.prototype.keyDownKey_ = null;
goog.events.KeyHandler.prototype.keyUpKey_ = null;
goog.events.KeyHandler.prototype.lastKey_ = -1;
goog.events.KeyHandler.prototype.keyCode_ = -1;
goog.events.KeyHandler.prototype.altKey_ = false;
goog.events.KeyHandler.EventType = {
    KEY: "key"
};
goog.events.KeyHandler.safariKey_ = {
    3: goog.events.KeyCodes.ENTER,
    12: goog.events.KeyCodes.NUMLOCK,
    63232: goog.events.KeyCodes.UP,
    63233: goog.events.KeyCodes.DOWN,
    63234: goog.events.KeyCodes.LEFT,
    63235: goog.events.KeyCodes.RIGHT,
    63236: goog.events.KeyCodes.F1,
    63237: goog.events.KeyCodes.F2,
    63238: goog.events.KeyCodes.F3,
    63239: goog.events.KeyCodes.F4,
    63240: goog.events.KeyCodes.F5,
    63241: goog.events.KeyCodes.F6,
    63242: goog.events.KeyCodes.F7,
    63243: goog.events.KeyCodes.F8,
    63244: goog.events.KeyCodes.F9,
    63245: goog.events.KeyCodes.F10,
    63246: goog.events.KeyCodes.F11,
    63247: goog.events.KeyCodes.F12,
    63248: goog.events.KeyCodes.PRINT_SCREEN,
    63272: goog.events.KeyCodes.DELETE,
    63273: goog.events.KeyCodes.HOME,
    63275: goog.events.KeyCodes.END,
    63276: goog.events.KeyCodes.PAGE_UP,
    63277: goog.events.KeyCodes.PAGE_DOWN,
    63289: goog.events.KeyCodes.NUMLOCK,
    63302: goog.events.KeyCodes.INSERT
};
goog.events.KeyHandler.keyIdentifier_ = {
    "Up": goog.events.KeyCodes.UP,
    "Down": goog.events.KeyCodes.DOWN,
    "Left": goog.events.KeyCodes.LEFT,
    "Right": goog.events.KeyCodes.RIGHT,
    "Enter": goog.events.KeyCodes.ENTER,
    "F1": goog.events.KeyCodes.F1,
    "F2": goog.events.KeyCodes.F2,
    "F3": goog.events.KeyCodes.F3,
    "F4": goog.events.KeyCodes.F4,
    "F5": goog.events.KeyCodes.F5,
    "F6": goog.events.KeyCodes.F6,
    "F7": goog.events.KeyCodes.F7,
    "F8": goog.events.KeyCodes.F8,
    "F9": goog.events.KeyCodes.F9,
    "F10": goog.events.KeyCodes.F10,
    "F11": goog.events.KeyCodes.F11,
    "F12": goog.events.KeyCodes.F12,
    "U+007F": goog.events.KeyCodes.DELETE,
    "Home": goog.events.KeyCodes.HOME,
    "End": goog.events.KeyCodes.END,
    "PageUp": goog.events.KeyCodes.PAGE_UP,
    "PageDown": goog.events.KeyCodes.PAGE_DOWN,
    "Insert": goog.events.KeyCodes.INSERT
};
goog.events.KeyHandler.USES_KEYDOWN_ = !goog.userAgent.WEBKIT || goog.userAgent.isVersionOrHigher("525");
goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_ = goog.userAgent.MAC && goog.userAgent.GECKO;
goog.events.KeyHandler.prototype.handleKeyDown_ = function(e) {
    if (goog.userAgent.WEBKIT || goog.userAgent.EDGE)
        if (this.lastKey_ == goog.events.KeyCodes.CTRL && !e.ctrlKey || this.lastKey_ == goog.events.KeyCodes.ALT && !e.altKey || goog.userAgent.MAC && this.lastKey_ == goog.events.KeyCodes.META && !e.metaKey) this.resetState();
    if (this.lastKey_ == -1)
        if (e.ctrlKey && e.keyCode != goog.events.KeyCodes.CTRL) this.lastKey_ = goog.events.KeyCodes.CTRL;
        else if (e.altKey && e.keyCode != goog.events.KeyCodes.ALT) this.lastKey_ = goog.events.KeyCodes.ALT;
    else if (e.metaKey && e.keyCode != goog.events.KeyCodes.META) this.lastKey_ = goog.events.KeyCodes.META;
    if (goog.events.KeyHandler.USES_KEYDOWN_ && !goog.events.KeyCodes.firesKeyPressEvent(e.keyCode, this.lastKey_, e.shiftKey, e.ctrlKey, e.altKey, e.metaKey)) this.handleEvent(e);
    else {
        this.keyCode_ = goog.events.KeyCodes.normalizeKeyCode(e.keyCode);
        if (goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_) this.altKey_ = e.altKey
    }
};
goog.events.KeyHandler.prototype.resetState = function() {
    this.lastKey_ = -1;
    this.keyCode_ = -1
};
goog.events.KeyHandler.prototype.handleKeyup_ = function(e) {
    this.resetState();
    this.altKey_ = e.altKey
};
goog.events.KeyHandler.prototype.handleEvent = function(e) {
    var be = e.getBrowserEvent();
    var keyCode, charCode;
    var altKey = be.altKey;
    if (goog.userAgent.IE && e.type == goog.events.EventType.KEYPRESS) {
        keyCode = this.keyCode_;
        charCode = keyCode != goog.events.KeyCodes.ENTER && keyCode != goog.events.KeyCodes.ESC ? be.keyCode : 0
    } else if ((goog.userAgent.WEBKIT || goog.userAgent.EDGE) && e.type == goog.events.EventType.KEYPRESS) {
        keyCode = this.keyCode_;
        charCode = be.charCode >= 0 && be.charCode < 63232 && goog.events.KeyCodes.isCharacterKey(keyCode) ?
            be.charCode : 0
    } else if (goog.userAgent.OPERA && !goog.userAgent.WEBKIT) {
        keyCode = this.keyCode_;
        charCode = goog.events.KeyCodes.isCharacterKey(keyCode) ? be.keyCode : 0
    } else {
        if (e.type == goog.events.EventType.KEYPRESS) {
            if (goog.events.KeyHandler.SAVE_ALT_FOR_KEYPRESS_) altKey = this.altKey_;
            if (be.keyCode == be.charCode)
                if (be.keyCode < 32) {
                    keyCode = be.keyCode;
                    charCode = 0
                } else {
                    keyCode = this.keyCode_;
                    charCode = be.charCode
                }
            else {
                keyCode = be.keyCode || this.keyCode_;
                charCode = be.charCode || 0
            }
        } else {
            keyCode = be.keyCode || this.keyCode_;
            charCode =
                be.charCode || 0
        }
        if (goog.userAgent.MAC && charCode == goog.events.KeyCodes.QUESTION_MARK && keyCode == goog.events.KeyCodes.WIN_KEY) keyCode = goog.events.KeyCodes.SLASH
    }
    keyCode = goog.events.KeyCodes.normalizeKeyCode(keyCode);
    var key = keyCode;
    if (keyCode)
        if (keyCode >= 63232 && keyCode in goog.events.KeyHandler.safariKey_) key = goog.events.KeyHandler.safariKey_[keyCode];
        else {
            if (keyCode == 25 && e.shiftKey) key = 9
        }
    else if (be.keyIdentifier && be.keyIdentifier in goog.events.KeyHandler.keyIdentifier_) key = goog.events.KeyHandler.keyIdentifier_[be.keyIdentifier];
    if (goog.userAgent.GECKO && goog.events.KeyHandler.USES_KEYDOWN_ && e.type == goog.events.EventType.KEYPRESS && !goog.events.KeyCodes.firesKeyPressEvent(key, this.lastKey_, e.shiftKey, e.ctrlKey, altKey, e.metaKey)) return;
    var repeat = key == this.lastKey_;
    this.lastKey_ = key;
    var event = new goog.events.KeyEvent(key, charCode, repeat, be);
    event.altKey = altKey;
    this.dispatchEvent(event)
};
goog.events.KeyHandler.prototype.getElement = function() {
    return this.element_
};
goog.events.KeyHandler.prototype.attach = function(element, opt_capture) {
    if (this.keyUpKey_) this.detach();
    this.element_ = element;
    this.keyPressKey_ = goog.events.listen(this.element_, goog.events.EventType.KEYPRESS, this, opt_capture);
    this.keyDownKey_ = goog.events.listen(this.element_, goog.events.EventType.KEYDOWN, this.handleKeyDown_, opt_capture, this);
    this.keyUpKey_ = goog.events.listen(this.element_, goog.events.EventType.KEYUP, this.handleKeyup_, opt_capture, this)
};
goog.events.KeyHandler.prototype.detach = function() {
    if (this.keyPressKey_) {
        goog.events.unlistenByKey(this.keyPressKey_);
        goog.events.unlistenByKey(this.keyDownKey_);
        goog.events.unlistenByKey(this.keyUpKey_);
        this.keyPressKey_ = null;
        this.keyDownKey_ = null;
        this.keyUpKey_ = null
    }
    this.element_ = null;
    this.lastKey_ = -1;
    this.keyCode_ = -1
};
goog.events.KeyHandler.prototype.disposeInternal = function() {
    goog.events.KeyHandler.superClass_.disposeInternal.call(this);
    this.detach()
};
goog.events.KeyEvent = function(keyCode, charCode, repeat, browserEvent) {
    goog.events.BrowserEvent.call(this, browserEvent);
    this.type = goog.events.KeyHandler.EventType.KEY;
    this.keyCode = keyCode;
    this.charCode = charCode;
    this.repeat = repeat
};
goog.inherits(goog.events.KeyEvent, goog.events.BrowserEvent);
goog.provide("goog.ui.ComponentUtil");
goog.require("goog.events.EventType");
goog.require("goog.events.PointerAsMouseEventType");
goog.ui.ComponentUtil.getMouseEventType = function(component) {
    return component.pointerEventsEnabled() ? goog.events.PointerAsMouseEventType : goog.events.EventType
};
goog.provide("goog.dom.classlist");
goog.require("goog.array");
goog.define("goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST", false);
goog.dom.classlist.get = function(element) {
    if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) return element.classList;
    var className = element.className;
    return goog.isString(className) && className.match(/\S+/g) || []
};
goog.dom.classlist.set = function(element, className) {
    element.className = className
};
goog.dom.classlist.contains = function(element, className) {
    if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) return element.classList.contains(className);
    return goog.array.contains(goog.dom.classlist.get(element), className)
};
goog.dom.classlist.add = function(element, className) {
    if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
        element.classList.add(className);
        return
    }
    if (!goog.dom.classlist.contains(element, className)) element.className += element.className.length > 0 ? " " + className : className
};
goog.dom.classlist.addAll = function(element, classesToAdd) {
    if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
        goog.array.forEach(classesToAdd, function(className) {
            goog.dom.classlist.add(element, className)
        });
        return
    }
    var classMap = {};
    goog.array.forEach(goog.dom.classlist.get(element), function(className) {
        classMap[className] = true
    });
    goog.array.forEach(classesToAdd, function(className) {
        classMap[className] = true
    });
    element.className = "";
    for (var className in classMap) element.className += element.className.length >
        0 ? " " + className : className
};
goog.dom.classlist.remove = function(element, className) {
    if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
        element.classList.remove(className);
        return
    }
    if (goog.dom.classlist.contains(element, className)) element.className = goog.array.filter(goog.dom.classlist.get(element), function(c) {
        return c != className
    }).join(" ")
};
goog.dom.classlist.removeAll = function(element, classesToRemove) {
    if (goog.dom.classlist.ALWAYS_USE_DOM_TOKEN_LIST || element.classList) {
        goog.array.forEach(classesToRemove, function(className) {
            goog.dom.classlist.remove(element, className)
        });
        return
    }
    element.className = goog.array.filter(goog.dom.classlist.get(element), function(className) {
        return !goog.array.contains(classesToRemove, className)
    }).join(" ")
};
goog.dom.classlist.enable = function(element, className, enabled) {
    if (enabled) goog.dom.classlist.add(element, className);
    else goog.dom.classlist.remove(element, className)
};
goog.dom.classlist.enableAll = function(element, classesToEnable, enabled) {
    var f = enabled ? goog.dom.classlist.addAll : goog.dom.classlist.removeAll;
    f(element, classesToEnable)
};
goog.dom.classlist.swap = function(element, fromClass, toClass) {
    if (goog.dom.classlist.contains(element, fromClass)) {
        goog.dom.classlist.remove(element, fromClass);
        goog.dom.classlist.add(element, toClass);
        return true
    }
    return false
};
goog.dom.classlist.toggle = function(element, className) {
    var add = !goog.dom.classlist.contains(element, className);
    goog.dom.classlist.enable(element, className, add);
    return add
};
goog.dom.classlist.addRemove = function(element, classToRemove, classToAdd) {
    goog.dom.classlist.remove(element, classToRemove);
    goog.dom.classlist.add(element, classToAdd)
};
goog.provide("goog.ui.registry");
goog.require("goog.asserts");
goog.require("goog.dom.classlist");
goog.forwardDeclare("goog.ui.Component");
goog.forwardDeclare("goog.ui.ControlRenderer");
goog.ui.registry.getDefaultRenderer = function(componentCtor) {
    var key;
    var rendererCtor;
    while (componentCtor) {
        key = goog.getUid(componentCtor);
        if (rendererCtor = goog.ui.registry.defaultRenderers_[key]) break;
        componentCtor = componentCtor.superClass_ ? componentCtor.superClass_.constructor : null
    }
    if (rendererCtor) return goog.isFunction(rendererCtor.getInstance) ? rendererCtor.getInstance() : new rendererCtor;
    return null
};
goog.ui.registry.setDefaultRenderer = function(componentCtor, rendererCtor) {
    if (!goog.isFunction(componentCtor)) throw new Error("Invalid component class " + componentCtor);
    if (!goog.isFunction(rendererCtor)) throw new Error("Invalid renderer class " + rendererCtor);
    var key = goog.getUid(componentCtor);
    goog.ui.registry.defaultRenderers_[key] = rendererCtor
};
goog.ui.registry.getDecoratorByClassName = function(className) {
    return className in goog.ui.registry.decoratorFunctions_ ? goog.ui.registry.decoratorFunctions_[className]() : null
};
goog.ui.registry.setDecoratorByClassName = function(className, decoratorFn) {
    if (!className) throw new Error("Invalid class name " + className);
    if (!goog.isFunction(decoratorFn)) throw new Error("Invalid decorator function " + decoratorFn);
    goog.ui.registry.decoratorFunctions_[className] = decoratorFn
};
goog.ui.registry.getDecorator = function(element) {
    var decorator;
    goog.asserts.assert(element);
    var classNames = goog.dom.classlist.get(element);
    for (var i = 0, len = classNames.length; i < len; i++)
        if (decorator = goog.ui.registry.getDecoratorByClassName(classNames[i])) return decorator;
    return null
};
goog.ui.registry.reset = function() {
    goog.ui.registry.defaultRenderers_ = {};
    goog.ui.registry.decoratorFunctions_ = {}
};
goog.ui.registry.defaultRenderers_ = {};
goog.ui.registry.decoratorFunctions_ = {};
goog.provide("goog.ui.ContainerRenderer");
goog.require("goog.a11y.aria");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.dom.NodeType");
goog.require("goog.dom.TagName");
goog.require("goog.dom.classlist");
goog.require("goog.string");
goog.require("goog.style");
goog.require("goog.ui.registry");
goog.require("goog.userAgent");
goog.forwardDeclare("goog.ui.Container");
goog.forwardDeclare("goog.ui.Container.Orientation");
goog.forwardDeclare("goog.ui.Control");
goog.ui.ContainerRenderer = function(opt_ariaRole) {
    this.ariaRole_ = opt_ariaRole
};
goog.addSingletonGetter(goog.ui.ContainerRenderer);
goog.ui.ContainerRenderer.getCustomRenderer = function(ctor, cssClassName) {
    var renderer = new ctor;
    renderer.getCssClass = function() {
        return cssClassName
    };
    return renderer
};
goog.ui.ContainerRenderer.CSS_CLASS = goog.getCssName("goog-container");
goog.ui.ContainerRenderer.prototype.getAriaRole = function() {
    return this.ariaRole_
};
goog.ui.ContainerRenderer.prototype.enableTabIndex = function(element, enable) {
    if (element) element.tabIndex = enable ? 0 : -1
};
goog.ui.ContainerRenderer.prototype.createDom = function(container) {
    return container.getDomHelper().createDom(goog.dom.TagName.DIV, this.getClassNames(container).join(" "))
};
goog.ui.ContainerRenderer.prototype.getContentElement = function(element) {
    return element
};
goog.ui.ContainerRenderer.prototype.canDecorate = function(element) {
    return element.tagName == "DIV"
};
goog.ui.ContainerRenderer.prototype.decorate = function(container, element) {
    if (element.id) container.setId(element.id);
    var baseClass = this.getCssClass();
    var hasBaseClass = false;
    var classNames = goog.dom.classlist.get(element);
    if (classNames) goog.array.forEach(classNames, function(className) {
        if (className == baseClass) hasBaseClass = true;
        else if (className) this.setStateFromClassName(container, className, baseClass)
    }, this);
    if (!hasBaseClass) goog.dom.classlist.add(element, baseClass);
    this.decorateChildren(container, this.getContentElement(element));
    return element
};
goog.ui.ContainerRenderer.prototype.setStateFromClassName = function(container, className, baseClass) {
    if (className == goog.getCssName(baseClass, "disabled")) container.setEnabled(false);
    else if (className == goog.getCssName(baseClass, "horizontal")) container.setOrientation(goog.ui.Container.Orientation.HORIZONTAL);
    else if (className == goog.getCssName(baseClass, "vertical")) container.setOrientation(goog.ui.Container.Orientation.VERTICAL)
};
goog.ui.ContainerRenderer.prototype.decorateChildren = function(container, element, opt_firstChild) {
    if (element) {
        var node = opt_firstChild || element.firstChild,
            next;
        while (node && node.parentNode == element) {
            next = node.nextSibling;
            if (node.nodeType == goog.dom.NodeType.ELEMENT) {
                var child = this.getDecoratorForChild(node);
                if (child) {
                    child.setElementInternal(node);
                    if (!container.isEnabled()) child.setEnabled(false);
                    container.addChild(child);
                    child.decorate(node)
                }
            } else if (!node.nodeValue || goog.string.trim(node.nodeValue) ==
                "") element.removeChild(node);
            node = next
        }
    }
};
goog.ui.ContainerRenderer.prototype.getDecoratorForChild = function(element) {
    return goog.ui.registry.getDecorator(element)
};
goog.ui.ContainerRenderer.prototype.initializeDom = function(container) {
    var elem = container.getElement();
    goog.asserts.assert(elem, "The container DOM element cannot be null.");
    goog.style.setUnselectable(elem, true, goog.userAgent.GECKO);
    if (goog.userAgent.IE) elem.hideFocus = true;
    var ariaRole = this.getAriaRole();
    if (ariaRole) goog.a11y.aria.setRole(elem, ariaRole)
};
goog.ui.ContainerRenderer.prototype.getKeyEventTarget = function(container) {
    return container.getElement()
};
goog.ui.ContainerRenderer.prototype.getCssClass = function() {
    return goog.ui.ContainerRenderer.CSS_CLASS
};
goog.ui.ContainerRenderer.prototype.getClassNames = function(container) {
    var baseClass = this.getCssClass();
    var isHorizontal = container.getOrientation() == goog.ui.Container.Orientation.HORIZONTAL;
    var classNames = [baseClass, isHorizontal ? goog.getCssName(baseClass, "horizontal") : goog.getCssName(baseClass, "vertical")];
    if (!container.isEnabled()) classNames.push(goog.getCssName(baseClass, "disabled"));
    return classNames
};
goog.ui.ContainerRenderer.prototype.getDefaultOrientation = function() {
    return goog.ui.Container.Orientation.VERTICAL
};
goog.provide("goog.ui.ControlContent");
goog.ui.ControlContent;
goog.provide("goog.ui.ControlRenderer");
goog.require("goog.a11y.aria");
goog.require("goog.a11y.aria.Role");
goog.require("goog.a11y.aria.State");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.dom");
goog.require("goog.dom.TagName");
goog.require("goog.dom.classlist");
goog.require("goog.object");
goog.require("goog.string");
goog.require("goog.style");
goog.require("goog.ui.Component");
goog.require("goog.ui.ControlContent");
goog.require("goog.userAgent");
goog.forwardDeclare("goog.ui.Control");
goog.ui.ControlRenderer = function() {};
goog.addSingletonGetter(goog.ui.ControlRenderer);
goog.tagUnsealableClass(goog.ui.ControlRenderer);
goog.ui.ControlRenderer.getCustomRenderer = function(ctor, cssClassName) {
    var renderer = new ctor;
    renderer.getCssClass = function() {
        return cssClassName
    };
    return renderer
};
goog.ui.ControlRenderer.CSS_CLASS = goog.getCssName("goog-control");
goog.ui.ControlRenderer.IE6_CLASS_COMBINATIONS = [];
goog.ui.ControlRenderer.ariaAttributeMap_;
goog.ui.ControlRenderer.TOGGLE_ARIA_STATE_MAP_ = goog.object.create(goog.a11y.aria.Role.BUTTON, goog.a11y.aria.State.PRESSED, goog.a11y.aria.Role.CHECKBOX, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.MENU_ITEM, goog.a11y.aria.State.SELECTED, goog.a11y.aria.Role.MENU_ITEM_CHECKBOX, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.MENU_ITEM_RADIO, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.RADIO, goog.a11y.aria.State.CHECKED, goog.a11y.aria.Role.TAB, goog.a11y.aria.State.SELECTED, goog.a11y.aria.Role.TREEITEM,
    goog.a11y.aria.State.SELECTED);
goog.ui.ControlRenderer.prototype.getAriaRole = function() {
    return undefined
};
goog.ui.ControlRenderer.prototype.createDom = function(control) {
    var element = control.getDomHelper().createDom(goog.dom.TagName.DIV, this.getClassNames(control).join(" "), control.getContent());
    return element
};
goog.ui.ControlRenderer.prototype.getContentElement = function(element) {
    return element
};
goog.ui.ControlRenderer.prototype.enableClassName = function(control, className, enable) {
    var element = control.getElement ? control.getElement() : control;
    if (element) {
        var classNames = [className];
        if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("7")) {
            classNames = this.getAppliedCombinedClassNames_(goog.dom.classlist.get(element), className);
            classNames.push(className)
        }
        goog.dom.classlist.enableAll(element, classNames, enable)
    }
};
goog.ui.ControlRenderer.prototype.enableExtraClassName = function(control, className, enable) {
    this.enableClassName(control, className, enable)
};
goog.ui.ControlRenderer.prototype.canDecorate = function(element) {
    return true
};
goog.ui.ControlRenderer.prototype.decorate = function(control, element) {
    if (element.id) control.setId(element.id);
    var contentElem = this.getContentElement(element);
    if (contentElem && contentElem.firstChild) control.setContentInternal(contentElem.firstChild.nextSibling ? goog.array.clone(contentElem.childNodes) : contentElem.firstChild);
    else control.setContentInternal(null);
    var state = 0;
    var rendererClassName = this.getCssClass();
    var structuralClassName = this.getStructuralCssClass();
    var hasRendererClassName = false;
    var hasStructuralClassName =
        false;
    var hasCombinedClassName = false;
    var classNames = goog.array.toArray(goog.dom.classlist.get(element));
    goog.array.forEach(classNames, function(className) {
        if (!hasRendererClassName && className == rendererClassName) {
            hasRendererClassName = true;
            if (structuralClassName == rendererClassName) hasStructuralClassName = true
        } else if (!hasStructuralClassName && className == structuralClassName) hasStructuralClassName = true;
        else state |= this.getStateFromClass(className);
        if (this.getStateFromClass(className) == goog.ui.Component.State.DISABLED) {
            goog.asserts.assertElement(contentElem);
            if (goog.dom.isFocusableTabIndex(contentElem)) goog.dom.setFocusableTabIndex(contentElem, false)
        }
    }, this);
    control.setStateInternal(state);
    if (!hasRendererClassName) {
        classNames.push(rendererClassName);
        if (structuralClassName == rendererClassName) hasStructuralClassName = true
    }
    if (!hasStructuralClassName) classNames.push(structuralClassName);
    var extraClassNames = control.getExtraClassNames();
    if (extraClassNames) classNames.push.apply(classNames, extraClassNames);
    if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher("7")) {
        var combinedClasses =
            this.getAppliedCombinedClassNames_(classNames);
        if (combinedClasses.length > 0) {
            classNames.push.apply(classNames, combinedClasses);
            hasCombinedClassName = true
        }
    }
    if (!hasRendererClassName || !hasStructuralClassName || extraClassNames || hasCombinedClassName) goog.dom.classlist.set(element, classNames.join(" "));
    return element
};
goog.ui.ControlRenderer.prototype.initializeDom = function(control) {
    if (control.isRightToLeft()) this.setRightToLeft(control.getElement(), true);
    if (control.isEnabled()) this.setFocusable(control, control.isVisible())
};
goog.ui.ControlRenderer.prototype.setAriaRole = function(element, opt_preferredRole) {
    var ariaRole = opt_preferredRole || this.getAriaRole();
    if (ariaRole) {
        goog.asserts.assert(element, "The element passed as a first parameter cannot be null.");
        var currentRole = goog.a11y.aria.getRole(element);
        if (ariaRole == currentRole) return;
        goog.a11y.aria.setRole(element, ariaRole)
    }
};
goog.ui.ControlRenderer.prototype.setAriaStates = function(control, element) {
    goog.asserts.assert(control);
    goog.asserts.assert(element);
    var ariaLabel = control.getAriaLabel();
    if (goog.isDefAndNotNull(ariaLabel)) this.setAriaLabel(element, ariaLabel);
    if (!control.isVisible()) goog.a11y.aria.setState(element, goog.a11y.aria.State.HIDDEN, !control.isVisible());
    if (!control.isEnabled()) this.updateAriaState(element, goog.ui.Component.State.DISABLED, !control.isEnabled());
    if (control.isSupportedState(goog.ui.Component.State.SELECTED)) this.updateAriaState(element,
        goog.ui.Component.State.SELECTED, control.isSelected());
    if (control.isSupportedState(goog.ui.Component.State.CHECKED)) this.updateAriaState(element, goog.ui.Component.State.CHECKED, control.isChecked());
    if (control.isSupportedState(goog.ui.Component.State.OPENED)) this.updateAriaState(element, goog.ui.Component.State.OPENED, control.isOpen())
};
goog.ui.ControlRenderer.prototype.setAriaLabel = function(element, ariaLabel) {
    goog.a11y.aria.setLabel(element, ariaLabel)
};
goog.ui.ControlRenderer.prototype.setAllowTextSelection = function(element, allow) {
    goog.style.setUnselectable(element, !allow, !goog.userAgent.IE && !goog.userAgent.OPERA)
};
goog.ui.ControlRenderer.prototype.setRightToLeft = function(element, rightToLeft) {
    this.enableClassName(element, goog.getCssName(this.getStructuralCssClass(), "rtl"), rightToLeft)
};
goog.ui.ControlRenderer.prototype.isFocusable = function(control) {
    var keyTarget;
    if (control.isSupportedState(goog.ui.Component.State.FOCUSED) && (keyTarget = control.getKeyEventTarget())) return goog.dom.isFocusableTabIndex(keyTarget);
    return false
};
goog.ui.ControlRenderer.prototype.setFocusable = function(control, focusable) {
    var keyTarget;
    if (control.isSupportedState(goog.ui.Component.State.FOCUSED) && (keyTarget = control.getKeyEventTarget())) {
        if (!focusable && control.isFocused()) {
            try {
                keyTarget.blur()
            } catch (e) {}
            if (control.isFocused()) control.handleBlur(null)
        }
        if (goog.dom.isFocusableTabIndex(keyTarget) != focusable) goog.dom.setFocusableTabIndex(keyTarget, focusable)
    }
};
goog.ui.ControlRenderer.prototype.setVisible = function(element, visible) {
    goog.style.setElementShown(element, visible);
    if (element) goog.a11y.aria.setState(element, goog.a11y.aria.State.HIDDEN, !visible)
};
goog.ui.ControlRenderer.prototype.setState = function(control, state, enable) {
    var element = control.getElement();
    if (element) {
        var className = this.getClassForState(state);
        if (className) this.enableClassName(control, className, enable);
        this.updateAriaState(element, state, enable)
    }
};
goog.ui.ControlRenderer.prototype.updateAriaState = function(element, state, enable) {
    if (!goog.ui.ControlRenderer.ariaAttributeMap_) goog.ui.ControlRenderer.ariaAttributeMap_ = goog.object.create(goog.ui.Component.State.DISABLED, goog.a11y.aria.State.DISABLED, goog.ui.Component.State.SELECTED, goog.a11y.aria.State.SELECTED, goog.ui.Component.State.CHECKED, goog.a11y.aria.State.CHECKED, goog.ui.Component.State.OPENED, goog.a11y.aria.State.EXPANDED);
    goog.asserts.assert(element, "The element passed as a first parameter cannot be null.");
    var ariaAttr = goog.ui.ControlRenderer.getAriaStateForAriaRole_(element, goog.ui.ControlRenderer.ariaAttributeMap_[state]);
    if (ariaAttr) goog.a11y.aria.setState(element, ariaAttr, enable)
};
goog.ui.ControlRenderer.getAriaStateForAriaRole_ = function(element, attr) {
    var role = goog.a11y.aria.getRole(element);
    if (!role) return attr;
    role = role;
    var matchAttr = goog.ui.ControlRenderer.TOGGLE_ARIA_STATE_MAP_[role] || attr;
    return goog.ui.ControlRenderer.isAriaState_(attr) ? matchAttr : attr
};
goog.ui.ControlRenderer.isAriaState_ = function(attr) {
    return attr == goog.a11y.aria.State.CHECKED || attr == goog.a11y.aria.State.SELECTED
};
goog.ui.ControlRenderer.prototype.setContent = function(element, content) {
    var contentElem = this.getContentElement(element);
    if (contentElem) {
        goog.dom.removeChildren(contentElem);
        if (content)
            if (goog.isString(content)) goog.dom.setTextContent(contentElem, content);
            else {
                var childHandler = function(child) {
                    if (child) {
                        var doc = goog.dom.getOwnerDocument(contentElem);
                        contentElem.appendChild(goog.isString(child) ? doc.createTextNode(child) : child)
                    }
                };
                if (goog.isArray(content)) goog.array.forEach(content, childHandler);
                else if (goog.isArrayLike(content) &&
                    !("nodeType" in content)) goog.array.forEach(goog.array.clone(content), childHandler);
                else childHandler(content)
            }
    }
};
goog.ui.ControlRenderer.prototype.getKeyEventTarget = function(control) {
    return control.getElement()
};
goog.ui.ControlRenderer.prototype.getCssClass = function() {
    return goog.ui.ControlRenderer.CSS_CLASS
};
goog.ui.ControlRenderer.prototype.getIe6ClassCombinations = function() {
    return []
};
goog.ui.ControlRenderer.prototype.getStructuralCssClass = function() {
    return this.getCssClass()
};
goog.ui.ControlRenderer.prototype.getClassNames = function(control) {
    var cssClass = this.getCssClass();
    var classNames = [cssClass];
    var structuralCssClass = this.getStructuralCssClass();
    if (structuralCssClass != cssClass) classNames.push(structuralCssClass);
    var classNamesForState = this.getClassNamesForState(control.getState());
    classNames.push.apply(classNames, classNamesForState);
    var extraClassNames = control.getExtraClassNames();
    if (extraClassNames) classNames.push.apply(classNames, extraClassNames);
    if (goog.userAgent.IE &&
        !goog.userAgent.isVersionOrHigher("7")) classNames.push.apply(classNames, this.getAppliedCombinedClassNames_(classNames));
    return classNames
};
goog.ui.ControlRenderer.prototype.getAppliedCombinedClassNames_ = function(classes, opt_includedClass) {
    var toAdd = [];
    if (opt_includedClass) classes = goog.array.concat(classes, [opt_includedClass]);
    goog.array.forEach(this.getIe6ClassCombinations(), function(combo) {
        if (goog.array.every(combo, goog.partial(goog.array.contains, classes)) && (!opt_includedClass || goog.array.contains(combo, opt_includedClass))) toAdd.push(combo.join("_"))
    });
    return toAdd
};
goog.ui.ControlRenderer.prototype.getClassNamesForState = function(state) {
    var classNames = [];
    while (state) {
        var mask = state & -state;
        classNames.push(this.getClassForState(mask));
        state &= ~mask
    }
    return classNames
};
goog.ui.ControlRenderer.prototype.getClassForState = function(state) {
    if (!this.classByState_) this.createClassByStateMap_();
    return this.classByState_[state]
};
goog.ui.ControlRenderer.prototype.getStateFromClass = function(className) {
    if (!this.stateByClass_) this.createStateByClassMap_();
    var state = parseInt(this.stateByClass_[className], 10);
    return isNaN(state) ? 0 : state
};
goog.ui.ControlRenderer.prototype.createClassByStateMap_ = function() {
    var baseClass = this.getStructuralCssClass();
    var isValidClassName = !goog.string.contains(goog.string.normalizeWhitespace(baseClass), " ");
    goog.asserts.assert(isValidClassName, "ControlRenderer has an invalid css class: '" + baseClass + "'");
    this.classByState_ = goog.object.create(goog.ui.Component.State.DISABLED, goog.getCssName(baseClass, "disabled"), goog.ui.Component.State.HOVER, goog.getCssName(baseClass, "hover"), goog.ui.Component.State.ACTIVE,
        goog.getCssName(baseClass, "active"), goog.ui.Component.State.SELECTED, goog.getCssName(baseClass, "selected"), goog.ui.Component.State.CHECKED, goog.getCssName(baseClass, "checked"), goog.ui.Component.State.FOCUSED, goog.getCssName(baseClass, "focused"), goog.ui.Component.State.OPENED, goog.getCssName(baseClass, "open"))
};
goog.ui.ControlRenderer.prototype.createStateByClassMap_ = function() {
    if (!this.classByState_) this.createClassByStateMap_();
    this.stateByClass_ = goog.object.transpose(this.classByState_)
};
goog.provide("goog.ui.Control");
goog.require("goog.Disposable");
goog.require("goog.array");
goog.require("goog.dom");
goog.require("goog.events.BrowserEvent");
goog.require("goog.events.Event");
goog.require("goog.events.EventHandler");
goog.require("goog.events.EventType");
goog.require("goog.events.KeyCodes");
goog.require("goog.events.KeyHandler");
goog.require("goog.string");
goog.require("goog.ui.Component");
goog.require("goog.ui.ComponentUtil");
goog.require("goog.ui.ControlContent");
goog.require("goog.ui.ControlRenderer");
goog.require("goog.ui.registry");
goog.require("goog.userAgent");
goog.ui.Control = function(opt_content, opt_renderer, opt_domHelper) {
    goog.ui.Component.call(this, opt_domHelper);
    this.renderer_ = opt_renderer || goog.ui.registry.getDefaultRenderer(this.constructor);
    this.setContentInternal(goog.isDef(opt_content) ? opt_content : null);
    this.ariaLabel_ = null;
    this.ieMouseEventSequenceSimulator_
};
goog.inherits(goog.ui.Control, goog.ui.Component);
goog.tagUnsealableClass(goog.ui.Control);
goog.ui.Control.registerDecorator = goog.ui.registry.setDecoratorByClassName;
goog.ui.Control.getDecorator = goog.ui.registry.getDecorator;
goog.ui.Control.prototype.renderer_;
goog.ui.Control.prototype.content_ = null;
goog.ui.Control.prototype.state_ = 0;
goog.ui.Control.prototype.supportedStates_ = goog.ui.Component.State.DISABLED | goog.ui.Component.State.HOVER | goog.ui.Component.State.ACTIVE | goog.ui.Component.State.FOCUSED;
goog.ui.Control.prototype.autoStates_ = goog.ui.Component.State.ALL;
goog.ui.Control.prototype.statesWithTransitionEvents_ = 0;
goog.ui.Control.prototype.visible_ = true;
goog.ui.Control.prototype.keyHandler_;
goog.ui.Control.prototype.extraClassNames_ = null;
goog.ui.Control.prototype.handleMouseEvents_ = true;
goog.ui.Control.prototype.allowTextSelection_ = false;
goog.ui.Control.prototype.preferredAriaRole_ = null;
goog.ui.Control.prototype.isHandleMouseEvents = function() {
    return this.handleMouseEvents_
};
goog.ui.Control.prototype.setHandleMouseEvents = function(enable) {
    if (this.isInDocument() && enable != this.handleMouseEvents_) this.enableMouseEventHandling_(enable);
    this.handleMouseEvents_ = enable
};
goog.ui.Control.prototype.getKeyEventTarget = function() {
    return this.renderer_.getKeyEventTarget(this)
};
goog.ui.Control.prototype.getKeyHandler = function() {
    return this.keyHandler_ || (this.keyHandler_ = new goog.events.KeyHandler)
};
goog.ui.Control.prototype.getRenderer = function() {
    return this.renderer_
};
goog.ui.Control.prototype.setRenderer = function(renderer) {
    if (this.isInDocument()) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    if (this.getElement()) this.setElementInternal(null);
    this.renderer_ = renderer
};
goog.ui.Control.prototype.getExtraClassNames = function() {
    return this.extraClassNames_
};
goog.ui.Control.prototype.addClassName = function(className) {
    if (className) {
        if (this.extraClassNames_) {
            if (!goog.array.contains(this.extraClassNames_, className)) this.extraClassNames_.push(className)
        } else this.extraClassNames_ = [className];
        this.renderer_.enableExtraClassName(this, className, true)
    }
};
goog.ui.Control.prototype.removeClassName = function(className) {
    if (className && this.extraClassNames_ && goog.array.remove(this.extraClassNames_, className)) {
        if (this.extraClassNames_.length == 0) this.extraClassNames_ = null;
        this.renderer_.enableExtraClassName(this, className, false)
    }
};
goog.ui.Control.prototype.enableClassName = function(className, enable) {
    if (enable) this.addClassName(className);
    else this.removeClassName(className)
};
goog.ui.Control.prototype.createDom = function() {
    var element = this.renderer_.createDom(this);
    this.setElementInternal(element);
    this.renderer_.setAriaRole(element, this.getPreferredAriaRole());
    if (!this.isAllowTextSelection()) this.renderer_.setAllowTextSelection(element, false);
    if (!this.isVisible()) this.renderer_.setVisible(element, false)
};
goog.ui.Control.prototype.getPreferredAriaRole = function() {
    return this.preferredAriaRole_
};
goog.ui.Control.prototype.setPreferredAriaRole = function(role) {
    this.preferredAriaRole_ = role
};
goog.ui.Control.prototype.getAriaLabel = function() {
    return this.ariaLabel_
};
goog.ui.Control.prototype.setAriaLabel = function(label) {
    this.ariaLabel_ = label;
    var element = this.getElement();
    if (element) this.renderer_.setAriaLabel(element, label)
};
goog.ui.Control.prototype.getContentElement = function() {
    return this.renderer_.getContentElement(this.getElement())
};
goog.ui.Control.prototype.canDecorate = function(element) {
    return this.renderer_.canDecorate(element)
};
goog.ui.Control.prototype.decorateInternal = function(element) {
    element = this.renderer_.decorate(this, element);
    this.setElementInternal(element);
    this.renderer_.setAriaRole(element, this.getPreferredAriaRole());
    if (!this.isAllowTextSelection()) this.renderer_.setAllowTextSelection(element, false);
    this.visible_ = element.style.display != "none"
};
goog.ui.Control.prototype.enterDocument = function() {
    goog.ui.Control.superClass_.enterDocument.call(this);
    this.renderer_.setAriaStates(this, this.getElementStrict());
    this.renderer_.initializeDom(this);
    if (this.supportedStates_ & ~goog.ui.Component.State.DISABLED) {
        if (this.isHandleMouseEvents()) this.enableMouseEventHandling_(true);
        if (this.isSupportedState(goog.ui.Component.State.FOCUSED)) {
            var keyTarget = this.getKeyEventTarget();
            if (keyTarget) {
                var keyHandler = this.getKeyHandler();
                keyHandler.attach(keyTarget);
                this.getHandler().listen(keyHandler, goog.events.KeyHandler.EventType.KEY, this.handleKeyEvent).listen(keyTarget, goog.events.EventType.FOCUS, this.handleFocus).listen(keyTarget, goog.events.EventType.BLUR, this.handleBlur)
            }
        }
    }
};
goog.ui.Control.prototype.enableMouseEventHandling_ = function(enable) {
    var MouseEventType = goog.ui.ComponentUtil.getMouseEventType(this);
    var handler = this.getHandler();
    var element = this.getElement();
    if (enable) {
        handler.listen(element, MouseEventType.MOUSEDOWN, this.handleMouseDown).listen(element, [MouseEventType.MOUSEUP, MouseEventType.MOUSECANCEL], this.handleMouseUp).listen(element, goog.events.EventType.MOUSEOVER, this.handleMouseOver).listen(element, goog.events.EventType.MOUSEOUT, this.handleMouseOut);
        if (this.pointerEventsEnabled()) handler.listen(element,
            goog.events.EventType.GOTPOINTERCAPTURE, this.preventPointerCapture_);
        if (this.handleContextMenu != goog.nullFunction) handler.listen(element, goog.events.EventType.CONTEXTMENU, this.handleContextMenu);
        if (goog.userAgent.IE) {
            if (!goog.userAgent.isVersionOrHigher(9)) handler.listen(element, goog.events.EventType.DBLCLICK, this.handleDblClick);
            if (!this.ieMouseEventSequenceSimulator_) {
                this.ieMouseEventSequenceSimulator_ = new goog.ui.Control.IeMouseEventSequenceSimulator_(this);
                this.registerDisposable(this.ieMouseEventSequenceSimulator_)
            }
        }
    } else {
        handler.unlisten(element,
            MouseEventType.MOUSEDOWN, this.handleMouseDown).unlisten(element, [MouseEventType.MOUSEUP, MouseEventType.MOUSECANCEL], this.handleMouseUp).unlisten(element, goog.events.EventType.MOUSEOVER, this.handleMouseOver).unlisten(element, goog.events.EventType.MOUSEOUT, this.handleMouseOut);
        if (this.pointerEventsEnabled()) handler.unlisten(element, goog.events.EventType.GOTPOINTERCAPTURE, this.preventPointerCapture_);
        if (this.handleContextMenu != goog.nullFunction) handler.unlisten(element, goog.events.EventType.CONTEXTMENU,
            this.handleContextMenu);
        if (goog.userAgent.IE) {
            if (!goog.userAgent.isVersionOrHigher(9)) handler.unlisten(element, goog.events.EventType.DBLCLICK, this.handleDblClick);
            goog.dispose(this.ieMouseEventSequenceSimulator_);
            this.ieMouseEventSequenceSimulator_ = null
        }
    }
};
goog.ui.Control.prototype.exitDocument = function() {
    goog.ui.Control.superClass_.exitDocument.call(this);
    if (this.keyHandler_) this.keyHandler_.detach();
    if (this.isVisible() && this.isEnabled()) this.renderer_.setFocusable(this, false)
};
goog.ui.Control.prototype.disposeInternal = function() {
    goog.ui.Control.superClass_.disposeInternal.call(this);
    if (this.keyHandler_) {
        this.keyHandler_.dispose();
        delete this.keyHandler_
    }
    delete this.renderer_;
    this.content_ = null;
    this.extraClassNames_ = null;
    this.ieMouseEventSequenceSimulator_ = null
};
goog.ui.Control.prototype.getContent = function() {
    return this.content_
};
goog.ui.Control.prototype.setContent = function(content) {
    this.renderer_.setContent(this.getElement(), content);
    this.setContentInternal(content)
};
goog.ui.Control.prototype.setContentInternal = function(content) {
    this.content_ = content
};
goog.ui.Control.prototype.getCaption = function() {
    var content = this.getContent();
    if (!content) return "";
    var caption = goog.isString(content) ? content : goog.isArray(content) ? goog.array.map(content, goog.dom.getRawTextContent).join("") : goog.dom.getTextContent(content);
    return goog.string.collapseBreakingSpaces(caption)
};
goog.ui.Control.prototype.setCaption = function(caption) {
    this.setContent(caption)
};
goog.ui.Control.prototype.setRightToLeft = function(rightToLeft) {
    goog.ui.Control.superClass_.setRightToLeft.call(this, rightToLeft);
    var element = this.getElement();
    if (element) this.renderer_.setRightToLeft(element, rightToLeft)
};
goog.ui.Control.prototype.isAllowTextSelection = function() {
    return this.allowTextSelection_
};
goog.ui.Control.prototype.setAllowTextSelection = function(allow) {
    this.allowTextSelection_ = allow;
    var element = this.getElement();
    if (element) this.renderer_.setAllowTextSelection(element, allow)
};
goog.ui.Control.prototype.isVisible = function() {
    return this.visible_
};
goog.ui.Control.prototype.setVisible = function(visible, opt_force) {
    if (opt_force || this.visible_ != visible && this.dispatchEvent(visible ? goog.ui.Component.EventType.SHOW : goog.ui.Component.EventType.HIDE)) {
        var element = this.getElement();
        if (element) this.renderer_.setVisible(element, visible);
        if (this.isEnabled()) this.renderer_.setFocusable(this, visible);
        this.visible_ = visible;
        return true
    }
    return false
};
goog.ui.Control.prototype.isEnabled = function() {
    return !this.hasState(goog.ui.Component.State.DISABLED)
};
goog.ui.Control.prototype.isParentDisabled_ = function() {
    var parent = this.getParent();
    return !!parent && typeof parent.isEnabled == "function" && !parent.isEnabled()
};
goog.ui.Control.prototype.setEnabled = function(enable) {
    if (!this.isParentDisabled_() && this.isTransitionAllowed(goog.ui.Component.State.DISABLED, !enable)) {
        if (!enable) {
            this.setActive(false);
            this.setHighlighted(false)
        }
        if (this.isVisible()) this.renderer_.setFocusable(this, enable);
        this.setState(goog.ui.Component.State.DISABLED, !enable, true)
    }
};
goog.ui.Control.prototype.isHighlighted = function() {
    return this.hasState(goog.ui.Component.State.HOVER)
};
goog.ui.Control.prototype.setHighlighted = function(highlight) {
    if (this.isTransitionAllowed(goog.ui.Component.State.HOVER, highlight)) this.setState(goog.ui.Component.State.HOVER, highlight)
};
goog.ui.Control.prototype.isActive = function() {
    return this.hasState(goog.ui.Component.State.ACTIVE)
};
goog.ui.Control.prototype.setActive = function(active) {
    if (this.isTransitionAllowed(goog.ui.Component.State.ACTIVE, active)) this.setState(goog.ui.Component.State.ACTIVE, active)
};
goog.ui.Control.prototype.isSelected = function() {
    return this.hasState(goog.ui.Component.State.SELECTED)
};
goog.ui.Control.prototype.setSelected = function(select) {
    if (this.isTransitionAllowed(goog.ui.Component.State.SELECTED, select)) this.setState(goog.ui.Component.State.SELECTED, select)
};
goog.ui.Control.prototype.isChecked = function() {
    return this.hasState(goog.ui.Component.State.CHECKED)
};
goog.ui.Control.prototype.setChecked = function(check) {
    if (this.isTransitionAllowed(goog.ui.Component.State.CHECKED, check)) this.setState(goog.ui.Component.State.CHECKED, check)
};
goog.ui.Control.prototype.isFocused = function() {
    return this.hasState(goog.ui.Component.State.FOCUSED)
};
goog.ui.Control.prototype.setFocused = function(focused) {
    if (this.isTransitionAllowed(goog.ui.Component.State.FOCUSED, focused)) this.setState(goog.ui.Component.State.FOCUSED, focused)
};
goog.ui.Control.prototype.isOpen = function() {
    return this.hasState(goog.ui.Component.State.OPENED)
};
goog.ui.Control.prototype.setOpen = function(open) {
    if (this.isTransitionAllowed(goog.ui.Component.State.OPENED, open)) this.setState(goog.ui.Component.State.OPENED, open)
};
goog.ui.Control.prototype.getState = function() {
    return this.state_
};
goog.ui.Control.prototype.hasState = function(state) {
    return !!(this.state_ & state)
};
goog.ui.Control.prototype.setState = function(state, enable, opt_calledFrom) {
    if (!opt_calledFrom && state == goog.ui.Component.State.DISABLED) {
        this.setEnabled(!enable);
        return
    }
    if (this.isSupportedState(state) && enable != this.hasState(state)) {
        this.renderer_.setState(this, state, enable);
        this.state_ = enable ? this.state_ | state : this.state_ & ~state
    }
};
goog.ui.Control.prototype.setStateInternal = function(state) {
    this.state_ = state
};
goog.ui.Control.prototype.isSupportedState = function(state) {
    return !!(this.supportedStates_ & state)
};
goog.ui.Control.prototype.setSupportedState = function(state, support) {
    if (this.isInDocument() && this.hasState(state) && !support) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    if (!support && this.hasState(state)) this.setState(state, false);
    this.supportedStates_ = support ? this.supportedStates_ | state : this.supportedStates_ & ~state
};
goog.ui.Control.prototype.isAutoState = function(state) {
    return !!(this.autoStates_ & state) && this.isSupportedState(state)
};
goog.ui.Control.prototype.setAutoStates = function(states, enable) {
    this.autoStates_ = enable ? this.autoStates_ | states : this.autoStates_ & ~states
};
goog.ui.Control.prototype.isDispatchTransitionEvents = function(state) {
    return !!(this.statesWithTransitionEvents_ & state) && this.isSupportedState(state)
};
goog.ui.Control.prototype.setDispatchTransitionEvents = function(states, enable) {
    this.statesWithTransitionEvents_ = enable ? this.statesWithTransitionEvents_ | states : this.statesWithTransitionEvents_ & ~states
};
goog.ui.Control.prototype.isTransitionAllowed = function(state, enable) {
    return this.isSupportedState(state) && this.hasState(state) != enable && (!(this.statesWithTransitionEvents_ & state) || this.dispatchEvent(goog.ui.Component.getStateTransitionEvent(state, enable))) && !this.isDisposed()
};
goog.ui.Control.prototype.handleMouseOver = function(e) {
    if (!goog.ui.Control.isMouseEventWithinElement_(e, this.getElement()) && this.dispatchEvent(goog.ui.Component.EventType.ENTER) && this.isEnabled() && this.isAutoState(goog.ui.Component.State.HOVER)) this.setHighlighted(true)
};
goog.ui.Control.prototype.handleMouseOut = function(e) {
    if (!goog.ui.Control.isMouseEventWithinElement_(e, this.getElement()) && this.dispatchEvent(goog.ui.Component.EventType.LEAVE)) {
        if (this.isAutoState(goog.ui.Component.State.ACTIVE)) this.setActive(false);
        if (this.isAutoState(goog.ui.Component.State.HOVER)) this.setHighlighted(false)
    }
};
goog.ui.Control.prototype.preventPointerCapture_ = function(e) {
    var elem = e.target;
    if (!!elem.releasePointerCapture) elem.releasePointerCapture(e.pointerId)
};
goog.ui.Control.prototype.handleContextMenu = goog.nullFunction;
goog.ui.Control.isMouseEventWithinElement_ = function(e, elem) {
    return !!e.relatedTarget && goog.dom.contains(elem, e.relatedTarget)
};
goog.ui.Control.prototype.handleMouseDown = function(e) {
    if (this.isEnabled()) {
        if (this.isAutoState(goog.ui.Component.State.HOVER)) this.setHighlighted(true);
        if (e.isMouseActionButton()) {
            if (this.isAutoState(goog.ui.Component.State.ACTIVE)) this.setActive(true);
            if (this.renderer_ && this.renderer_.isFocusable(this)) this.getKeyEventTarget().focus()
        }
    }
    if (!this.isAllowTextSelection() && e.isMouseActionButton()) e.preventDefault()
};
goog.ui.Control.prototype.handleMouseUp = function(e) {
    if (this.isEnabled()) {
        if (this.isAutoState(goog.ui.Component.State.HOVER)) this.setHighlighted(true);
        if (this.isActive() && this.performActionInternal(e) && this.isAutoState(goog.ui.Component.State.ACTIVE)) this.setActive(false)
    }
};
goog.ui.Control.prototype.handleDblClick = function(e) {
    if (this.isEnabled()) this.performActionInternal(e)
};
goog.ui.Control.prototype.performActionInternal = function(e) {
    if (this.isAutoState(goog.ui.Component.State.CHECKED)) this.setChecked(!this.isChecked());
    if (this.isAutoState(goog.ui.Component.State.SELECTED)) this.setSelected(true);
    if (this.isAutoState(goog.ui.Component.State.OPENED)) this.setOpen(!this.isOpen());
    var actionEvent = new goog.events.Event(goog.ui.Component.EventType.ACTION, this);
    if (e) {
        actionEvent.altKey = e.altKey;
        actionEvent.ctrlKey = e.ctrlKey;
        actionEvent.metaKey = e.metaKey;
        actionEvent.shiftKey = e.shiftKey;
        actionEvent.platformModifierKey = e.platformModifierKey
    }
    return this.dispatchEvent(actionEvent)
};
goog.ui.Control.prototype.handleFocus = function(e) {
    if (this.isAutoState(goog.ui.Component.State.FOCUSED)) this.setFocused(true)
};
goog.ui.Control.prototype.handleBlur = function(e) {
    if (this.isAutoState(goog.ui.Component.State.ACTIVE)) this.setActive(false);
    if (this.isAutoState(goog.ui.Component.State.FOCUSED)) this.setFocused(false)
};
goog.ui.Control.prototype.handleKeyEvent = function(e) {
    if (this.isVisible() && this.isEnabled() && this.handleKeyEventInternal(e)) {
        e.preventDefault();
        e.stopPropagation();
        return true
    }
    return false
};
goog.ui.Control.prototype.handleKeyEventInternal = function(e) {
    return e.keyCode == goog.events.KeyCodes.ENTER && this.performActionInternal(e)
};
goog.ui.registry.setDefaultRenderer(goog.ui.Control, goog.ui.ControlRenderer);
goog.ui.registry.setDecoratorByClassName(goog.ui.ControlRenderer.CSS_CLASS, function() {
    return new goog.ui.Control(null)
});
goog.ui.Control.IeMouseEventSequenceSimulator_ = function(control) {
    goog.ui.Control.IeMouseEventSequenceSimulator_.base(this, "constructor");
    this.control_ = control;
    this.clickExpected_ = false;
    this.handler_ = new goog.events.EventHandler(this);
    this.registerDisposable(this.handler_);
    var element = this.control_.getElementStrict();
    this.handler_.listen(element, goog.events.EventType.MOUSEDOWN, this.handleMouseDown_).listen(element, goog.events.EventType.MOUSEUP, this.handleMouseUp_).listen(element, goog.events.EventType.CLICK,
        this.handleClick_)
};
goog.inherits(goog.ui.Control.IeMouseEventSequenceSimulator_, goog.Disposable);
goog.ui.Control.IeMouseEventSequenceSimulator_.SYNTHETIC_EVENTS_ = !goog.userAgent.IE || goog.userAgent.isDocumentModeOrHigher(9);
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.handleMouseDown_ = function() {
    this.clickExpected_ = false
};
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.handleMouseUp_ = function() {
    this.clickExpected_ = true
};
goog.ui.Control.IeMouseEventSequenceSimulator_.makeLeftMouseEvent_ = function(e, typeArg) {
    if (!goog.ui.Control.IeMouseEventSequenceSimulator_.SYNTHETIC_EVENTS_) {
        e.button = goog.events.BrowserEvent.MouseButton.LEFT;
        e.type = typeArg;
        return e
    }
    var event = document.createEvent("MouseEvents");
    event.initMouseEvent(typeArg, e.bubbles, e.cancelable, e.view || null, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, goog.events.BrowserEvent.MouseButton.LEFT, e.relatedTarget || null);
    return event
};
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.handleClick_ = function(e) {
    if (this.clickExpected_) {
        this.clickExpected_ = false;
        return
    }
    var browserEvent = e;
    var event = browserEvent.getBrowserEvent();
    var origEventButton = event.button;
    var origEventType = event.type;
    var down = goog.ui.Control.IeMouseEventSequenceSimulator_.makeLeftMouseEvent_(event, goog.events.EventType.MOUSEDOWN);
    this.control_.handleMouseDown(new goog.events.BrowserEvent(down, browserEvent.currentTarget));
    var up = goog.ui.Control.IeMouseEventSequenceSimulator_.makeLeftMouseEvent_(event,
        goog.events.EventType.MOUSEUP);
    this.control_.handleMouseUp(new goog.events.BrowserEvent(up, browserEvent.currentTarget));
    if (goog.ui.Control.IeMouseEventSequenceSimulator_.SYNTHETIC_EVENTS_) return;
    event.button = origEventButton;
    event.type = origEventType
};
goog.ui.Control.IeMouseEventSequenceSimulator_.prototype.disposeInternal = function() {
    this.control_ = null;
    goog.ui.Control.IeMouseEventSequenceSimulator_.base(this, "disposeInternal")
};
goog.provide("goog.ui.Container");
goog.provide("goog.ui.Container.EventType");
goog.provide("goog.ui.Container.Orientation");
goog.require("goog.a11y.aria");
goog.require("goog.a11y.aria.State");
goog.require("goog.asserts");
goog.require("goog.dom");
goog.require("goog.events.EventType");
goog.require("goog.events.KeyCodes");
goog.require("goog.events.KeyHandler");
goog.require("goog.object");
goog.require("goog.style");
goog.require("goog.ui.Component");
goog.require("goog.ui.ComponentUtil");
goog.require("goog.ui.ContainerRenderer");
goog.require("goog.ui.Control");
goog.ui.Container = function(opt_orientation, opt_renderer, opt_domHelper) {
    goog.ui.Component.call(this, opt_domHelper);
    this.renderer_ = opt_renderer || goog.ui.ContainerRenderer.getInstance();
    this.orientation_ = opt_orientation || this.renderer_.getDefaultOrientation()
};
goog.inherits(goog.ui.Container, goog.ui.Component);
goog.tagUnsealableClass(goog.ui.Container);
goog.ui.Container.EventType = {
    AFTER_SHOW: "aftershow",
    AFTER_HIDE: "afterhide"
};
goog.ui.Container.Orientation = {
    HORIZONTAL: "horizontal",
    VERTICAL: "vertical"
};
goog.ui.Container.prototype.keyEventTarget_ = null;
goog.ui.Container.prototype.keyHandler_ = null;
goog.ui.Container.prototype.renderer_ = null;
goog.ui.Container.prototype.orientation_ = null;
goog.ui.Container.prototype.visible_ = true;
goog.ui.Container.prototype.enabled_ = true;
goog.ui.Container.prototype.focusable_ = true;
goog.ui.Container.prototype.highlightedIndex_ = -1;
goog.ui.Container.prototype.openItem_ = null;
goog.ui.Container.prototype.mouseButtonPressed_ = false;
goog.ui.Container.prototype.allowFocusableChildren_ = false;
goog.ui.Container.prototype.openFollowsHighlight_ = true;
goog.ui.Container.prototype.childElementIdMap_ = null;
goog.ui.Container.prototype.getKeyEventTarget = function() {
    return this.keyEventTarget_ || this.renderer_.getKeyEventTarget(this)
};
goog.ui.Container.prototype.setKeyEventTarget = function(element) {
    if (this.focusable_) {
        var oldTarget = this.getKeyEventTarget();
        var inDocument = this.isInDocument();
        this.keyEventTarget_ = element;
        var newTarget = this.getKeyEventTarget();
        if (inDocument) {
            this.keyEventTarget_ = oldTarget;
            this.enableFocusHandling_(false);
            this.keyEventTarget_ = element;
            this.getKeyHandler().attach(newTarget);
            this.enableFocusHandling_(true)
        }
    } else throw new Error("Can't set key event target for container " + "that doesn't support keyboard focus!");
};
goog.ui.Container.prototype.getKeyHandler = function() {
    return this.keyHandler_ || (this.keyHandler_ = new goog.events.KeyHandler(this.getKeyEventTarget()))
};
goog.ui.Container.prototype.getRenderer = function() {
    return this.renderer_
};
goog.ui.Container.prototype.setRenderer = function(renderer) {
    if (this.getElement()) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    this.renderer_ = renderer
};
goog.ui.Container.prototype.createDom = function() {
    this.setElementInternal(this.renderer_.createDom(this))
};
goog.ui.Container.prototype.getContentElement = function() {
    return this.renderer_.getContentElement(this.getElement())
};
goog.ui.Container.prototype.canDecorate = function(element) {
    return this.renderer_.canDecorate(element)
};
goog.ui.Container.prototype.decorateInternal = function(element) {
    this.setElementInternal(this.renderer_.decorate(this, element));
    if (element.style.display == "none") this.visible_ = false
};
goog.ui.Container.prototype.enterDocument = function() {
    goog.ui.Container.superClass_.enterDocument.call(this);
    this.forEachChild(function(child) {
        if (child.isInDocument()) this.registerChildId_(child)
    }, this);
    var elem = this.getElement();
    this.renderer_.initializeDom(this);
    this.setVisible(this.visible_, true);
    var MouseEventType = goog.ui.ComponentUtil.getMouseEventType(this);
    this.getHandler().listen(this, goog.ui.Component.EventType.ENTER, this.handleEnterItem).listen(this, goog.ui.Component.EventType.HIGHLIGHT,
        this.handleHighlightItem).listen(this, goog.ui.Component.EventType.UNHIGHLIGHT, this.handleUnHighlightItem).listen(this, goog.ui.Component.EventType.OPEN, this.handleOpenItem).listen(this, goog.ui.Component.EventType.CLOSE, this.handleCloseItem).listen(elem, MouseEventType.MOUSEDOWN, this.handleMouseDown).listen(goog.dom.getOwnerDocument(elem), [MouseEventType.MOUSEUP, MouseEventType.MOUSECANCEL], this.handleDocumentMouseUp).listen(elem, [MouseEventType.MOUSEDOWN, MouseEventType.MOUSEUP, MouseEventType.MOUSECANCEL,
        goog.events.EventType.MOUSEOVER, goog.events.EventType.MOUSEOUT, goog.events.EventType.CONTEXTMENU
    ], this.handleChildMouseEvents);
    if (this.pointerEventsEnabled()) this.getHandler().listen(elem, goog.events.EventType.GOTPOINTERCAPTURE, this.preventPointerCapture_);
    if (this.isFocusable()) this.enableFocusHandling_(true)
};
goog.ui.Container.prototype.preventPointerCapture_ = function(e) {
    var elem = e.target;
    if (!!elem.releasePointerCapture) elem.releasePointerCapture(e.pointerId)
};
goog.ui.Container.prototype.enableFocusHandling_ = function(enable) {
    var handler = this.getHandler();
    var keyTarget = this.getKeyEventTarget();
    if (enable) handler.listen(keyTarget, goog.events.EventType.FOCUS, this.handleFocus).listen(keyTarget, goog.events.EventType.BLUR, this.handleBlur).listen(this.getKeyHandler(), goog.events.KeyHandler.EventType.KEY, this.handleKeyEvent);
    else handler.unlisten(keyTarget, goog.events.EventType.FOCUS, this.handleFocus).unlisten(keyTarget, goog.events.EventType.BLUR, this.handleBlur).unlisten(this.getKeyHandler(),
        goog.events.KeyHandler.EventType.KEY, this.handleKeyEvent)
};
goog.ui.Container.prototype.exitDocument = function() {
    this.setHighlightedIndex(-1);
    if (this.openItem_) this.openItem_.setOpen(false);
    this.mouseButtonPressed_ = false;
    goog.ui.Container.superClass_.exitDocument.call(this)
};
goog.ui.Container.prototype.disposeInternal = function() {
    goog.ui.Container.superClass_.disposeInternal.call(this);
    if (this.keyHandler_) {
        this.keyHandler_.dispose();
        this.keyHandler_ = null
    }
    this.keyEventTarget_ = null;
    this.childElementIdMap_ = null;
    this.openItem_ = null;
    this.renderer_ = null
};
goog.ui.Container.prototype.handleEnterItem = function(e) {
    return true
};
goog.ui.Container.prototype.handleHighlightItem = function(e) {
    var index = this.indexOfChild(e.target);
    if (index > -1 && index != this.highlightedIndex_) {
        var item = this.getHighlighted();
        if (item) item.setHighlighted(false);
        this.highlightedIndex_ = index;
        item = this.getHighlighted();
        if (this.isMouseButtonPressed()) item.setActive(true);
        if (this.openFollowsHighlight_ && this.openItem_ && item != this.openItem_)
            if (item.isSupportedState(goog.ui.Component.State.OPENED)) item.setOpen(true);
            else this.openItem_.setOpen(false)
    }
    var element =
        this.getElement();
    goog.asserts.assert(element, "The DOM element for the container cannot be null.");
    if (e.target.getElement() != null) goog.a11y.aria.setState(element, goog.a11y.aria.State.ACTIVEDESCENDANT, e.target.getElement().id)
};
goog.ui.Container.prototype.handleUnHighlightItem = function(e) {
    if (e.target == this.getHighlighted()) this.highlightedIndex_ = -1;
    var element = this.getElement();
    goog.asserts.assert(element, "The DOM element for the container cannot be null.");
    goog.a11y.aria.removeState(element, goog.a11y.aria.State.ACTIVEDESCENDANT)
};
goog.ui.Container.prototype.handleOpenItem = function(e) {
    var item = e.target;
    if (item && item != this.openItem_ && item.getParent() == this) {
        if (this.openItem_) this.openItem_.setOpen(false);
        this.openItem_ = item
    }
};
goog.ui.Container.prototype.handleCloseItem = function(e) {
    if (e.target == this.openItem_) this.openItem_ = null;
    var element = this.getElement();
    var targetEl = e.target.getElement();
    if (element && e.target.isHighlighted() && targetEl) goog.a11y.aria.setActiveDescendant(element, targetEl)
};
goog.ui.Container.prototype.handleMouseDown = function(e) {
    if (this.enabled_) this.setMouseButtonPressed(true);
    var keyTarget = this.getKeyEventTarget();
    if (keyTarget && goog.dom.isFocusableTabIndex(keyTarget)) keyTarget.focus();
    else e.preventDefault()
};
goog.ui.Container.prototype.handleDocumentMouseUp = function(e) {
    this.setMouseButtonPressed(false)
};
goog.ui.Container.prototype.handleChildMouseEvents = function(e) {
    var MouseEventType = goog.ui.ComponentUtil.getMouseEventType(this);
    var control = this.getOwnerControl(e.target);
    if (control) switch (e.type) {
        case MouseEventType.MOUSEDOWN:
            control.handleMouseDown(e);
            break;
        case MouseEventType.MOUSEUP:
        case MouseEventType.MOUSECANCEL:
            control.handleMouseUp(e);
            break;
        case goog.events.EventType.MOUSEOVER:
            control.handleMouseOver(e);
            break;
        case goog.events.EventType.MOUSEOUT:
            control.handleMouseOut(e);
            break;
        case goog.events.EventType.CONTEXTMENU:
            control.handleContextMenu(e);
            break
    }
};
goog.ui.Container.prototype.getOwnerControl = function(node) {
    if (this.childElementIdMap_) {
        var elem = this.getElement();
        while (node && node !== elem) {
            var id = node.id;
            if (id in this.childElementIdMap_) return this.childElementIdMap_[id];
            node = node.parentNode
        }
    }
    return null
};
goog.ui.Container.prototype.handleFocus = function(e) {};
goog.ui.Container.prototype.handleBlur = function(e) {
    this.setHighlightedIndex(-1);
    this.setMouseButtonPressed(false);
    if (this.openItem_) this.openItem_.setOpen(false)
};
goog.ui.Container.prototype.handleKeyEvent = function(e) {
    if (this.isEnabled() && this.isVisible() && (this.getChildCount() != 0 || this.keyEventTarget_) && this.handleKeyEventInternal(e)) {
        e.preventDefault();
        e.stopPropagation();
        return true
    }
    return false
};
goog.ui.Container.prototype.handleKeyEventInternal = function(e) {
    var highlighted = this.getHighlighted();
    if (highlighted && typeof highlighted.handleKeyEvent == "function" && highlighted.handleKeyEvent(e)) return true;
    if (this.openItem_ && this.openItem_ != highlighted && typeof this.openItem_.handleKeyEvent == "function" && this.openItem_.handleKeyEvent(e)) return true;
    if (e.shiftKey || e.ctrlKey || e.metaKey || e.altKey) return false;
    switch (e.keyCode) {
        case goog.events.KeyCodes.ESC:
            if (this.isFocusable()) this.getKeyEventTarget().blur();
            else return false;
            break;
        case goog.events.KeyCodes.HOME:
            this.highlightFirst();
            break;
        case goog.events.KeyCodes.END:
            this.highlightLast();
            break;
        case goog.events.KeyCodes.UP:
            if (this.orientation_ == goog.ui.Container.Orientation.VERTICAL) this.highlightPrevious();
            else return false;
            break;
        case goog.events.KeyCodes.LEFT:
            if (this.orientation_ == goog.ui.Container.Orientation.HORIZONTAL)
                if (this.isRightToLeft()) this.highlightNext();
                else this.highlightPrevious();
            else return false;
            break;
        case goog.events.KeyCodes.DOWN:
            if (this.orientation_ ==
                goog.ui.Container.Orientation.VERTICAL) this.highlightNext();
            else return false;
            break;
        case goog.events.KeyCodes.RIGHT:
            if (this.orientation_ == goog.ui.Container.Orientation.HORIZONTAL)
                if (this.isRightToLeft()) this.highlightPrevious();
                else this.highlightNext();
            else return false;
            break;
        default:
            return false
    }
    return true
};
goog.ui.Container.prototype.registerChildId_ = function(child) {
    var childElem = child.getElement();
    var id = childElem.id || (childElem.id = child.getId());
    if (!this.childElementIdMap_) this.childElementIdMap_ = {};
    this.childElementIdMap_[id] = child
};
goog.ui.Container.prototype.addChild = function(child, opt_render) {
    goog.asserts.assertInstanceof(child, goog.ui.Control, "The child of a container must be a control");
    goog.ui.Container.superClass_.addChild.call(this, child, opt_render)
};
goog.ui.Container.prototype.getChild;
goog.ui.Container.prototype.getChildAt;
goog.ui.Container.prototype.addChildAt = function(control, index, opt_render) {
    goog.asserts.assertInstanceof(control, goog.ui.Control);
    control.setDispatchTransitionEvents(goog.ui.Component.State.HOVER, true);
    control.setDispatchTransitionEvents(goog.ui.Component.State.OPENED, true);
    if (this.isFocusable() || !this.isFocusableChildrenAllowed()) control.setSupportedState(goog.ui.Component.State.FOCUSED, false);
    control.setHandleMouseEvents(false);
    var srcIndex = control.getParent() == this ? this.indexOfChild(control) : -1;
    goog.ui.Container.superClass_.addChildAt.call(this, control, index, opt_render);
    if (control.isInDocument() && this.isInDocument()) this.registerChildId_(control);
    this.updateHighlightedIndex_(srcIndex, index)
};
goog.ui.Container.prototype.updateHighlightedIndex_ = function(fromIndex, toIndex) {
    if (fromIndex == -1) fromIndex = this.getChildCount();
    if (fromIndex == this.highlightedIndex_) this.highlightedIndex_ = Math.min(this.getChildCount() - 1, toIndex);
    else if (fromIndex > this.highlightedIndex_ && toIndex <= this.highlightedIndex_) this.highlightedIndex_++;
    else if (fromIndex < this.highlightedIndex_ && toIndex > this.highlightedIndex_) this.highlightedIndex_--
};
goog.ui.Container.prototype.removeChild = function(control, opt_unrender) {
    control = goog.isString(control) ? this.getChild(control) : control;
    goog.asserts.assertInstanceof(control, goog.ui.Control);
    if (control) {
        var index = this.indexOfChild(control);
        if (index != -1)
            if (index == this.highlightedIndex_) {
                control.setHighlighted(false);
                this.highlightedIndex_ = -1
            } else if (index < this.highlightedIndex_) this.highlightedIndex_--;
        var childElem = control.getElement();
        if (childElem && childElem.id && this.childElementIdMap_) goog.object.remove(this.childElementIdMap_,
            childElem.id)
    }
    control = goog.ui.Container.superClass_.removeChild.call(this, control, opt_unrender);
    control.setHandleMouseEvents(true);
    return control
};
goog.ui.Container.prototype.getOrientation = function() {
    return this.orientation_
};
goog.ui.Container.prototype.setOrientation = function(orientation) {
    if (this.getElement()) throw new Error(goog.ui.Component.Error.ALREADY_RENDERED);
    this.orientation_ = orientation
};
goog.ui.Container.prototype.isVisible = function() {
    return this.visible_
};
goog.ui.Container.prototype.setVisible = function(visible, opt_force) {
    if (opt_force || this.visible_ != visible && this.dispatchEvent(visible ? goog.ui.Component.EventType.SHOW : goog.ui.Component.EventType.HIDE)) {
        this.visible_ = visible;
        var elem = this.getElement();
        if (elem) {
            goog.style.setElementShown(elem, visible);
            if (this.isFocusable()) this.renderer_.enableTabIndex(this.getKeyEventTarget(), this.enabled_ && this.visible_);
            if (!opt_force) this.dispatchEvent(this.visible_ ? goog.ui.Container.EventType.AFTER_SHOW : goog.ui.Container.EventType.AFTER_HIDE)
        }
        return true
    }
    return false
};
goog.ui.Container.prototype.isEnabled = function() {
    return this.enabled_
};
goog.ui.Container.prototype.setEnabled = function(enable) {
    if (this.enabled_ != enable && this.dispatchEvent(enable ? goog.ui.Component.EventType.ENABLE : goog.ui.Component.EventType.DISABLE)) {
        if (enable) {
            this.enabled_ = true;
            this.forEachChild(function(child) {
                if (child.wasDisabled) delete child.wasDisabled;
                else child.setEnabled(true)
            })
        } else {
            this.forEachChild(function(child) {
                if (child.isEnabled()) child.setEnabled(false);
                else child.wasDisabled = true
            });
            this.enabled_ = false;
            this.setMouseButtonPressed(false)
        }
        if (this.isFocusable()) this.renderer_.enableTabIndex(this.getKeyEventTarget(),
            enable && this.visible_)
    }
};
goog.ui.Container.prototype.isFocusable = function() {
    return this.focusable_
};
goog.ui.Container.prototype.setFocusable = function(focusable) {
    if (focusable != this.focusable_ && this.isInDocument()) this.enableFocusHandling_(focusable);
    this.focusable_ = focusable;
    if (this.enabled_ && this.visible_) this.renderer_.enableTabIndex(this.getKeyEventTarget(), focusable)
};
goog.ui.Container.prototype.isFocusableChildrenAllowed = function() {
    return this.allowFocusableChildren_
};
goog.ui.Container.prototype.setFocusableChildrenAllowed = function(focusable) {
    this.allowFocusableChildren_ = focusable
};
goog.ui.Container.prototype.isOpenFollowsHighlight = function() {
    return this.openFollowsHighlight_
};
goog.ui.Container.prototype.setOpenFollowsHighlight = function(follow) {
    this.openFollowsHighlight_ = follow
};
goog.ui.Container.prototype.getHighlightedIndex = function() {
    return this.highlightedIndex_
};
goog.ui.Container.prototype.setHighlightedIndex = function(index) {
    var child = this.getChildAt(index);
    if (child) child.setHighlighted(true);
    else if (this.highlightedIndex_ > -1) this.getHighlighted().setHighlighted(false)
};
goog.ui.Container.prototype.setHighlighted = function(item) {
    this.setHighlightedIndex(this.indexOfChild(item))
};
goog.ui.Container.prototype.getHighlighted = function() {
    return this.getChildAt(this.highlightedIndex_)
};
goog.ui.Container.prototype.highlightFirst = function() {
    this.highlightHelper(function(index, max) {
        return (index + 1) % max
    }, this.getChildCount() - 1)
};
goog.ui.Container.prototype.highlightLast = function() {
    this.highlightHelper(function(index, max) {
        index--;
        return index < 0 ? max - 1 : index
    }, 0)
};
goog.ui.Container.prototype.highlightNext = function() {
    this.highlightHelper(function(index, max) {
        return (index + 1) % max
    }, this.highlightedIndex_)
};
goog.ui.Container.prototype.highlightPrevious = function() {
    this.highlightHelper(function(index, max) {
        index--;
        return index < 0 ? max - 1 : index
    }, this.highlightedIndex_)
};
goog.ui.Container.prototype.highlightHelper = function(fn, startIndex) {
    var curIndex = startIndex < 0 ? this.indexOfChild(this.openItem_) : startIndex;
    var numItems = this.getChildCount();
    curIndex = fn.call(this, curIndex, numItems);
    var visited = 0;
    while (visited <= numItems) {
        var control = this.getChildAt(curIndex);
        if (control && this.canHighlightItem(control)) {
            this.setHighlightedIndexFromKeyEvent(curIndex);
            return true
        }
        visited++;
        curIndex = fn.call(this, curIndex, numItems)
    }
    return false
};
goog.ui.Container.prototype.canHighlightItem = function(item) {
    return item.isVisible() && item.isEnabled() && item.isSupportedState(goog.ui.Component.State.HOVER)
};
goog.ui.Container.prototype.setHighlightedIndexFromKeyEvent = function(index) {
    this.setHighlightedIndex(index)
};
goog.ui.Container.prototype.getOpenItem = function() {
    return this.openItem_
};
goog.ui.Container.prototype.isMouseButtonPressed = function() {
    return this.mouseButtonPressed_
};
goog.ui.Container.prototype.setMouseButtonPressed = function(pressed) {
    this.mouseButtonPressed_ = pressed
};
goog.provide("goog.ui.MenuHeaderRenderer");
goog.require("goog.ui.ControlRenderer");
goog.ui.MenuHeaderRenderer = function() {
    goog.ui.ControlRenderer.call(this)
};
goog.inherits(goog.ui.MenuHeaderRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuHeaderRenderer);
goog.ui.MenuHeaderRenderer.CSS_CLASS = goog.getCssName("goog-menuheader");
goog.ui.MenuHeaderRenderer.prototype.getCssClass = function() {
    return goog.ui.MenuHeaderRenderer.CSS_CLASS
};
goog.provide("goog.ui.MenuHeader");
goog.require("goog.ui.Component");
goog.require("goog.ui.Control");
goog.require("goog.ui.MenuHeaderRenderer");
goog.require("goog.ui.registry");
goog.ui.MenuHeader = function(content, opt_domHelper, opt_renderer) {
    goog.ui.Control.call(this, content, opt_renderer || goog.ui.MenuHeaderRenderer.getInstance(), opt_domHelper);
    this.setSupportedState(goog.ui.Component.State.DISABLED, false);
    this.setSupportedState(goog.ui.Component.State.HOVER, false);
    this.setSupportedState(goog.ui.Component.State.ACTIVE, false);
    this.setSupportedState(goog.ui.Component.State.FOCUSED, false);
    this.setStateInternal(goog.ui.Component.State.DISABLED)
};
goog.inherits(goog.ui.MenuHeader, goog.ui.Control);
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuHeaderRenderer.CSS_CLASS, function() {
    return new goog.ui.MenuHeader(null)
});
goog.provide("goog.ui.MenuItemRenderer");
goog.require("goog.a11y.aria.Role");
goog.require("goog.asserts");
goog.require("goog.dom");
goog.require("goog.dom.TagName");
goog.require("goog.dom.classlist");
goog.require("goog.ui.Component");
goog.require("goog.ui.ControlRenderer");
goog.ui.MenuItemRenderer = function() {
    goog.ui.ControlRenderer.call(this);
    this.classNameCache_ = []
};
goog.inherits(goog.ui.MenuItemRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuItemRenderer);
goog.ui.MenuItemRenderer.CSS_CLASS = goog.getCssName("goog-menuitem");
goog.ui.MenuItemRenderer.CompositeCssClassIndex_ = {
    HOVER: 0,
    CHECKBOX: 1,
    CONTENT: 2
};
goog.ui.MenuItemRenderer.prototype.getCompositeCssClass_ = function(index) {
    var result = this.classNameCache_[index];
    if (!result) {
        switch (index) {
            case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER:
                result = goog.getCssName(this.getStructuralCssClass(), "highlight");
                break;
            case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX:
                result = goog.getCssName(this.getStructuralCssClass(), "checkbox");
                break;
            case goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT:
                result = goog.getCssName(this.getStructuralCssClass(),
                    "content");
                break
        }
        this.classNameCache_[index] = result
    }
    return result
};
goog.ui.MenuItemRenderer.prototype.getAriaRole = function() {
    return goog.a11y.aria.Role.MENU_ITEM
};
goog.ui.MenuItemRenderer.prototype.createDom = function(item) {
    var element = item.getDomHelper().createDom(goog.dom.TagName.DIV, this.getClassNames(item).join(" "), this.createContent(item.getContent(), item.getDomHelper()));
    this.setEnableCheckBoxStructure(item, element, item.isSupportedState(goog.ui.Component.State.SELECTED) || item.isSupportedState(goog.ui.Component.State.CHECKED));
    return element
};
goog.ui.MenuItemRenderer.prototype.getContentElement = function(element) {
    return element && element.firstChild
};
goog.ui.MenuItemRenderer.prototype.decorate = function(item, element) {
    goog.asserts.assert(element);
    if (!this.hasContentStructure(element)) element.appendChild(this.createContent(element.childNodes, item.getDomHelper()));
    if (goog.dom.classlist.contains(element, goog.getCssName("goog-option"))) {
        item.setCheckable(true);
        this.setCheckable(item, element, true)
    }
    return goog.ui.MenuItemRenderer.superClass_.decorate.call(this, item, element)
};
goog.ui.MenuItemRenderer.prototype.setContent = function(element, content) {
    var contentElement = this.getContentElement(element);
    var checkBoxElement = this.hasCheckBoxStructure(element) ? contentElement.firstChild : null;
    goog.ui.MenuItemRenderer.superClass_.setContent.call(this, element, content);
    if (checkBoxElement && !this.hasCheckBoxStructure(element)) contentElement.insertBefore(checkBoxElement, contentElement.firstChild || null)
};
goog.ui.MenuItemRenderer.prototype.hasContentStructure = function(element) {
    var child = goog.dom.getFirstElementChild(element);
    var contentClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT);
    return !!child && goog.dom.classlist.contains(child, contentClassName)
};
goog.ui.MenuItemRenderer.prototype.createContent = function(content, dom) {
    var contentClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CONTENT);
    return dom.createDom(goog.dom.TagName.DIV, contentClassName, content)
};
goog.ui.MenuItemRenderer.prototype.setSelectable = function(item, element, selectable) {
    if (item && element) this.setEnableCheckBoxStructure(item, element, selectable)
};
goog.ui.MenuItemRenderer.prototype.setCheckable = function(item, element, checkable) {
    if (item && element) this.setEnableCheckBoxStructure(item, element, checkable)
};
goog.ui.MenuItemRenderer.prototype.hasCheckBoxStructure = function(element) {
    var contentElement = this.getContentElement(element);
    if (contentElement) {
        var child = contentElement.firstChild;
        var checkboxClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX);
        return !!child && goog.dom.isElement(child) && goog.dom.classlist.contains(child, checkboxClassName)
    }
    return false
};
goog.ui.MenuItemRenderer.prototype.setEnableCheckBoxStructure = function(item, element, enable) {
    this.setAriaRole(element, item.getPreferredAriaRole());
    this.setAriaStates(item, element);
    if (enable != this.hasCheckBoxStructure(element)) {
        goog.dom.classlist.enable(element, goog.getCssName("goog-option"), enable);
        var contentElement = this.getContentElement(element);
        if (enable) {
            var checkboxClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.CHECKBOX);
            contentElement.insertBefore(item.getDomHelper().createDom(goog.dom.TagName.DIV,
                checkboxClassName), contentElement.firstChild || null)
        } else contentElement.removeChild(contentElement.firstChild)
    }
};
goog.ui.MenuItemRenderer.prototype.getClassForState = function(state) {
    switch (state) {
        case goog.ui.Component.State.HOVER:
            return this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER);
        case goog.ui.Component.State.CHECKED:
        case goog.ui.Component.State.SELECTED:
            return goog.getCssName("goog-option-selected");
        default:
            return goog.ui.MenuItemRenderer.superClass_.getClassForState.call(this, state)
    }
};
goog.ui.MenuItemRenderer.prototype.getStateFromClass = function(className) {
    var hoverClassName = this.getCompositeCssClass_(goog.ui.MenuItemRenderer.CompositeCssClassIndex_.HOVER);
    switch (className) {
        case goog.getCssName("goog-option-selected"):
            return goog.ui.Component.State.CHECKED;
        case hoverClassName:
            return goog.ui.Component.State.HOVER;
        default:
            return goog.ui.MenuItemRenderer.superClass_.getStateFromClass.call(this, className)
    }
};
goog.ui.MenuItemRenderer.prototype.getCssClass = function() {
    return goog.ui.MenuItemRenderer.CSS_CLASS
};
goog.provide("goog.ui.MenuItem");
goog.require("goog.a11y.aria.Role");
goog.require("goog.array");
goog.require("goog.dom");
goog.require("goog.dom.classlist");
goog.require("goog.math.Coordinate");
goog.require("goog.string");
goog.require("goog.ui.Component");
goog.require("goog.ui.Control");
goog.require("goog.ui.MenuItemRenderer");
goog.require("goog.ui.registry");
goog.forwardDeclare("goog.ui.Menu");
goog.ui.MenuItem = function(content, opt_model, opt_domHelper, opt_renderer) {
    goog.ui.Control.call(this, content, opt_renderer || goog.ui.MenuItemRenderer.getInstance(), opt_domHelper);
    this.setValue(opt_model)
};
goog.inherits(goog.ui.MenuItem, goog.ui.Control);
goog.tagUnsealableClass(goog.ui.MenuItem);
goog.ui.MenuItem.prototype.mnemonicKey_;
goog.ui.MenuItem.MNEMONIC_WRAPPER_CLASS_ = goog.getCssName("goog-menuitem-mnemonic-separator");
goog.ui.MenuItem.ACCELERATOR_CLASS = goog.getCssName("goog-menuitem-accel");
goog.ui.MenuItem.prototype.getValue = function() {
    var model = this.getModel();
    return model != null ? model : this.getCaption()
};
goog.ui.MenuItem.prototype.setValue = function(value) {
    this.setModel(value)
};
goog.ui.MenuItem.prototype.setSupportedState = function(state, support) {
    goog.ui.MenuItem.base(this, "setSupportedState", state, support);
    switch (state) {
        case goog.ui.Component.State.SELECTED:
            this.setSelectableInternal_(support);
            break;
        case goog.ui.Component.State.CHECKED:
            this.setCheckableInternal_(support);
            break
    }
};
goog.ui.MenuItem.prototype.setSelectable = function(selectable) {
    this.setSupportedState(goog.ui.Component.State.SELECTED, selectable)
};
goog.ui.MenuItem.prototype.setSelectableInternal_ = function(selectable) {
    if (this.isChecked() && !selectable) this.setChecked(false);
    var element = this.getElement();
    if (element) this.getRenderer().setSelectable(this, element, selectable)
};
goog.ui.MenuItem.prototype.setCheckable = function(checkable) {
    this.setSupportedState(goog.ui.Component.State.CHECKED, checkable)
};
goog.ui.MenuItem.prototype.setCheckableInternal_ = function(checkable) {
    var element = this.getElement();
    if (element) this.getRenderer().setCheckable(this, element, checkable)
};
goog.ui.MenuItem.prototype.getCaption = function() {
    var content = this.getContent();
    if (goog.isArray(content)) {
        var acceleratorClass = goog.ui.MenuItem.ACCELERATOR_CLASS;
        var mnemonicWrapClass = goog.ui.MenuItem.MNEMONIC_WRAPPER_CLASS_;
        var caption = goog.array.map(content, function(node) {
            if (goog.dom.isElement(node) && (goog.dom.classlist.contains(node, acceleratorClass) || goog.dom.classlist.contains(node, mnemonicWrapClass))) return "";
            else return goog.dom.getRawTextContent(node)
        }).join("");
        return goog.string.collapseBreakingSpaces(caption)
    }
    return goog.ui.MenuItem.superClass_.getCaption.call(this)
};
goog.ui.MenuItem.prototype.getAccelerator = function() {
    var dom = this.getDomHelper();
    var content = this.getContent();
    if (goog.isArray(content)) {
        var acceleratorEl = goog.array.find(content, function(e) {
            return goog.dom.classlist.contains(e, goog.ui.MenuItem.ACCELERATOR_CLASS)
        });
        if (acceleratorEl) return dom.getTextContent(acceleratorEl)
    }
    return null
};
goog.ui.MenuItem.prototype.handleMouseUp = function(e) {
    var parentMenu = this.getParent();
    if (parentMenu) {
        var oldCoords = parentMenu.openingCoords;
        parentMenu.openingCoords = null;
        if (oldCoords && goog.isNumber(e.clientX)) {
            var newCoords = new goog.math.Coordinate(e.clientX, e.clientY);
            if (goog.math.Coordinate.equals(oldCoords, newCoords)) return
        }
    }
    goog.ui.MenuItem.base(this, "handleMouseUp", e)
};
goog.ui.MenuItem.prototype.handleKeyEventInternal = function(e) {
    if (e.keyCode == this.getMnemonic() && this.performActionInternal(e)) return true;
    else return goog.ui.MenuItem.base(this, "handleKeyEventInternal", e)
};
goog.ui.MenuItem.prototype.setMnemonic = function(key) {
    this.mnemonicKey_ = key
};
goog.ui.MenuItem.prototype.getMnemonic = function() {
    return this.mnemonicKey_
};
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuItemRenderer.CSS_CLASS, function() {
    return new goog.ui.MenuItem(null)
});
goog.ui.MenuItem.prototype.getPreferredAriaRole = function() {
    if (this.isSupportedState(goog.ui.Component.State.CHECKED)) return goog.a11y.aria.Role.MENU_ITEM_CHECKBOX;
    if (this.isSupportedState(goog.ui.Component.State.SELECTED)) return goog.a11y.aria.Role.MENU_ITEM_RADIO;
    return goog.ui.MenuItem.base(this, "getPreferredAriaRole")
};
goog.ui.MenuItem.prototype.getParent = function() {
    return goog.ui.Control.prototype.getParent.call(this)
};
goog.ui.MenuItem.prototype.getParentEventTarget = function() {
    return goog.ui.Control.prototype.getParentEventTarget.call(this)
};
goog.provide("goog.ui.MenuSeparatorRenderer");
goog.require("goog.dom");
goog.require("goog.dom.TagName");
goog.require("goog.dom.classlist");
goog.require("goog.ui.ControlRenderer");
goog.ui.MenuSeparatorRenderer = function() {
    goog.ui.ControlRenderer.call(this)
};
goog.inherits(goog.ui.MenuSeparatorRenderer, goog.ui.ControlRenderer);
goog.addSingletonGetter(goog.ui.MenuSeparatorRenderer);
goog.ui.MenuSeparatorRenderer.CSS_CLASS = goog.getCssName("goog-menuseparator");
goog.ui.MenuSeparatorRenderer.prototype.createDom = function(separator) {
    return separator.getDomHelper().createDom(goog.dom.TagName.DIV, this.getCssClass())
};
goog.ui.MenuSeparatorRenderer.prototype.decorate = function(separator, element) {
    if (element.id) separator.setId(element.id);
    if (element.tagName == goog.dom.TagName.HR) {
        var hr = element;
        element = this.createDom(separator);
        goog.dom.insertSiblingBefore(element, hr);
        goog.dom.removeNode(hr)
    } else goog.dom.classlist.add(element, this.getCssClass());
    return element
};
goog.ui.MenuSeparatorRenderer.prototype.setContent = function(separator, content) {};
goog.ui.MenuSeparatorRenderer.prototype.getCssClass = function() {
    return goog.ui.MenuSeparatorRenderer.CSS_CLASS
};
goog.provide("goog.ui.Separator");
goog.require("goog.a11y.aria");
goog.require("goog.asserts");
goog.require("goog.ui.Component");
goog.require("goog.ui.Control");
goog.require("goog.ui.MenuSeparatorRenderer");
goog.require("goog.ui.registry");
goog.ui.Separator = function(opt_renderer, opt_domHelper) {
    goog.ui.Control.call(this, null, opt_renderer || goog.ui.MenuSeparatorRenderer.getInstance(), opt_domHelper);
    this.setSupportedState(goog.ui.Component.State.DISABLED, false);
    this.setSupportedState(goog.ui.Component.State.HOVER, false);
    this.setSupportedState(goog.ui.Component.State.ACTIVE, false);
    this.setSupportedState(goog.ui.Component.State.FOCUSED, false);
    this.setStateInternal(goog.ui.Component.State.DISABLED)
};
goog.inherits(goog.ui.Separator, goog.ui.Control);
goog.ui.Separator.prototype.enterDocument = function() {
    goog.ui.Separator.superClass_.enterDocument.call(this);
    var element = this.getElement();
    goog.asserts.assert(element, "The DOM element for the separator cannot be null.");
    goog.a11y.aria.setRole(element, "separator")
};
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuSeparatorRenderer.CSS_CLASS, function() {
    return new goog.ui.Separator
});
goog.provide("goog.ui.MenuRenderer");
goog.require("goog.a11y.aria");
goog.require("goog.a11y.aria.Role");
goog.require("goog.a11y.aria.State");
goog.require("goog.asserts");
goog.require("goog.dom");
goog.require("goog.dom.TagName");
goog.require("goog.ui.ContainerRenderer");
goog.require("goog.ui.Separator");
goog.forwardDeclare("goog.ui.Menu");
goog.ui.MenuRenderer = function(opt_ariaRole) {
    goog.ui.ContainerRenderer.call(this, opt_ariaRole || goog.a11y.aria.Role.MENU)
};
goog.inherits(goog.ui.MenuRenderer, goog.ui.ContainerRenderer);
goog.addSingletonGetter(goog.ui.MenuRenderer);
goog.ui.MenuRenderer.CSS_CLASS = goog.getCssName("goog-menu");
goog.ui.MenuRenderer.prototype.canDecorate = function(element) {
    return element.tagName == goog.dom.TagName.UL || goog.ui.MenuRenderer.superClass_.canDecorate.call(this, element)
};
goog.ui.MenuRenderer.prototype.getDecoratorForChild = function(element) {
    return element.tagName == goog.dom.TagName.HR ? new goog.ui.Separator : goog.ui.MenuRenderer.superClass_.getDecoratorForChild.call(this, element)
};
goog.ui.MenuRenderer.prototype.containsElement = function(menu, element) {
    return goog.dom.contains(menu.getElement(), element)
};
goog.ui.MenuRenderer.prototype.getCssClass = function() {
    return goog.ui.MenuRenderer.CSS_CLASS
};
goog.ui.MenuRenderer.prototype.initializeDom = function(container) {
    goog.ui.MenuRenderer.superClass_.initializeDom.call(this, container);
    var element = container.getElement();
    goog.asserts.assert(element, "The menu DOM element cannot be null.");
    goog.a11y.aria.setState(element, goog.a11y.aria.State.HASPOPUP, "true")
};
goog.provide("goog.ui.MenuSeparator");
goog.require("goog.ui.MenuSeparatorRenderer");
goog.require("goog.ui.Separator");
goog.require("goog.ui.registry");
goog.ui.MenuSeparator = function(opt_domHelper) {
    goog.ui.Separator.call(this, goog.ui.MenuSeparatorRenderer.getInstance(), opt_domHelper)
};
goog.inherits(goog.ui.MenuSeparator, goog.ui.Separator);
goog.ui.registry.setDecoratorByClassName(goog.ui.MenuSeparatorRenderer.CSS_CLASS, function() {
    return new goog.ui.Separator
});
goog.provide("goog.ui.Menu");
goog.provide("goog.ui.Menu.EventType");
goog.require("goog.dom.TagName");
goog.require("goog.math.Coordinate");
goog.require("goog.string");
goog.require("goog.style");
goog.require("goog.ui.Component.EventType");
goog.require("goog.ui.Component.State");
goog.require("goog.ui.Container");
goog.require("goog.ui.Container.Orientation");
goog.require("goog.ui.MenuHeader");
goog.require("goog.ui.MenuItem");
goog.require("goog.ui.MenuRenderer");
goog.require("goog.ui.MenuSeparator");
goog.ui.Menu = function(opt_domHelper, opt_renderer) {
    goog.ui.Container.call(this, goog.ui.Container.Orientation.VERTICAL, opt_renderer || goog.ui.MenuRenderer.getInstance(), opt_domHelper);
    this.setFocusable(false)
};
goog.inherits(goog.ui.Menu, goog.ui.Container);
goog.tagUnsealableClass(goog.ui.Menu);
goog.ui.Menu.EventType = {
    BEFORE_SHOW: goog.ui.Component.EventType.BEFORE_SHOW,
    SHOW: goog.ui.Component.EventType.SHOW,
    BEFORE_HIDE: goog.ui.Component.EventType.HIDE,
    HIDE: goog.ui.Component.EventType.HIDE
};
goog.ui.Menu.CSS_CLASS = goog.ui.MenuRenderer.CSS_CLASS;
goog.ui.Menu.prototype.openingCoords;
goog.ui.Menu.prototype.allowAutoFocus_ = true;
goog.ui.Menu.prototype.allowHighlightDisabled_ = false;
goog.ui.Menu.prototype.getCssClass = function() {
    return this.getRenderer().getCssClass()
};
goog.ui.Menu.prototype.containsElement = function(element) {
    if (this.getRenderer().containsElement(this, element)) return true;
    for (var i = 0, count = this.getChildCount(); i < count; i++) {
        var child = this.getChildAt(i);
        if (typeof child.containsElement == "function" && child.containsElement(element)) return true
    }
    return false
};
goog.ui.Menu.prototype.addItem = function(item) {
    this.addChild(item, true)
};
goog.ui.Menu.prototype.addItemAt = function(item, n) {
    this.addChildAt(item, n, true)
};
goog.ui.Menu.prototype.removeItem = function(item) {
    var removedChild = this.removeChild(item, true);
    if (removedChild) removedChild.dispose()
};
goog.ui.Menu.prototype.removeItemAt = function(n) {
    var removedChild = this.removeChildAt(n, true);
    if (removedChild) removedChild.dispose()
};
goog.ui.Menu.prototype.getItemAt = function(n) {
    return this.getChildAt(n)
};
goog.ui.Menu.prototype.getItemCount = function() {
    return this.getChildCount()
};
goog.ui.Menu.prototype.getItems = function() {
    var children = [];
    this.forEachChild(function(child) {
        children.push(child)
    });
    return children
};
goog.ui.Menu.prototype.setPosition = function(x, opt_y) {
    var visible = this.isVisible();
    if (!visible) goog.style.setElementShown(this.getElement(), true);
    goog.style.setPageOffset(this.getElement(), x, opt_y);
    if (!visible) goog.style.setElementShown(this.getElement(), false)
};
goog.ui.Menu.prototype.getPosition = function() {
    return this.isVisible() ? goog.style.getPageOffset(this.getElement()) : null
};
goog.ui.Menu.prototype.setAllowAutoFocus = function(allow) {
    this.allowAutoFocus_ = allow;
    if (allow) this.setFocusable(true)
};
goog.ui.Menu.prototype.getAllowAutoFocus = function() {
    return this.allowAutoFocus_
};
goog.ui.Menu.prototype.setAllowHighlightDisabled = function(allow) {
    this.allowHighlightDisabled_ = allow
};
goog.ui.Menu.prototype.getAllowHighlightDisabled = function() {
    return this.allowHighlightDisabled_
};
goog.ui.Menu.prototype.setVisible = function(show, opt_force, opt_e) {
    var visibilityChanged = goog.ui.Menu.superClass_.setVisible.call(this, show, opt_force);
    if (visibilityChanged && show && this.isInDocument() && this.allowAutoFocus_) this.getKeyEventTarget().focus();
    if (show && opt_e && goog.isNumber(opt_e.clientX)) this.openingCoords = new goog.math.Coordinate(opt_e.clientX, opt_e.clientY);
    else this.openingCoords = null;
    return visibilityChanged
};
goog.ui.Menu.prototype.handleEnterItem = function(e) {
    if (this.allowAutoFocus_) this.getKeyEventTarget().focus();
    return goog.ui.Menu.superClass_.handleEnterItem.call(this, e)
};
goog.ui.Menu.prototype.highlightNextPrefix = function(charStr) {
    var re = new RegExp("^" + goog.string.regExpEscape(charStr), "i");
    return this.highlightHelper(function(index, max) {
        var start = index < 0 ? 0 : index;
        var wrapped = false;
        do {
            ++index;
            if (index == max) {
                index = 0;
                wrapped = true
            }
            var name = this.getChildAt(index).getCaption();
            if (name && name.match(re)) return index
        } while (!wrapped || index != start);
        return this.getHighlightedIndex()
    }, this.getHighlightedIndex())
};
goog.ui.Menu.prototype.canHighlightItem = function(item) {
    return (this.allowHighlightDisabled_ || item.isEnabled()) && item.isVisible() && item.isSupportedState(goog.ui.Component.State.HOVER)
};
goog.ui.Menu.prototype.decorateInternal = function(element) {
    this.decorateContent(element);
    goog.ui.Menu.superClass_.decorateInternal.call(this, element)
};
goog.ui.Menu.prototype.handleKeyEventInternal = function(e) {
    var handled = goog.ui.Menu.base(this, "handleKeyEventInternal", e);
    if (!handled) this.forEachChild(function(menuItem) {
        if (!handled && menuItem.getMnemonic && menuItem.getMnemonic() == e.keyCode) {
            if (this.isEnabled()) this.setHighlighted(menuItem);
            handled = menuItem.handleKeyEvent(e)
        }
    }, this);
    return handled
};
goog.ui.Menu.prototype.setHighlightedIndex = function(index) {
    goog.ui.Menu.base(this, "setHighlightedIndex", index);
    var child = this.getChildAt(index);
    if (child) goog.style.scrollIntoContainerView(child.getElement(), this.getElement())
};
goog.ui.Menu.prototype.decorateContent = function(element) {
    var renderer = this.getRenderer();
    var contentElements = this.getDomHelper().getElementsByTagNameAndClass(goog.dom.TagName.DIV, goog.getCssName(renderer.getCssClass(), "content"), element);
    var length = contentElements.length;
    for (var i = 0; i < length; i++) renderer.decorateChildren(this, contentElements[i])
};
goog.provide("goog.events.FocusHandler");
goog.provide("goog.events.FocusHandler.EventType");
goog.require("goog.events");
goog.require("goog.events.BrowserEvent");
goog.require("goog.events.EventTarget");
goog.require("goog.userAgent");
goog.events.FocusHandler = function(element) {
    goog.events.EventTarget.call(this);
    this.element_ = element;
    var typeIn = goog.userAgent.IE ? "focusin" : "focus";
    var typeOut = goog.userAgent.IE ? "focusout" : "blur";
    this.listenKeyIn_ = goog.events.listen(this.element_, typeIn, this, !goog.userAgent.IE);
    this.listenKeyOut_ = goog.events.listen(this.element_, typeOut, this, !goog.userAgent.IE)
};
goog.inherits(goog.events.FocusHandler, goog.events.EventTarget);
goog.events.FocusHandler.EventType = {
    FOCUSIN: "focusin",
    FOCUSOUT: "focusout"
};
goog.events.FocusHandler.prototype.handleEvent = function(e) {
    var be = e.getBrowserEvent();
    var event = new goog.events.BrowserEvent(be);
    event.type = e.type == "focusin" || e.type == "focus" ? goog.events.FocusHandler.EventType.FOCUSIN : goog.events.FocusHandler.EventType.FOCUSOUT;
    this.dispatchEvent(event)
};
goog.events.FocusHandler.prototype.disposeInternal = function() {
    goog.events.FocusHandler.superClass_.disposeInternal.call(this);
    goog.events.unlistenByKey(this.listenKeyIn_);
    goog.events.unlistenByKey(this.listenKeyOut_);
    delete this.element_
};
goog.provide("goog.debug.LogRecord");
goog.debug.LogRecord = function(level, msg, loggerName, opt_time, opt_sequenceNumber) {
    this.reset(level, msg, loggerName, opt_time, opt_sequenceNumber)
};
goog.debug.LogRecord.prototype.time_;
goog.debug.LogRecord.prototype.level_;
goog.debug.LogRecord.prototype.msg_;
goog.debug.LogRecord.prototype.loggerName_;
goog.debug.LogRecord.prototype.sequenceNumber_ = 0;
goog.debug.LogRecord.prototype.exception_ = null;
goog.define("goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS", true);
goog.debug.LogRecord.nextSequenceNumber_ = 0;
goog.debug.LogRecord.prototype.reset = function(level, msg, loggerName, opt_time, opt_sequenceNumber) {
    if (goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS) this.sequenceNumber_ = typeof opt_sequenceNumber == "number" ? opt_sequenceNumber : goog.debug.LogRecord.nextSequenceNumber_++;
    this.time_ = opt_time || goog.now();
    this.level_ = level;
    this.msg_ = msg;
    this.loggerName_ = loggerName;
    delete this.exception_
};
goog.debug.LogRecord.prototype.getLoggerName = function() {
    return this.loggerName_
};
goog.debug.LogRecord.prototype.getException = function() {
    return this.exception_
};
goog.debug.LogRecord.prototype.setException = function(exception) {
    this.exception_ = exception
};
goog.debug.LogRecord.prototype.setLoggerName = function(loggerName) {
    this.loggerName_ = loggerName
};
goog.debug.LogRecord.prototype.getLevel = function() {
    return this.level_
};
goog.debug.LogRecord.prototype.setLevel = function(level) {
    this.level_ = level
};
goog.debug.LogRecord.prototype.getMessage = function() {
    return this.msg_
};
goog.debug.LogRecord.prototype.setMessage = function(msg) {
    this.msg_ = msg
};
goog.debug.LogRecord.prototype.getMillis = function() {
    return this.time_
};
goog.debug.LogRecord.prototype.setMillis = function(time) {
    this.time_ = time
};
goog.debug.LogRecord.prototype.getSequenceNumber = function() {
    return this.sequenceNumber_
};
goog.provide("goog.debug.LogBuffer");
goog.require("goog.asserts");
goog.require("goog.debug.LogRecord");
goog.debug.LogBuffer = function() {
    goog.asserts.assert(goog.debug.LogBuffer.isBufferingEnabled(), "Cannot use goog.debug.LogBuffer without defining " + "goog.debug.LogBuffer.CAPACITY.");
    this.clear()
};
goog.debug.LogBuffer.getInstance = function() {
    if (!goog.debug.LogBuffer.instance_) goog.debug.LogBuffer.instance_ = new goog.debug.LogBuffer;
    return goog.debug.LogBuffer.instance_
};
goog.define("goog.debug.LogBuffer.CAPACITY", 0);
goog.debug.LogBuffer.prototype.buffer_;
goog.debug.LogBuffer.prototype.curIndex_;
goog.debug.LogBuffer.prototype.isFull_;
goog.debug.LogBuffer.prototype.addRecord = function(level, msg, loggerName) {
    var curIndex = (this.curIndex_ + 1) % goog.debug.LogBuffer.CAPACITY;
    this.curIndex_ = curIndex;
    if (this.isFull_) {
        var ret = this.buffer_[curIndex];
        ret.reset(level, msg, loggerName);
        return ret
    }
    this.isFull_ = curIndex == goog.debug.LogBuffer.CAPACITY - 1;
    return this.buffer_[curIndex] = new goog.debug.LogRecord(level, msg, loggerName)
};
goog.debug.LogBuffer.isBufferingEnabled = function() {
    return goog.debug.LogBuffer.CAPACITY > 0
};
goog.debug.LogBuffer.prototype.clear = function() {
    this.buffer_ = new Array(goog.debug.LogBuffer.CAPACITY);
    this.curIndex_ = -1;
    this.isFull_ = false
};
goog.debug.LogBuffer.prototype.forEachRecord = function(func) {
    var buffer = this.buffer_;
    if (!buffer[0]) return;
    var curIndex = this.curIndex_;
    var i = this.isFull_ ? curIndex : -1;
    do {
        i = (i + 1) % goog.debug.LogBuffer.CAPACITY;
        func(buffer[i])
    } while (i != curIndex)
};
goog.provide("goog.debug.LogManager");
goog.provide("goog.debug.Loggable");
goog.provide("goog.debug.Logger");
goog.provide("goog.debug.Logger.Level");
goog.require("goog.array");
goog.require("goog.asserts");
goog.require("goog.debug");
goog.require("goog.debug.LogBuffer");
goog.require("goog.debug.LogRecord");
goog.debug.Loggable;
goog.debug.Logger = function(name) {
    this.name_ = name;
    this.parent_ = null;
    this.level_ = null;
    this.children_ = null;
    this.handlers_ = null
};
goog.debug.Logger.ROOT_LOGGER_NAME = "";
goog.define("goog.debug.Logger.ENABLE_HIERARCHY", true);
goog.define("goog.debug.Logger.ENABLE_PROFILER_LOGGING", false);
if (!goog.debug.Logger.ENABLE_HIERARCHY) {
    goog.debug.Logger.rootHandlers_ = [];
    goog.debug.Logger.rootLevel_
}
goog.debug.Logger.Level = function(name, value) {
    this.name = name;
    this.value = value
};
goog.debug.Logger.Level.prototype.toString = function() {
    return this.name
};
goog.debug.Logger.Level.OFF = new goog.debug.Logger.Level("OFF", Infinity);
goog.debug.Logger.Level.SHOUT = new goog.debug.Logger.Level("SHOUT", 1200);
goog.debug.Logger.Level.SEVERE = new goog.debug.Logger.Level("SEVERE", 1E3);
goog.debug.Logger.Level.WARNING = new goog.debug.Logger.Level("WARNING", 900);
goog.debug.Logger.Level.INFO = new goog.debug.Logger.Level("INFO", 800);
goog.debug.Logger.Level.CONFIG = new goog.debug.Logger.Level("CONFIG", 700);
goog.debug.Logger.Level.FINE = new goog.debug.Logger.Level("FINE", 500);
goog.debug.Logger.Level.FINER = new goog.debug.Logger.Level("FINER", 400);
goog.debug.Logger.Level.FINEST = new goog.debug.Logger.Level("FINEST", 300);
goog.debug.Logger.Level.ALL = new goog.debug.Logger.Level("ALL", 0);
goog.debug.Logger.Level.PREDEFINED_LEVELS = [goog.debug.Logger.Level.OFF, goog.debug.Logger.Level.SHOUT, goog.debug.Logger.Level.SEVERE, goog.debug.Logger.Level.WARNING, goog.debug.Logger.Level.INFO, goog.debug.Logger.Level.CONFIG, goog.debug.Logger.Level.FINE, goog.debug.Logger.Level.FINER, goog.debug.Logger.Level.FINEST, goog.debug.Logger.Level.ALL];
goog.debug.Logger.Level.predefinedLevelsCache_ = null;
goog.debug.Logger.Level.createPredefinedLevelsCache_ = function() {
    goog.debug.Logger.Level.predefinedLevelsCache_ = {};
    for (var i = 0, level; level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i]; i++) {
        goog.debug.Logger.Level.predefinedLevelsCache_[level.value] = level;
        goog.debug.Logger.Level.predefinedLevelsCache_[level.name] = level
    }
};
goog.debug.Logger.Level.getPredefinedLevel = function(name) {
    if (!goog.debug.Logger.Level.predefinedLevelsCache_) goog.debug.Logger.Level.createPredefinedLevelsCache_();
    return goog.debug.Logger.Level.predefinedLevelsCache_[name] || null
};
goog.debug.Logger.Level.getPredefinedLevelByValue = function(value) {
    if (!goog.debug.Logger.Level.predefinedLevelsCache_) goog.debug.Logger.Level.createPredefinedLevelsCache_();
    if (value in goog.debug.Logger.Level.predefinedLevelsCache_) return goog.debug.Logger.Level.predefinedLevelsCache_[value];
    for (var i = 0; i < goog.debug.Logger.Level.PREDEFINED_LEVELS.length; ++i) {
        var level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
        if (level.value <= value) return level
    }
    return null
};
goog.debug.Logger.getLogger = function(name) {
    return goog.debug.LogManager.getLogger(name)
};
goog.debug.Logger.logToProfilers = function(msg) {
    if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) {
        var msWriteProfilerMark = goog.global["msWriteProfilerMark"];
        if (msWriteProfilerMark) {
            msWriteProfilerMark(msg);
            return
        }
        var console = goog.global["console"];
        if (console && console["timeStamp"]) console["timeStamp"](msg)
    }
};
goog.debug.Logger.prototype.getName = function() {
    return this.name_
};
goog.debug.Logger.prototype.addHandler = function(handler) {
    if (goog.debug.LOGGING_ENABLED)
        if (goog.debug.Logger.ENABLE_HIERARCHY) {
            if (!this.handlers_) this.handlers_ = [];
            this.handlers_.push(handler)
        } else {
            goog.asserts.assert(!this.name_, "Cannot call addHandler on a non-root logger when " + "goog.debug.Logger.ENABLE_HIERARCHY is false.");
            goog.debug.Logger.rootHandlers_.push(handler)
        }
};
goog.debug.Logger.prototype.removeHandler = function(handler) {
    if (goog.debug.LOGGING_ENABLED) {
        var handlers = goog.debug.Logger.ENABLE_HIERARCHY ? this.handlers_ : goog.debug.Logger.rootHandlers_;
        return !!handlers && goog.array.remove(handlers, handler)
    } else return false
};
goog.debug.Logger.prototype.getParent = function() {
    return this.parent_
};
goog.debug.Logger.prototype.getChildren = function() {
    if (!this.children_) this.children_ = {};
    return this.children_
};
goog.debug.Logger.prototype.setLevel = function(level) {
    if (goog.debug.LOGGING_ENABLED)
        if (goog.debug.Logger.ENABLE_HIERARCHY) this.level_ = level;
        else {
            goog.asserts.assert(!this.name_, "Cannot call setLevel() on a non-root logger when " + "goog.debug.Logger.ENABLE_HIERARCHY is false.");
            goog.debug.Logger.rootLevel_ = level
        }
};
goog.debug.Logger.prototype.getLevel = function() {
    return goog.debug.LOGGING_ENABLED ? this.level_ : goog.debug.Logger.Level.OFF
};
goog.debug.Logger.prototype.getEffectiveLevel = function() {
    if (!goog.debug.LOGGING_ENABLED) return goog.debug.Logger.Level.OFF;
    if (!goog.debug.Logger.ENABLE_HIERARCHY) return goog.debug.Logger.rootLevel_;
    if (this.level_) return this.level_;
    if (this.parent_) return this.parent_.getEffectiveLevel();
    goog.asserts.fail("Root logger has no level set.");
    return null
};
goog.debug.Logger.prototype.isLoggable = function(level) {
    return goog.debug.LOGGING_ENABLED && level.value >= this.getEffectiveLevel().value
};
goog.debug.Logger.prototype.log = function(level, msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED && this.isLoggable(level)) {
        if (goog.isFunction(msg)) msg = msg();
        this.doLogRecord_(this.getLogRecord(level, msg, opt_exception))
    }
};
goog.debug.Logger.prototype.getLogRecord = function(level, msg, opt_exception) {
    if (goog.debug.LogBuffer.isBufferingEnabled()) var logRecord = goog.debug.LogBuffer.getInstance().addRecord(level, msg, this.name_);
    else logRecord = new goog.debug.LogRecord(level, String(msg), this.name_);
    if (opt_exception) logRecord.setException(opt_exception);
    return logRecord
};
goog.debug.Logger.prototype.shout = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.SHOUT, msg, opt_exception)
};
goog.debug.Logger.prototype.severe = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.SEVERE, msg, opt_exception)
};
goog.debug.Logger.prototype.warning = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.WARNING, msg, opt_exception)
};
goog.debug.Logger.prototype.info = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.INFO, msg, opt_exception)
};
goog.debug.Logger.prototype.config = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.CONFIG, msg, opt_exception)
};
goog.debug.Logger.prototype.fine = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.FINE, msg, opt_exception)
};
goog.debug.Logger.prototype.finer = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.FINER, msg, opt_exception)
};
goog.debug.Logger.prototype.finest = function(msg, opt_exception) {
    if (goog.debug.LOGGING_ENABLED) this.log(goog.debug.Logger.Level.FINEST, msg, opt_exception)
};
goog.debug.Logger.prototype.logRecord = function(logRecord) {
    if (goog.debug.LOGGING_ENABLED && this.isLoggable(logRecord.getLevel())) this.doLogRecord_(logRecord)
};
goog.debug.Logger.prototype.doLogRecord_ = function(logRecord) {
    if (goog.debug.Logger.ENABLE_PROFILER_LOGGING) goog.debug.Logger.logToProfilers("log:" + logRecord.getMessage());
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
        var target = this;
        while (target) {
            target.callPublish_(logRecord);
            target = target.getParent()
        }
    } else
        for (var i = 0, handler; handler = goog.debug.Logger.rootHandlers_[i++];) handler(logRecord)
};
goog.debug.Logger.prototype.callPublish_ = function(logRecord) {
    if (this.handlers_)
        for (var i = 0, handler; handler = this.handlers_[i]; i++) handler(logRecord)
};
goog.debug.Logger.prototype.setParent_ = function(parent) {
    this.parent_ = parent
};
goog.debug.Logger.prototype.addChild_ = function(name, logger) {
    this.getChildren()[name] = logger
};
goog.debug.LogManager = {};
goog.debug.LogManager.loggers_ = {};
goog.debug.LogManager.rootLogger_ = null;
goog.debug.LogManager.initialize = function() {
    if (!goog.debug.LogManager.rootLogger_) {
        goog.debug.LogManager.rootLogger_ = new goog.debug.Logger(goog.debug.Logger.ROOT_LOGGER_NAME);
        goog.debug.LogManager.loggers_[goog.debug.Logger.ROOT_LOGGER_NAME] = goog.debug.LogManager.rootLogger_;
        goog.debug.LogManager.rootLogger_.setLevel(goog.debug.Logger.Level.CONFIG)
    }
};
goog.debug.LogManager.getLoggers = function() {
    return goog.debug.LogManager.loggers_
};
goog.debug.LogManager.getRoot = function() {
    goog.debug.LogManager.initialize();
    return goog.debug.LogManager.rootLogger_
};
goog.debug.LogManager.getLogger = function(name) {
    goog.debug.LogManager.initialize();
    var ret = goog.debug.LogManager.loggers_[name];
    return ret || goog.debug.LogManager.createLogger_(name)
};
goog.debug.LogManager.createFunctionForCatchErrors = function(opt_logger) {
    return function(info) {
        var logger = opt_logger || goog.debug.LogManager.getRoot();
        logger.severe("Error: " + info.message + " (" + info.fileName + " @ Line: " + info.line + ")")
    }
};
goog.debug.LogManager.createLogger_ = function(name) {
    var logger = new goog.debug.Logger(name);
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
        var lastDotIndex = name.lastIndexOf(".");
        var parentName = name.substr(0, lastDotIndex);
        var leafName = name.substr(lastDotIndex + 1);
        var parentLogger = goog.debug.LogManager.getLogger(parentName);
        parentLogger.addChild_(leafName, logger);
        logger.setParent_(parentLogger)
    }
    goog.debug.LogManager.loggers_[name] = logger;
    return logger
};
goog.provide("goog.log");
goog.provide("goog.log.Level");
goog.provide("goog.log.LogRecord");
goog.provide("goog.log.Logger");
goog.require("goog.debug");
goog.require("goog.debug.LogManager");
goog.require("goog.debug.LogRecord");
goog.require("goog.debug.Logger");
goog.define("goog.log.ENABLED", goog.debug.LOGGING_ENABLED);
goog.log.ROOT_LOGGER_NAME = goog.debug.Logger.ROOT_LOGGER_NAME;
goog.log.Logger = goog.debug.Logger;
goog.log.Level = goog.debug.Logger.Level;
goog.log.LogRecord = goog.debug.LogRecord;
goog.log.getLogger = function(name, opt_level) {
    if (goog.log.ENABLED) {
        var logger = goog.debug.LogManager.getLogger(name);
        if (opt_level && logger) logger.setLevel(opt_level);
        return logger
    } else return null
};
goog.log.addHandler = function(logger, handler) {
    if (goog.log.ENABLED && logger) logger.addHandler(handler)
};
goog.log.removeHandler = function(logger, handler) {
    if (goog.log.ENABLED && logger) return logger.removeHandler(handler);
    else return false
};
goog.log.log = function(logger, level, msg, opt_exception) {
    if (goog.log.ENABLED && logger) logger.log(level, msg, opt_exception)
};
goog.log.error = function(logger, msg, opt_exception) {
    if (goog.log.ENABLED && logger) logger.severe(msg, opt_exception)
};
goog.log.warning = function(logger, msg, opt_exception) {
    if (goog.log.ENABLED && logger) logger.warning(msg, opt_exception)
};
goog.log.info = function(logger, msg, opt_exception) {
    if (goog.log.ENABLED && logger) logger.info(msg, opt_exception)
};
goog.log.fine = function(logger, msg, opt_exception) {
    if (goog.log.ENABLED && logger) logger.fine(msg, opt_exception)
};
goog.provide("goog.Thenable");
goog.forwardDeclare("goog.Promise");
goog.Thenable = function() {};
goog.Thenable.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {};
goog.Thenable.IMPLEMENTED_BY_PROP = "$goog_Thenable";
goog.Thenable.addImplementation = function(ctor) {
    if (COMPILED) ctor.prototype[goog.Thenable.IMPLEMENTED_BY_PROP] = true;
    else ctor.prototype.$goog_Thenable = true
};
goog.Thenable.isImplementedBy = function(object) {
    if (!object) return false;
    try {
        if (COMPILED) return !!object[goog.Thenable.IMPLEMENTED_BY_PROP];
        return !!object.$goog_Thenable
    } catch (e) {
        return false
    }
};
goog.provide("goog.async.FreeList");
goog.async.FreeList = goog.defineClass(null, {
    constructor: function(create, reset, limit) {
        this.limit_ = limit;
        this.create_ = create;
        this.reset_ = reset;
        this.occupants_ = 0;
        this.head_ = null
    },
    get: function() {
        var item;
        if (this.occupants_ > 0) {
            this.occupants_--;
            item = this.head_;
            this.head_ = item.next;
            item.next = null
        } else item = this.create_();
        return item
    },
    put: function(item) {
        this.reset_(item);
        if (this.occupants_ < this.limit_) {
            this.occupants_++;
            item.next = this.head_;
            this.head_ = item
        }
    },
    occupants: function() {
        return this.occupants_
    }
});
goog.provide("goog.async.WorkItem");
goog.provide("goog.async.WorkQueue");
goog.require("goog.asserts");
goog.require("goog.async.FreeList");
goog.async.WorkQueue = function() {
    this.workHead_ = null;
    this.workTail_ = null
};
goog.define("goog.async.WorkQueue.DEFAULT_MAX_UNUSED", 100);
goog.async.WorkQueue.freelist_ = new goog.async.FreeList(function() {
    return new goog.async.WorkItem
}, function(item) {
    item.reset()
}, goog.async.WorkQueue.DEFAULT_MAX_UNUSED);
goog.async.WorkQueue.prototype.add = function(fn, scope) {
    var item = this.getUnusedItem_();
    item.set(fn, scope);
    if (this.workTail_) {
        this.workTail_.next = item;
        this.workTail_ = item
    } else {
        goog.asserts.assert(!this.workHead_);
        this.workHead_ = item;
        this.workTail_ = item
    }
};
goog.async.WorkQueue.prototype.remove = function() {
    var item = null;
    if (this.workHead_) {
        item = this.workHead_;
        this.workHead_ = this.workHead_.next;
        if (!this.workHead_) this.workTail_ = null;
        item.next = null
    }
    return item
};
goog.async.WorkQueue.prototype.returnUnused = function(item) {
    goog.async.WorkQueue.freelist_.put(item)
};
goog.async.WorkQueue.prototype.getUnusedItem_ = function() {
    return goog.async.WorkQueue.freelist_.get()
};
goog.async.WorkItem = function() {
    this.fn = null;
    this.scope = null;
    this.next = null
};
goog.async.WorkItem.prototype.set = function(fn, scope) {
    this.fn = fn;
    this.scope = scope;
    this.next = null
};
goog.async.WorkItem.prototype.reset = function() {
    this.fn = null;
    this.scope = null;
    this.next = null
};
goog.provide("goog.async.nextTick");
goog.provide("goog.async.throwException");
goog.require("goog.debug.entryPointRegistry");
goog.require("goog.dom.TagName");
goog.require("goog.functions");
goog.require("goog.labs.userAgent.browser");
goog.require("goog.labs.userAgent.engine");
goog.async.throwException = function(exception) {
    goog.global.setTimeout(function() {
        throw exception;
    }, 0)
};
goog.async.nextTick = function(callback, opt_context, opt_useSetImmediate) {
    var cb = callback;
    if (opt_context) cb = goog.bind(callback, opt_context);
    cb = goog.async.nextTick.wrapCallback_(cb);
    if (goog.isFunction(goog.global.setImmediate) && (opt_useSetImmediate || goog.async.nextTick.useSetImmediate_())) {
        goog.global.setImmediate(cb);
        return
    }
    if (!goog.async.nextTick.setImmediate_) goog.async.nextTick.setImmediate_ = goog.async.nextTick.getSetImmediateEmulator_();
    goog.async.nextTick.setImmediate_(cb)
};
goog.async.nextTick.useSetImmediate_ = function() {
    if (!goog.global.Window || !goog.global.Window.prototype) return true;
    if (goog.labs.userAgent.browser.isEdge() || goog.global.Window.prototype.setImmediate != goog.global.setImmediate) return true;
    return false
};
goog.async.nextTick.setImmediate_;
goog.async.nextTick.getSetImmediateEmulator_ = function() {
    var Channel = goog.global["MessageChannel"];
    if (typeof Channel === "undefined" && typeof window !== "undefined" && window.postMessage && window.addEventListener && !goog.labs.userAgent.engine.isPresto()) Channel = function() {
        var iframe = document.createElement(String(goog.dom.TagName.IFRAME));
        iframe.style.display = "none";
        iframe.src = "";
        document.documentElement.appendChild(iframe);
        var win = iframe.contentWindow;
        var doc = win.document;
        doc.open();
        doc.write("");
        doc.close();
        var message = "callImmediate" + Math.random();
        var origin = win.location.protocol == "file:" ? "*" : win.location.protocol + "//" + win.location.host;
        var onmessage = goog.bind(function(e) {
            if (origin != "*" && e.origin != origin || e.data != message) return;
            this["port1"].onmessage()
        }, this);
        win.addEventListener("message", onmessage, false);
        this["port1"] = {};
        this["port2"] = {
            postMessage: function() {
                win.postMessage(message, origin)
            }
        }
    };
    if (typeof Channel !== "undefined" && !goog.labs.userAgent.browser.isIE()) {
        var channel = new Channel;
        var head = {};
        var tail = head;
        channel["port1"].onmessage = function() {
            if (goog.isDef(head.next)) {
                head = head.next;
                var cb = head.cb;
                head.cb = null;
                cb()
            }
        };
        return function(cb) {
            tail.next = {
                cb: cb
            };
            tail = tail.next;
            channel["port2"].postMessage(0)
        }
    }
    if (typeof document !== "undefined" && "onreadystatechange" in document.createElement(String(goog.dom.TagName.SCRIPT))) return function(cb) {
        var script = document.createElement(String(goog.dom.TagName.SCRIPT));
        script.onreadystatechange = function() {
            script.onreadystatechange = null;
            script.parentNode.removeChild(script);
            script = null;
            cb();
            cb = null
        };
        document.documentElement.appendChild(script)
    };
    return function(cb) {
        goog.global.setTimeout(cb, 0)
    }
};
goog.async.nextTick.wrapCallback_ = goog.functions.identity;
goog.debug.entryPointRegistry.register(function(transformer) {
    goog.async.nextTick.wrapCallback_ = transformer
});
goog.provide("goog.async.run");
goog.require("goog.async.WorkQueue");
goog.require("goog.async.nextTick");
goog.require("goog.async.throwException");
goog.define("goog.ASSUME_NATIVE_PROMISE", false);
goog.async.run = function(callback, opt_context) {
    if (!goog.async.run.schedule_) goog.async.run.initializeRunner_();
    if (!goog.async.run.workQueueScheduled_) {
        goog.async.run.schedule_();
        goog.async.run.workQueueScheduled_ = true
    }
    goog.async.run.workQueue_.add(callback, opt_context)
};
goog.async.run.initializeRunner_ = function() {
    if (goog.ASSUME_NATIVE_PROMISE || goog.global.Promise && goog.global.Promise.resolve) {
        var promise = goog.global.Promise.resolve(undefined);
        goog.async.run.schedule_ = function() {
            promise.then(goog.async.run.processWorkQueue)
        }
    } else goog.async.run.schedule_ = function() {
        goog.async.nextTick(goog.async.run.processWorkQueue)
    }
};
goog.async.run.forceNextTick = function(opt_realSetTimeout) {
    goog.async.run.schedule_ = function() {
        goog.async.nextTick(goog.async.run.processWorkQueue);
        if (opt_realSetTimeout) opt_realSetTimeout(goog.async.run.processWorkQueue)
    }
};
goog.async.run.schedule_;
goog.async.run.workQueueScheduled_ = false;
goog.async.run.workQueue_ = new goog.async.WorkQueue;
if (goog.DEBUG) goog.async.run.resetQueue = function() {
    goog.async.run.workQueueScheduled_ = false;
    goog.async.run.workQueue_ = new goog.async.WorkQueue
};
goog.async.run.processWorkQueue = function() {
    var item = null;
    while (item = goog.async.run.workQueue_.remove()) {
        try {
            item.fn.call(item.scope)
        } catch (e) {
            goog.async.throwException(e)
        }
        goog.async.run.workQueue_.returnUnused(item)
    }
    goog.async.run.workQueueScheduled_ = false
};
goog.provide("goog.promise.Resolver");
goog.forwardDeclare("goog.Promise");
goog.promise.Resolver = function() {};
goog.promise.Resolver.prototype.promise;
goog.promise.Resolver.prototype.resolve;
goog.promise.Resolver.prototype.reject;
goog.provide("goog.Promise");
goog.require("goog.Thenable");
goog.require("goog.asserts");
goog.require("goog.async.FreeList");
goog.require("goog.async.run");
goog.require("goog.async.throwException");
goog.require("goog.debug.Error");
goog.require("goog.promise.Resolver");
goog.Promise = function(resolver, opt_context) {
    this.state_ = goog.Promise.State_.PENDING;
    this.result_ = undefined;
    this.parent_ = null;
    this.callbackEntries_ = null;
    this.callbackEntriesTail_ = null;
    this.executing_ = false;
    if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) this.unhandledRejectionId_ = 0;
    else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) this.hadUnhandledRejection_ = false;
    if (goog.Promise.LONG_STACK_TRACES) {
        this.stack_ = [];
        this.addStackTrace_(new Error("created"));
        this.currentStep_ = 0
    }
    if (resolver != goog.nullFunction) try {
        var self =
            this;
        resolver.call(opt_context, function(value) {
            self.resolve_(goog.Promise.State_.FULFILLED, value)
        }, function(reason) {
            if (goog.DEBUG && !(reason instanceof goog.Promise.CancellationError)) try {
                if (reason instanceof Error) throw reason;
                else throw new Error("Promise rejected.");
            } catch (e) {}
            self.resolve_(goog.Promise.State_.REJECTED, reason)
        })
    } catch (e) {
        this.resolve_(goog.Promise.State_.REJECTED, e)
    }
};
goog.define("goog.Promise.LONG_STACK_TRACES", false);
goog.define("goog.Promise.UNHANDLED_REJECTION_DELAY", 0);
goog.Promise.State_ = {
    PENDING: 0,
    BLOCKED: 1,
    FULFILLED: 2,
    REJECTED: 3
};
goog.Promise.CallbackEntry_ = function() {
    this.child = null;
    this.onFulfilled = null;
    this.onRejected = null;
    this.context = null;
    this.next = null;
    this.always = false
};
goog.Promise.CallbackEntry_.prototype.reset = function() {
    this.child = null;
    this.onFulfilled = null;
    this.onRejected = null;
    this.context = null;
    this.always = false
};
goog.define("goog.Promise.DEFAULT_MAX_UNUSED", 100);
goog.Promise.freelist_ = new goog.async.FreeList(function() {
    return new goog.Promise.CallbackEntry_
}, function(item) {
    item.reset()
}, goog.Promise.DEFAULT_MAX_UNUSED);
goog.Promise.getCallbackEntry_ = function(onFulfilled, onRejected, context) {
    var entry = goog.Promise.freelist_.get();
    entry.onFulfilled = onFulfilled;
    entry.onRejected = onRejected;
    entry.context = context;
    return entry
};
goog.Promise.returnEntry_ = function(entry) {
    goog.Promise.freelist_.put(entry)
};
goog.Promise.resolve = function(opt_value) {
    if (opt_value instanceof goog.Promise) return opt_value;
    var promise = new goog.Promise(goog.nullFunction);
    promise.resolve_(goog.Promise.State_.FULFILLED, opt_value);
    return promise
};
goog.Promise.reject = function(opt_reason) {
    return new goog.Promise(function(resolve, reject) {
        reject(opt_reason)
    })
};
goog.Promise.resolveThen_ = function(value, onFulfilled, onRejected) {
    var isThenable = goog.Promise.maybeThen_(value, onFulfilled, onRejected, null);
    if (!isThenable) goog.async.run(goog.partial(onFulfilled, value))
};
goog.Promise.race = function(promises) {
    return new goog.Promise(function(resolve, reject) {
        if (!promises.length) resolve(undefined);
        for (var i = 0, promise; i < promises.length; i++) {
            promise = promises[i];
            goog.Promise.resolveThen_(promise, resolve, reject)
        }
    })
};
goog.Promise.all = function(promises) {
    return new goog.Promise(function(resolve, reject) {
        var toFulfill = promises.length;
        var values = [];
        if (!toFulfill) {
            resolve(values);
            return
        }
        var onFulfill = function(index, value) {
            toFulfill--;
            values[index] = value;
            if (toFulfill == 0) resolve(values)
        };
        var onReject = function(reason) {
            reject(reason)
        };
        for (var i = 0, promise; i < promises.length; i++) {
            promise = promises[i];
            goog.Promise.resolveThen_(promise, goog.partial(onFulfill, i), onReject)
        }
    })
};
goog.Promise.allSettled = function(promises) {
    return new goog.Promise(function(resolve, reject) {
        var toSettle = promises.length;
        var results = [];
        if (!toSettle) {
            resolve(results);
            return
        }
        var onSettled = function(index, fulfilled, result) {
            toSettle--;
            results[index] = fulfilled ? {
                fulfilled: true,
                value: result
            } : {
                fulfilled: false,
                reason: result
            };
            if (toSettle == 0) resolve(results)
        };
        for (var i = 0, promise; i < promises.length; i++) {
            promise = promises[i];
            goog.Promise.resolveThen_(promise, goog.partial(onSettled, i, true), goog.partial(onSettled,
                i, false))
        }
    })
};
goog.Promise.firstFulfilled = function(promises) {
    return new goog.Promise(function(resolve, reject) {
        var toReject = promises.length;
        var reasons = [];
        if (!toReject) {
            resolve(undefined);
            return
        }
        var onFulfill = function(value) {
            resolve(value)
        };
        var onReject = function(index, reason) {
            toReject--;
            reasons[index] = reason;
            if (toReject == 0) reject(reasons)
        };
        for (var i = 0, promise; i < promises.length; i++) {
            promise = promises[i];
            goog.Promise.resolveThen_(promise, onFulfill, goog.partial(onReject, i))
        }
    })
};
goog.Promise.withResolver = function() {
    var resolve, reject;
    var promise = new goog.Promise(function(rs, rj) {
        resolve = rs;
        reject = rj
    });
    return new goog.Promise.Resolver_(promise, resolve, reject)
};
goog.Promise.prototype.then = function(opt_onFulfilled, opt_onRejected, opt_context) {
    if (opt_onFulfilled != null) goog.asserts.assertFunction(opt_onFulfilled, "opt_onFulfilled should be a function.");
    if (opt_onRejected != null) goog.asserts.assertFunction(opt_onRejected, "opt_onRejected should be a function. Did you pass opt_context " + "as the second argument instead of the third?");
    if (goog.Promise.LONG_STACK_TRACES) this.addStackTrace_(new Error("then"));
    return this.addChildPromise_(goog.isFunction(opt_onFulfilled) ?
        opt_onFulfilled : null, goog.isFunction(opt_onRejected) ? opt_onRejected : null, opt_context)
};
goog.Thenable.addImplementation(goog.Promise);
goog.Promise.prototype.thenVoid = function(opt_onFulfilled, opt_onRejected, opt_context) {
    if (opt_onFulfilled != null) goog.asserts.assertFunction(opt_onFulfilled, "opt_onFulfilled should be a function.");
    if (opt_onRejected != null) goog.asserts.assertFunction(opt_onRejected, "opt_onRejected should be a function. Did you pass opt_context " + "as the second argument instead of the third?");
    if (goog.Promise.LONG_STACK_TRACES) this.addStackTrace_(new Error("then"));
    this.addCallbackEntry_(goog.Promise.getCallbackEntry_(opt_onFulfilled ||
        goog.nullFunction, opt_onRejected || null, opt_context))
};
goog.Promise.prototype.thenAlways = function(onSettled, opt_context) {
    if (goog.Promise.LONG_STACK_TRACES) this.addStackTrace_(new Error("thenAlways"));
    var entry = goog.Promise.getCallbackEntry_(onSettled, onSettled, opt_context);
    entry.always = true;
    this.addCallbackEntry_(entry);
    return this
};
goog.Promise.prototype.thenCatch = function(onRejected, opt_context) {
    if (goog.Promise.LONG_STACK_TRACES) this.addStackTrace_(new Error("thenCatch"));
    return this.addChildPromise_(null, onRejected, opt_context)
};
goog.Promise.prototype.cancel = function(opt_message) {
    if (this.state_ == goog.Promise.State_.PENDING) goog.async.run(function() {
        var err = new goog.Promise.CancellationError(opt_message);
        this.cancelInternal_(err)
    }, this)
};
goog.Promise.prototype.cancelInternal_ = function(err) {
    if (this.state_ == goog.Promise.State_.PENDING)
        if (this.parent_) {
            this.parent_.cancelChild_(this, err);
            this.parent_ = null
        } else this.resolve_(goog.Promise.State_.REJECTED, err)
};
goog.Promise.prototype.cancelChild_ = function(childPromise, err) {
    if (!this.callbackEntries_) return;
    var childCount = 0;
    var childEntry = null;
    var beforeChildEntry = null;
    for (var entry = this.callbackEntries_; entry; entry = entry.next) {
        if (!entry.always) {
            childCount++;
            if (entry.child == childPromise) childEntry = entry;
            if (childEntry && childCount > 1) break
        }
        if (!childEntry) beforeChildEntry = entry
    }
    if (childEntry)
        if (this.state_ == goog.Promise.State_.PENDING && childCount == 1) this.cancelInternal_(err);
        else {
            if (beforeChildEntry) this.removeEntryAfter_(beforeChildEntry);
            else this.popEntry_();
            this.executeCallback_(childEntry, goog.Promise.State_.REJECTED, err)
        }
};
goog.Promise.prototype.addCallbackEntry_ = function(callbackEntry) {
    if (!this.hasEntry_() && (this.state_ == goog.Promise.State_.FULFILLED || this.state_ == goog.Promise.State_.REJECTED)) this.scheduleCallbacks_();
    this.queueEntry_(callbackEntry)
};
goog.Promise.prototype.addChildPromise_ = function(onFulfilled, onRejected, opt_context) {
    var callbackEntry = goog.Promise.getCallbackEntry_(null, null, null);
    callbackEntry.child = new goog.Promise(function(resolve, reject) {
        callbackEntry.onFulfilled = onFulfilled ? function(value) {
            try {
                var result = onFulfilled.call(opt_context, value);
                resolve(result)
            } catch (err) {
                reject(err)
            }
        } : resolve;
        callbackEntry.onRejected = onRejected ? function(reason) {
            try {
                var result = onRejected.call(opt_context, reason);
                if (!goog.isDef(result) && reason instanceof goog.Promise.CancellationError) reject(reason);
                else resolve(result)
            } catch (err) {
                reject(err)
            }
        } : reject
    });
    callbackEntry.child.parent_ = this;
    this.addCallbackEntry_(callbackEntry);
    return callbackEntry.child
};
goog.Promise.prototype.unblockAndFulfill_ = function(value) {
    goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);
    this.state_ = goog.Promise.State_.PENDING;
    this.resolve_(goog.Promise.State_.FULFILLED, value)
};
goog.Promise.prototype.unblockAndReject_ = function(reason) {
    goog.asserts.assert(this.state_ == goog.Promise.State_.BLOCKED);
    this.state_ = goog.Promise.State_.PENDING;
    this.resolve_(goog.Promise.State_.REJECTED, reason)
};
goog.Promise.prototype.resolve_ = function(state, x) {
    if (this.state_ != goog.Promise.State_.PENDING) return;
    if (this === x) {
        state = goog.Promise.State_.REJECTED;
        x = new TypeError("Promise cannot resolve to itself")
    }
    this.state_ = goog.Promise.State_.BLOCKED;
    var isThenable = goog.Promise.maybeThen_(x, this.unblockAndFulfill_, this.unblockAndReject_, this);
    if (isThenable) return;
    this.result_ = x;
    this.state_ = state;
    this.parent_ = null;
    this.scheduleCallbacks_();
    if (state == goog.Promise.State_.REJECTED && !(x instanceof goog.Promise.CancellationError)) goog.Promise.addUnhandledRejection_(this,
        x)
};
goog.Promise.maybeThen_ = function(value, onFulfilled, onRejected, context) {
    if (value instanceof goog.Promise) {
        value.thenVoid(onFulfilled, onRejected, context);
        return true
    } else if (goog.Thenable.isImplementedBy(value)) {
        value = value;
        value.then(onFulfilled, onRejected, context);
        return true
    } else if (goog.isObject(value)) try {
        var then = value["then"];
        if (goog.isFunction(then)) {
            goog.Promise.tryThen_(value, then, onFulfilled, onRejected, context);
            return true
        }
    } catch (e) {
        onRejected.call(context, e);
        return true
    }
    return false
};
goog.Promise.tryThen_ = function(thenable, then, onFulfilled, onRejected, context) {
    var called = false;
    var resolve = function(value) {
        if (!called) {
            called = true;
            onFulfilled.call(context, value)
        }
    };
    var reject = function(reason) {
        if (!called) {
            called = true;
            onRejected.call(context, reason)
        }
    };
    try {
        then.call(thenable, resolve, reject)
    } catch (e) {
        reject(e)
    }
};
goog.Promise.prototype.scheduleCallbacks_ = function() {
    if (!this.executing_) {
        this.executing_ = true;
        goog.async.run(this.executeCallbacks_, this)
    }
};
goog.Promise.prototype.hasEntry_ = function() {
    return !!this.callbackEntries_
};
goog.Promise.prototype.queueEntry_ = function(entry) {
    goog.asserts.assert(entry.onFulfilled != null);
    if (this.callbackEntriesTail_) {
        this.callbackEntriesTail_.next = entry;
        this.callbackEntriesTail_ = entry
    } else {
        this.callbackEntries_ = entry;
        this.callbackEntriesTail_ = entry
    }
};
goog.Promise.prototype.popEntry_ = function() {
    var entry = null;
    if (this.callbackEntries_) {
        entry = this.callbackEntries_;
        this.callbackEntries_ = entry.next;
        entry.next = null
    }
    if (!this.callbackEntries_) this.callbackEntriesTail_ = null;
    if (entry != null) goog.asserts.assert(entry.onFulfilled != null);
    return entry
};
goog.Promise.prototype.removeEntryAfter_ = function(previous) {
    goog.asserts.assert(this.callbackEntries_);
    goog.asserts.assert(previous != null);
    if (previous.next == this.callbackEntriesTail_) this.callbackEntriesTail_ = previous;
    previous.next = previous.next.next
};
goog.Promise.prototype.executeCallbacks_ = function() {
    var entry = null;
    while (entry = this.popEntry_()) {
        if (goog.Promise.LONG_STACK_TRACES) this.currentStep_++;
        this.executeCallback_(entry, this.state_, this.result_)
    }
    this.executing_ = false
};
goog.Promise.prototype.executeCallback_ = function(callbackEntry, state, result) {
    if (state == goog.Promise.State_.REJECTED && callbackEntry.onRejected && !callbackEntry.always) this.removeUnhandledRejection_();
    if (callbackEntry.child) {
        callbackEntry.child.parent_ = null;
        goog.Promise.invokeCallback_(callbackEntry, state, result)
    } else try {
        callbackEntry.always ? callbackEntry.onFulfilled.call(callbackEntry.context) : goog.Promise.invokeCallback_(callbackEntry, state, result)
    } catch (err) {
        goog.Promise.handleRejection_.call(null,
            err)
    }
    goog.Promise.returnEntry_(callbackEntry)
};
goog.Promise.invokeCallback_ = function(callbackEntry, state, result) {
    if (state == goog.Promise.State_.FULFILLED) callbackEntry.onFulfilled.call(callbackEntry.context, result);
    else if (callbackEntry.onRejected) callbackEntry.onRejected.call(callbackEntry.context, result)
};
goog.Promise.prototype.addStackTrace_ = function(err) {
    if (goog.Promise.LONG_STACK_TRACES && goog.isString(err.stack)) {
        var trace = err.stack.split("\n", 4)[3];
        var message = err.message;
        message += Array(11 - message.length).join(" ");
        this.stack_.push(message + trace)
    }
};
goog.Promise.prototype.appendLongStack_ = function(err) {
    if (goog.Promise.LONG_STACK_TRACES && err && goog.isString(err.stack) && this.stack_.length) {
        var longTrace = ["Promise trace:"];
        for (var promise = this; promise; promise = promise.parent_) {
            for (var i = this.currentStep_; i >= 0; i--) longTrace.push(promise.stack_[i]);
            longTrace.push("Value: " + "[" + (promise.state_ == goog.Promise.State_.REJECTED ? "REJECTED" : "FULFILLED") + "] " + "<" + String(promise.result_) + ">")
        }
        err.stack += "\n\n" + longTrace.join("\n")
    }
};
goog.Promise.prototype.removeUnhandledRejection_ = function() {
    if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0)
        for (var p = this; p && p.unhandledRejectionId_; p = p.parent_) {
            goog.global.clearTimeout(p.unhandledRejectionId_);
            p.unhandledRejectionId_ = 0
        } else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0)
            for (var p = this; p && p.hadUnhandledRejection_; p = p.parent_) p.hadUnhandledRejection_ = false
};
goog.Promise.addUnhandledRejection_ = function(promise, reason) {
    if (goog.Promise.UNHANDLED_REJECTION_DELAY > 0) promise.unhandledRejectionId_ = goog.global.setTimeout(function() {
        promise.appendLongStack_(reason);
        goog.Promise.handleRejection_.call(null, reason)
    }, goog.Promise.UNHANDLED_REJECTION_DELAY);
    else if (goog.Promise.UNHANDLED_REJECTION_DELAY == 0) {
        promise.hadUnhandledRejection_ = true;
        goog.async.run(function() {
            if (promise.hadUnhandledRejection_) {
                promise.appendLongStack_(reason);
                goog.Promise.handleRejection_.call(null,
                    reason)
            }
        })
    }
};
goog.Promise.handleRejection_ = goog.async.throwException;
goog.Promise.setUnhandledRejectionHandler = function(handler) {
    goog.Promise.handleRejection_ = handler
};
goog.Promise.CancellationError = function(opt_message) {
    goog.Promise.CancellationError.base(this, "constructor", opt_message)
};
goog.inherits(goog.Promise.CancellationError, goog.debug.Error);
goog.Promise.CancellationError.prototype.name = "cancel";
goog.Promise.Resolver_ = function(promise, resolve, reject) {
    this.promise = promise;
    this.resolve = resolve;
    this.reject = reject
};
goog.provide("goog.Timer");
goog.require("goog.Promise");
goog.require("goog.events.EventTarget");
goog.Timer = function(opt_interval, opt_timerObject) {
    goog.events.EventTarget.call(this);
    this.interval_ = opt_interval || 1;
    this.timerObject_ = opt_timerObject || goog.Timer.defaultTimerObject;
    this.boundTick_ = goog.bind(this.tick_, this);
    this.last_ = goog.now()
};
goog.inherits(goog.Timer, goog.events.EventTarget);
goog.Timer.MAX_TIMEOUT_ = 2147483647;
goog.Timer.INVALID_TIMEOUT_ID_ = -1;
goog.Timer.prototype.enabled = false;
goog.Timer.defaultTimerObject = goog.global;
goog.Timer.intervalScale = .8;
goog.Timer.prototype.timer_ = null;
goog.Timer.prototype.getInterval = function() {
    return this.interval_
};
goog.Timer.prototype.setInterval = function(interval) {
    this.interval_ = interval;
    if (this.timer_ && this.enabled) {
        this.stop();
        this.start()
    } else if (this.timer_) this.stop()
};
goog.Timer.prototype.tick_ = function() {
    if (this.enabled) {
        var elapsed = goog.now() - this.last_;
        if (elapsed > 0 && elapsed < this.interval_ * goog.Timer.intervalScale) {
            this.timer_ = this.timerObject_.setTimeout(this.boundTick_, this.interval_ - elapsed);
            return
        }
        if (this.timer_) {
            this.timerObject_.clearTimeout(this.timer_);
            this.timer_ = null
        }
        this.dispatchTick();
        if (this.enabled) {
            this.stop();
            this.start()
        }
    }
};
goog.Timer.prototype.dispatchTick = function() {
    this.dispatchEvent(goog.Timer.TICK)
};
goog.Timer.prototype.start = function() {
    this.enabled = true;
    if (!this.timer_) {
        this.timer_ = this.timerObject_.setTimeout(this.boundTick_, this.interval_);
        this.last_ = goog.now()
    }
};
goog.Timer.prototype.stop = function() {
    this.enabled = false;
    if (this.timer_) {
        this.timerObject_.clearTimeout(this.timer_);
        this.timer_ = null
    }
};
goog.Timer.prototype.disposeInternal = function() {
    goog.Timer.superClass_.disposeInternal.call(this);
    this.stop();
    delete this.timerObject_
};
goog.Timer.TICK = "tick";
goog.Timer.callOnce = function(listener, opt_delay, opt_handler) {
    if (goog.isFunction(listener)) {
        if (opt_handler) listener = goog.bind(listener, opt_handler)
    } else if (listener && typeof listener.handleEvent == "function") listener = goog.bind(listener.handleEvent, listener);
    else throw new Error("Invalid listener argument");
    if (Number(opt_delay) > goog.Timer.MAX_TIMEOUT_) return goog.Timer.INVALID_TIMEOUT_ID_;
    else return goog.Timer.defaultTimerObject.setTimeout(listener, opt_delay || 0)
};
goog.Timer.clear = function(timerId) {
    goog.Timer.defaultTimerObject.clearTimeout(timerId)
};
goog.Timer.promise = function(delay, opt_result) {
    var timerKey = null;
    return (new goog.Promise(function(resolve, reject) {
        timerKey = goog.Timer.callOnce(function() {
            resolve(opt_result)
        }, delay);
        if (timerKey == goog.Timer.INVALID_TIMEOUT_ID_) reject(new Error("Failed to schedule timer."))
    })).thenCatch(function(error) {
        goog.Timer.clear(timerKey);
        throw error;
    })
};
goog.provide("goog.string.StringBuffer");
goog.string.StringBuffer = function(opt_a1, var_args) {
    if (opt_a1 != null) this.append.apply(this, arguments)
};
goog.string.StringBuffer.prototype.buffer_ = "";
goog.string.StringBuffer.prototype.set = function(s) {
    this.buffer_ = "" + s
};
goog.string.StringBuffer.prototype.append = function(a1, opt_a2, var_args) {
    this.buffer_ += String(a1);
    if (opt_a2 != null)
        for (var i = 1; i < arguments.length; i++) this.buffer_ += arguments[i];
    return this
};
goog.string.StringBuffer.prototype.clear = function() {
    this.buffer_ = ""
};
goog.string.StringBuffer.prototype.getLength = function() {
    return this.buffer_.length
};
goog.string.StringBuffer.prototype.toString = function() {
    return this.buffer_
};
goog.provide("goog.ui.tree.BaseNode");
goog.provide("goog.ui.tree.BaseNode.EventType");
goog.require("goog.Timer");
goog.require("goog.a11y.aria");
goog.require("goog.a11y.aria.State");
goog.require("goog.asserts");
goog.require("goog.dom.safe");
goog.require("goog.events.Event");
goog.require("goog.events.KeyCodes");
goog.require("goog.html.SafeHtml");
goog.require("goog.html.SafeStyle");
goog.require("goog.string");
goog.require("goog.string.StringBuffer");
goog.require("goog.style");
goog.require("goog.ui.Component");
goog.forwardDeclare("goog.ui.tree.TreeControl");
goog.ui.tree.BaseNode = function(content, opt_config, opt_domHelper) {
    goog.ui.Component.call(this, opt_domHelper);
    this.config_ = opt_config || goog.ui.tree.BaseNode.defaultConfig;
    this.html_ = goog.html.SafeHtml.htmlEscapePreservingNewlines(content);
    this.iconClass_;
    this.expandedIconClass_;
    this.tree;
    this.previousSibling_;
    this.nextSibling_;
    this.firstChild_;
    this.lastChild_;
    this.selected_ = false;
    this.expanded_ = false;
    this.toolTip_ = null;
    this.afterLabelHtml_ = goog.html.SafeHtml.EMPTY;
    this.isUserCollapsible_ = true;
    this.depth_ = -1
};
goog.inherits(goog.ui.tree.BaseNode, goog.ui.Component);
goog.ui.tree.BaseNode.EventType = {
    BEFORE_EXPAND: "beforeexpand",
    EXPAND: "expand",
    BEFORE_COLLAPSE: "beforecollapse",
    COLLAPSE: "collapse"
};
goog.ui.tree.BaseNode.allNodes = {};
goog.ui.tree.BaseNode.prototype.disposeInternal = function() {
    goog.ui.tree.BaseNode.superClass_.disposeInternal.call(this);
    if (this.tree) {
        this.tree.removeNode(this);
        this.tree = null
    }
    this.setElementInternal(null)
};
goog.ui.tree.BaseNode.prototype.initAccessibility = function() {
    var el = this.getElement();
    if (el) {
        var label = this.getLabelElement();
        if (label && !label.id) label.id = this.getId() + ".label";
        goog.a11y.aria.setRole(el, "treeitem");
        goog.a11y.aria.setState(el, "selected", false);
        goog.a11y.aria.setState(el, "level", this.getDepth());
        if (label) goog.a11y.aria.setState(el, "labelledby", label.id);
        var img = this.getIconElement();
        if (img) goog.a11y.aria.setRole(img, "presentation");
        var ei = this.getExpandIconElement();
        if (ei) goog.a11y.aria.setRole(ei,
            "presentation");
        var ce = this.getChildrenElement();
        if (ce) {
            goog.a11y.aria.setRole(ce, "group");
            if (ce.hasChildNodes()) {
                goog.a11y.aria.setState(el, goog.a11y.aria.State.EXPANDED, false);
                var count = this.getChildCount();
                for (var i = 1; i <= count; i++) {
                    var child = this.getChildAt(i - 1).getElement();
                    goog.asserts.assert(child, "The child element cannot be null");
                    goog.a11y.aria.setState(child, "setsize", count);
                    goog.a11y.aria.setState(child, "posinset", i)
                }
            }
        }
    }
};
goog.ui.tree.BaseNode.prototype.createDom = function() {
    var element = this.getDomHelper().safeHtmlToNode(this.toSafeHtml());
    this.setElementInternal(element)
};
goog.ui.tree.BaseNode.prototype.enterDocument = function() {
    goog.ui.tree.BaseNode.superClass_.enterDocument.call(this);
    goog.ui.tree.BaseNode.allNodes[this.getId()] = this;
    this.initAccessibility()
};
goog.ui.tree.BaseNode.prototype.exitDocument = function() {
    goog.ui.tree.BaseNode.superClass_.exitDocument.call(this);
    delete goog.ui.tree.BaseNode.allNodes[this.getId()]
};
goog.ui.tree.BaseNode.prototype.addChildAt = function(child, index, opt_render) {
    goog.asserts.assert(!child.getParent());
    goog.asserts.assertInstanceof(child, goog.ui.tree.BaseNode);
    var prevNode = this.getChildAt(index - 1);
    var nextNode = this.getChildAt(index);
    goog.ui.tree.BaseNode.superClass_.addChildAt.call(this, child, index);
    child.previousSibling_ = prevNode;
    child.nextSibling_ = nextNode;
    if (prevNode) prevNode.nextSibling_ = child;
    else this.firstChild_ = child;
    if (nextNode) nextNode.previousSibling_ = child;
    else this.lastChild_ =
        child;
    var tree = this.getTree();
    if (tree) child.setTreeInternal(tree);
    child.setDepth_(this.getDepth() + 1);
    var el = this.getElement();
    if (el) {
        this.updateExpandIcon();
        goog.a11y.aria.setState(el, goog.a11y.aria.State.EXPANDED, this.getExpanded());
        if (this.getExpanded()) {
            var childrenEl = this.getChildrenElement();
            if (!child.getElement()) child.createDom();
            var childElement = child.getElement();
            var nextElement = nextNode && nextNode.getElement();
            childrenEl.insertBefore(childElement, nextElement);
            if (this.isInDocument()) child.enterDocument();
            if (!nextNode)
                if (prevNode) prevNode.updateExpandIcon();
                else {
                    goog.style.setElementShown(childrenEl, true);
                    this.setExpanded(this.getExpanded())
                }
        }
    }
};
goog.ui.tree.BaseNode.prototype.add = function(child, opt_before) {
    goog.asserts.assert(!opt_before || opt_before.getParent() == this, "Can only add nodes before siblings");
    if (child.getParent()) child.getParent().removeChild(child);
    this.addChildAt(child, opt_before ? this.indexOfChild(opt_before) : this.getChildCount());
    return child
};
goog.ui.tree.BaseNode.prototype.removeChild = function(childNode, opt_unrender) {
    var child = childNode;
    var tree = this.getTree();
    var selectedNode = tree ? tree.getSelectedItem() : null;
    if (selectedNode == child || child.contains(selectedNode))
        if (tree.hasFocus()) {
            this.select();
            goog.Timer.callOnce(this.onTimeoutSelect_, 10, this)
        } else this.select();
    goog.ui.tree.BaseNode.superClass_.removeChild.call(this, child);
    if (this.lastChild_ == child) this.lastChild_ = child.previousSibling_;
    if (this.firstChild_ == child) this.firstChild_ = child.nextSibling_;
    if (child.previousSibling_) child.previousSibling_.nextSibling_ = child.nextSibling_;
    if (child.nextSibling_) child.nextSibling_.previousSibling_ = child.previousSibling_;
    var wasLast = child.isLastSibling();
    child.tree = null;
    child.depth_ = -1;
    if (tree) {
        tree.removeNode(child);
        if (this.isInDocument()) {
            var childrenEl = this.getChildrenElement();
            if (child.isInDocument()) {
                var childEl = child.getElement();
                childrenEl.removeChild(childEl);
                child.exitDocument()
            }
            if (wasLast) {
                var newLast = this.getLastChild();
                if (newLast) newLast.updateExpandIcon()
            }
            if (!this.hasChildren()) {
                childrenEl.style.display =
                    "none";
                this.updateExpandIcon();
                this.updateIcon_();
                var el = this.getElement();
                if (el) goog.a11y.aria.removeState(el, goog.a11y.aria.State.EXPANDED)
            }
        }
    }
    return child
};
goog.ui.tree.BaseNode.prototype.remove = goog.ui.tree.BaseNode.prototype.removeChild;
goog.ui.tree.BaseNode.prototype.onTimeoutSelect_ = function() {
    this.select()
};
goog.ui.tree.BaseNode.prototype.getTree = goog.abstractMethod;
goog.ui.tree.BaseNode.prototype.getDepth = function() {
    var depth = this.depth_;
    if (depth < 0) {
        depth = this.computeDepth_();
        this.setDepth_(depth)
    }
    return depth
};
goog.ui.tree.BaseNode.prototype.computeDepth_ = function() {
    var parent = this.getParent();
    if (parent) return parent.getDepth() + 1;
    else return 0
};
goog.ui.tree.BaseNode.prototype.setDepth_ = function(depth) {
    if (depth != this.depth_) {
        this.depth_ = depth;
        var row = this.getRowElement();
        if (row) {
            var indent = this.getPixelIndent_() + "px";
            if (this.isRightToLeft()) row.style.paddingRight = indent;
            else row.style.paddingLeft = indent
        }
        this.forEachChild(function(child) {
            child.setDepth_(depth + 1)
        })
    }
};
goog.ui.tree.BaseNode.prototype.contains = function(node) {
    var current = node;
    while (current) {
        if (current == this) return true;
        current = current.getParent()
    }
    return false
};
goog.ui.tree.BaseNode.EMPTY_CHILDREN_ = [];
goog.ui.tree.BaseNode.prototype.getChildAt;
goog.ui.tree.BaseNode.prototype.getChildren = function() {
    var children = [];
    this.forEachChild(function(child) {
        children.push(child)
    });
    return children
};
goog.ui.tree.BaseNode.prototype.getFirstChild = function() {
    return this.getChildAt(0)
};
goog.ui.tree.BaseNode.prototype.getLastChild = function() {
    return this.getChildAt(this.getChildCount() - 1)
};
goog.ui.tree.BaseNode.prototype.getPreviousSibling = function() {
    return this.previousSibling_
};
goog.ui.tree.BaseNode.prototype.getNextSibling = function() {
    return this.nextSibling_
};
goog.ui.tree.BaseNode.prototype.isLastSibling = function() {
    return !this.nextSibling_
};
goog.ui.tree.BaseNode.prototype.isSelected = function() {
    return this.selected_
};
goog.ui.tree.BaseNode.prototype.select = function() {
    var tree = this.getTree();
    if (tree) tree.setSelectedItem(this)
};
goog.ui.tree.BaseNode.prototype.deselect = goog.nullFunction;
goog.ui.tree.BaseNode.prototype.setSelectedInternal = function(selected) {
    if (this.selected_ == selected) return;
    this.selected_ = selected;
    this.updateRow();
    var el = this.getElement();
    if (el) {
        goog.a11y.aria.setState(el, "selected", selected);
        if (selected) {
            var treeElement = this.getTree().getElement();
            goog.asserts.assert(treeElement, "The DOM element for the tree cannot be null");
            goog.a11y.aria.setState(treeElement, "activedescendant", this.getId())
        }
    }
};
goog.ui.tree.BaseNode.prototype.getExpanded = function() {
    return this.expanded_
};
goog.ui.tree.BaseNode.prototype.setExpandedInternal = function(expanded) {
    this.expanded_ = expanded
};
goog.ui.tree.BaseNode.prototype.setExpanded = function(expanded) {
    var isStateChange = expanded != this.expanded_;
    if (isStateChange) {
        var prevented = !this.dispatchEvent(expanded ? goog.ui.tree.BaseNode.EventType.BEFORE_EXPAND : goog.ui.tree.BaseNode.EventType.BEFORE_COLLAPSE);
        if (prevented) return
    }
    var ce;
    this.expanded_ = expanded;
    var tree = this.getTree();
    var el = this.getElement();
    if (this.hasChildren()) {
        if (!expanded && tree && this.contains(tree.getSelectedItem())) this.select();
        if (el) {
            ce = this.getChildrenElement();
            if (ce) {
                goog.style.setElementShown(ce,
                    expanded);
                goog.a11y.aria.setState(el, goog.a11y.aria.State.EXPANDED, expanded);
                if (expanded && this.isInDocument() && !ce.hasChildNodes()) {
                    var children = [];
                    this.forEachChild(function(child) {
                        children.push(child.toSafeHtml())
                    });
                    goog.dom.safe.setInnerHtml(ce, goog.html.SafeHtml.concat(children));
                    this.forEachChild(function(child) {
                        child.enterDocument()
                    })
                }
            }
            this.updateExpandIcon()
        }
    } else {
        ce = this.getChildrenElement();
        if (ce) goog.style.setElementShown(ce, false)
    }
    if (el) this.updateIcon_();
    if (isStateChange) this.dispatchEvent(expanded ?
        goog.ui.tree.BaseNode.EventType.EXPAND : goog.ui.tree.BaseNode.EventType.COLLAPSE)
};
goog.ui.tree.BaseNode.prototype.toggle = function() {
    this.setExpanded(!this.getExpanded())
};
goog.ui.tree.BaseNode.prototype.expand = function() {
    this.setExpanded(true)
};
goog.ui.tree.BaseNode.prototype.collapse = function() {
    this.setExpanded(false)
};
goog.ui.tree.BaseNode.prototype.collapseChildren = function() {
    this.forEachChild(function(child) {
        child.collapseAll()
    })
};
goog.ui.tree.BaseNode.prototype.collapseAll = function() {
    this.collapseChildren();
    this.collapse()
};
goog.ui.tree.BaseNode.prototype.expandChildren = function() {
    this.forEachChild(function(child) {
        child.expandAll()
    })
};
goog.ui.tree.BaseNode.prototype.expandAll = function() {
    this.expandChildren();
    this.expand()
};
goog.ui.tree.BaseNode.prototype.reveal = function() {
    var parent = this.getParent();
    if (parent) {
        parent.setExpanded(true);
        parent.reveal()
    }
};
goog.ui.tree.BaseNode.prototype.setIsUserCollapsible = function(isCollapsible) {
    this.isUserCollapsible_ = isCollapsible;
    if (!this.isUserCollapsible_) this.expand();
    if (this.getElement()) this.updateExpandIcon()
};
goog.ui.tree.BaseNode.prototype.isUserCollapsible = function() {
    return this.isUserCollapsible_
};
goog.ui.tree.BaseNode.prototype.toSafeHtml = function() {
    var tree = this.getTree();
    var hideLines = !tree.getShowLines() || tree == this.getParent() && !tree.getShowRootLines();
    var childClass = hideLines ? this.config_.cssChildrenNoLines : this.config_.cssChildren;
    var nonEmptyAndExpanded = this.getExpanded() && this.hasChildren();
    var attributes = {
        "class": childClass,
        "style": this.getLineStyle()
    };
    var content = [];
    if (nonEmptyAndExpanded) this.forEachChild(function(child) {
        content.push(child.toSafeHtml())
    });
    var children = goog.html.SafeHtml.create("div",
        attributes, content);
    return goog.html.SafeHtml.create("div", {
        "class": this.config_.cssItem,
        "id": this.getId()
    }, [this.getRowSafeHtml(), children])
};
goog.ui.tree.BaseNode.prototype.getPixelIndent_ = function() {
    return Math.max(0, (this.getDepth() - 1) * this.config_.indentWidth)
};
goog.ui.tree.BaseNode.prototype.getRowSafeHtml = function() {
    var style = {};
    style["padding-" + (this.isRightToLeft() ? "right" : "left")] = this.getPixelIndent_() + "px";
    var attributes = {
        "class": this.getRowClassName(),
        "style": style
    };
    var content = [this.getExpandIconSafeHtml(), this.getIconSafeHtml(), this.getLabelSafeHtml()];
    return goog.html.SafeHtml.create("div", attributes, content)
};
goog.ui.tree.BaseNode.prototype.getRowClassName = function() {
    var selectedClass;
    if (this.isSelected()) selectedClass = " " + this.config_.cssSelectedRow;
    else selectedClass = "";
    return this.config_.cssTreeRow + selectedClass
};
goog.ui.tree.BaseNode.prototype.getLabelSafeHtml = function() {
    var html = goog.html.SafeHtml.create("span", {
        "class": this.config_.cssItemLabel,
        "title": this.getToolTip() || null
    }, this.getSafeHtml());
    return goog.html.SafeHtml.concat(html, goog.html.SafeHtml.create("span", {}, this.getAfterLabelSafeHtml()))
};
goog.ui.tree.BaseNode.prototype.getAfterLabelHtml = function() {
    return goog.html.SafeHtml.unwrap(this.getAfterLabelSafeHtml())
};
goog.ui.tree.BaseNode.prototype.getAfterLabelSafeHtml = function() {
    return this.afterLabelHtml_
};
goog.ui.tree.BaseNode.prototype.setAfterLabelSafeHtml = function(html) {
    this.afterLabelHtml_ = html;
    var el = this.getAfterLabelElement();
    if (el) goog.dom.safe.setInnerHtml(el, html)
};
goog.ui.tree.BaseNode.prototype.getIconSafeHtml = function() {
    return goog.html.SafeHtml.create("span", {
        "style": {
            "display": "inline-block"
        },
        "class": this.getCalculatedIconClass()
    })
};
goog.ui.tree.BaseNode.prototype.getCalculatedIconClass = goog.abstractMethod;
goog.ui.tree.BaseNode.prototype.getExpandIconSafeHtml = function() {
    return goog.html.SafeHtml.create("span", {
        "type": "expand",
        "style": {
            "display": "inline-block"
        },
        "class": this.getExpandIconClass()
    })
};
goog.ui.tree.BaseNode.prototype.getExpandIconClass = function() {
    var tree = this.getTree();
    var hideLines = !tree.getShowLines() || tree == this.getParent() && !tree.getShowRootLines();
    var config = this.config_;
    var sb = new goog.string.StringBuffer;
    sb.append(config.cssTreeIcon, " ", config.cssExpandTreeIcon, " ");
    if (this.hasChildren()) {
        var bits = 0;
        if (tree.getShowExpandIcons() && this.isUserCollapsible_)
            if (this.getExpanded()) bits = 2;
            else bits = 1;
        if (!hideLines)
            if (this.isLastSibling()) bits += 4;
            else bits += 8;
        switch (bits) {
            case 1:
                sb.append(config.cssExpandTreeIconPlus);
                break;
            case 2:
                sb.append(config.cssExpandTreeIconMinus);
                break;
            case 4:
                sb.append(config.cssExpandTreeIconL);
                break;
            case 5:
                sb.append(config.cssExpandTreeIconLPlus);
                break;
            case 6:
                sb.append(config.cssExpandTreeIconLMinus);
                break;
            case 8:
                sb.append(config.cssExpandTreeIconT);
                break;
            case 9:
                sb.append(config.cssExpandTreeIconTPlus);
                break;
            case 10:
                sb.append(config.cssExpandTreeIconTMinus);
                break;
            default:
                sb.append(config.cssExpandTreeIconBlank)
        }
    } else if (hideLines) sb.append(config.cssExpandTreeIconBlank);
    else if (this.isLastSibling()) sb.append(config.cssExpandTreeIconL);
    else sb.append(config.cssExpandTreeIconT);
    return sb.toString()
};
goog.ui.tree.BaseNode.prototype.getLineStyle = function() {
    var nonEmptyAndExpanded = this.getExpanded() && this.hasChildren();
    return goog.html.SafeStyle.create({
        "background-position": this.getBackgroundPosition(),
        "display": nonEmptyAndExpanded ? null : "none"
    })
};
goog.ui.tree.BaseNode.prototype.getBackgroundPosition = function() {
    return (this.isLastSibling() ? "-100" : (this.getDepth() - 1) * this.config_.indentWidth) + "px 0"
};
goog.ui.tree.BaseNode.prototype.getElement = function() {
    var el = goog.ui.tree.BaseNode.superClass_.getElement.call(this);
    if (!el) {
        el = this.getDomHelper().getElement(this.getId());
        this.setElementInternal(el)
    }
    return el
};
goog.ui.tree.BaseNode.prototype.getRowElement = function() {
    var el = this.getElement();
    return el ? el.firstChild : null
};
goog.ui.tree.BaseNode.prototype.getExpandIconElement = function() {
    var el = this.getRowElement();
    return el ? el.firstChild : null
};
goog.ui.tree.BaseNode.prototype.getIconElement = function() {
    var el = this.getRowElement();
    return el ? el.childNodes[1] : null
};
goog.ui.tree.BaseNode.prototype.getLabelElement = function() {
    var el = this.getRowElement();
    return el && el.lastChild ? el.lastChild.previousSibling : null
};
goog.ui.tree.BaseNode.prototype.getAfterLabelElement = function() {
    var el = this.getRowElement();
    return el ? el.lastChild : null
};
goog.ui.tree.BaseNode.prototype.getChildrenElement = function() {
    var el = this.getElement();
    return el ? el.lastChild : null
};
goog.ui.tree.BaseNode.prototype.setIconClass = function(s) {
    this.iconClass_ = s;
    if (this.isInDocument()) this.updateIcon_()
};
goog.ui.tree.BaseNode.prototype.getIconClass = function() {
    return this.iconClass_
};
goog.ui.tree.BaseNode.prototype.setExpandedIconClass = function(s) {
    this.expandedIconClass_ = s;
    if (this.isInDocument()) this.updateIcon_()
};
goog.ui.tree.BaseNode.prototype.getExpandedIconClass = function() {
    return this.expandedIconClass_
};
goog.ui.tree.BaseNode.prototype.setText = function(s) {
    this.setSafeHtml(goog.html.SafeHtml.htmlEscape(s))
};
goog.ui.tree.BaseNode.prototype.getText = function() {
    return goog.string.unescapeEntities(goog.html.SafeHtml.unwrap(this.html_))
};
goog.ui.tree.BaseNode.prototype.setSafeHtml = function(html) {
    this.html_ = html;
    var el = this.getLabelElement();
    if (el) goog.dom.safe.setInnerHtml(el, html);
    var tree = this.getTree();
    if (tree) tree.setNode(this)
};
goog.ui.tree.BaseNode.prototype.getHtml = function() {
    return goog.html.SafeHtml.unwrap(this.getSafeHtml())
};
goog.ui.tree.BaseNode.prototype.getSafeHtml = function() {
    return this.html_
};
goog.ui.tree.BaseNode.prototype.setToolTip = function(s) {
    this.toolTip_ = s;
    var el = this.getLabelElement();
    if (el) el.title = s
};
goog.ui.tree.BaseNode.prototype.getToolTip = function() {
    return this.toolTip_
};
goog.ui.tree.BaseNode.prototype.updateRow = function() {
    var rowEl = this.getRowElement();
    if (rowEl) rowEl.className = this.getRowClassName()
};
goog.ui.tree.BaseNode.prototype.updateExpandIcon = function() {
    var img = this.getExpandIconElement();
    if (img) img.className = this.getExpandIconClass();
    var cel = this.getChildrenElement();
    if (cel) cel.style.backgroundPosition = this.getBackgroundPosition()
};
goog.ui.tree.BaseNode.prototype.updateIcon_ = function() {
    this.getIconElement().className = this.getCalculatedIconClass()
};
goog.ui.tree.BaseNode.prototype.onMouseDown = function(e) {
    var el = e.target;
    var type = el.getAttribute("type");
    if (type == "expand" && this.hasChildren()) {
        if (this.isUserCollapsible_) this.toggle();
        return
    }
    this.select();
    this.updateRow()
};
goog.ui.tree.BaseNode.prototype.onClick_ = goog.events.Event.preventDefault;
goog.ui.tree.BaseNode.prototype.onDoubleClick_ = function(e) {
    var el = e.target;
    var type = el.getAttribute("type");
    if (type == "expand" && this.hasChildren()) return;
    if (this.isUserCollapsible_) this.toggle()
};
goog.ui.tree.BaseNode.prototype.onKeyDown = function(e) {
    var handled = true;
    switch (e.keyCode) {
        case goog.events.KeyCodes.RIGHT:
            if (e.altKey) break;
            if (this.hasChildren())
                if (!this.getExpanded()) this.setExpanded(true);
                else this.getFirstChild().select();
            break;
        case goog.events.KeyCodes.LEFT:
            if (e.altKey) break;
            if (this.hasChildren() && this.getExpanded() && this.isUserCollapsible_) this.setExpanded(false);
            else {
                var parent = this.getParent();
                var tree = this.getTree();
                if (parent && (tree.getShowRootNode() || parent != tree)) parent.select()
            }
            break;
        case goog.events.KeyCodes.DOWN:
            var nextNode = this.getNextShownNode();
            if (nextNode) nextNode.select();
            break;
        case goog.events.KeyCodes.UP:
            var previousNode = this.getPreviousShownNode();
            if (previousNode) previousNode.select();
            break;
        default:
            handled = false
    }
    if (handled) {
        e.preventDefault();
        var tree = this.getTree();
        if (tree) tree.clearTypeAhead()
    }
    return handled
};
goog.ui.tree.BaseNode.prototype.getLastShownDescendant = function() {
    if (!this.getExpanded() || !this.hasChildren()) return this;
    return this.getLastChild().getLastShownDescendant()
};
goog.ui.tree.BaseNode.prototype.getNextShownNode = function() {
    if (this.hasChildren() && this.getExpanded()) return this.getFirstChild();
    else {
        var parent = this;
        var next;
        while (parent != this.getTree()) {
            next = parent.getNextSibling();
            if (next != null) return next;
            parent = parent.getParent()
        }
        return null
    }
};
goog.ui.tree.BaseNode.prototype.getPreviousShownNode = function() {
    var ps = this.getPreviousSibling();
    if (ps != null) return ps.getLastShownDescendant();
    var parent = this.getParent();
    var tree = this.getTree();
    if (!tree.getShowRootNode() && parent == tree) return null;
    if (this == tree) return null;
    return parent
};
goog.ui.tree.BaseNode.prototype.getClientData = goog.ui.tree.BaseNode.prototype.getModel;
goog.ui.tree.BaseNode.prototype.setClientData = goog.ui.tree.BaseNode.prototype.setModel;
goog.ui.tree.BaseNode.prototype.getConfig = function() {
    return this.config_
};
goog.ui.tree.BaseNode.prototype.setTreeInternal = function(tree) {
    if (this.tree != tree) {
        this.tree = tree;
        tree.setNode(this);
        this.forEachChild(function(child) {
            child.setTreeInternal(tree)
        })
    }
};
goog.ui.tree.BaseNode.defaultConfig = {
    indentWidth: 19,
    cssRoot: goog.getCssName("goog-tree-root") + " " + goog.getCssName("goog-tree-item"),
    cssHideRoot: goog.getCssName("goog-tree-hide-root"),
    cssItem: goog.getCssName("goog-tree-item"),
    cssChildren: goog.getCssName("goog-tree-children"),
    cssChildrenNoLines: goog.getCssName("goog-tree-children-nolines"),
    cssTreeRow: goog.getCssName("goog-tree-row"),
    cssItemLabel: goog.getCssName("goog-tree-item-label"),
    cssTreeIcon: goog.getCssName("goog-tree-icon"),
    cssExpandTreeIcon: goog.getCssName("goog-tree-expand-icon"),
    cssExpandTreeIconPlus: goog.getCssName("goog-tree-expand-icon-plus"),
    cssExpandTreeIconMinus: goog.getCssName("goog-tree-expand-icon-minus"),
    cssExpandTreeIconTPlus: goog.getCssName("goog-tree-expand-icon-tplus"),
    cssExpandTreeIconTMinus: goog.getCssName("goog-tree-expand-icon-tminus"),
    cssExpandTreeIconLPlus: goog.getCssName("goog-tree-expand-icon-lplus"),
    cssExpandTreeIconLMinus: goog.getCssName("goog-tree-expand-icon-lminus"),
    cssExpandTreeIconT: goog.getCssName("goog-tree-expand-icon-t"),
    cssExpandTreeIconL: goog.getCssName("goog-tree-expand-icon-l"),
    cssExpandTreeIconBlank: goog.getCssName("goog-tree-expand-icon-blank"),
    cssExpandedFolderIcon: goog.getCssName("goog-tree-expanded-folder-icon"),
    cssCollapsedFolderIcon: goog.getCssName("goog-tree-collapsed-folder-icon"),
    cssFileIcon: goog.getCssName("goog-tree-file-icon"),
    cssExpandedRootIcon: goog.getCssName("goog-tree-expanded-folder-icon"),
    cssCollapsedRootIcon: goog.getCssName("goog-tree-collapsed-folder-icon"),
    cssSelectedRow: goog.getCssName("selected")
};
goog.provide("goog.ui.tree.TreeNode");
goog.require("goog.ui.tree.BaseNode");
goog.forwardDeclare("goog.ui.tree.TreeControl");
goog.ui.tree.TreeNode = function(content, opt_config, opt_domHelper) {
    goog.ui.tree.BaseNode.call(this, content, opt_config, opt_domHelper)
};
goog.inherits(goog.ui.tree.TreeNode, goog.ui.tree.BaseNode);
goog.ui.tree.TreeNode.prototype.getTree = function() {
    if (this.tree) return this.tree;
    var parent = this.getParent();
    if (parent) {
        var tree = parent.getTree();
        if (tree) {
            this.setTreeInternal(tree);
            return tree
        }
    }
    return null
};
goog.ui.tree.TreeNode.prototype.getCalculatedIconClass = function() {
    var expanded = this.getExpanded();
    var expandedIconClass = this.getExpandedIconClass();
    if (expanded && expandedIconClass) return expandedIconClass;
    var iconClass = this.getIconClass();
    if (!expanded && iconClass) return iconClass;
    var config = this.getConfig();
    if (this.hasChildren())
        if (expanded && config.cssExpandedFolderIcon) return config.cssTreeIcon + " " + config.cssExpandedFolderIcon;
        else {
            if (!expanded && config.cssCollapsedFolderIcon) return config.cssTreeIcon +
                " " + config.cssCollapsedFolderIcon
        }
    else if (config.cssFileIcon) return config.cssTreeIcon + " " + config.cssFileIcon;
    return ""
};
goog.provide("goog.structs");
goog.require("goog.array");
goog.require("goog.object");
goog.structs.getCount = function(col) {
    if (col.getCount && typeof col.getCount == "function") return col.getCount();
    if (goog.isArrayLike(col) || goog.isString(col)) return col.length;
    return goog.object.getCount(col)
};
goog.structs.getValues = function(col) {
    if (col.getValues && typeof col.getValues == "function") return col.getValues();
    if (goog.isString(col)) return col.split("");
    if (goog.isArrayLike(col)) {
        var rv = [];
        var l = col.length;
        for (var i = 0; i < l; i++) rv.push(col[i]);
        return rv
    }
    return goog.object.getValues(col)
};
goog.structs.getKeys = function(col) {
    if (col.getKeys && typeof col.getKeys == "function") return col.getKeys();
    if (col.getValues && typeof col.getValues == "function") return undefined;
    if (goog.isArrayLike(col) || goog.isString(col)) {
        var rv = [];
        var l = col.length;
        for (var i = 0; i < l; i++) rv.push(i);
        return rv
    }
    return goog.object.getKeys(col)
};
goog.structs.contains = function(col, val) {
    if (col.contains && typeof col.contains == "function") return col.contains(val);
    if (col.containsValue && typeof col.containsValue == "function") return col.containsValue(val);
    if (goog.isArrayLike(col) || goog.isString(col)) return goog.array.contains(col, val);
    return goog.object.containsValue(col, val)
};
goog.structs.isEmpty = function(col) {
    if (col.isEmpty && typeof col.isEmpty == "function") return col.isEmpty();
    if (goog.isArrayLike(col) || goog.isString(col)) return goog.array.isEmpty(col);
    return goog.object.isEmpty(col)
};
goog.structs.clear = function(col) {
    if (col.clear && typeof col.clear == "function") col.clear();
    else if (goog.isArrayLike(col)) goog.array.clear(col);
    else goog.object.clear(col)
};
goog.structs.forEach = function(col, f, opt_obj) {
    if (col.forEach && typeof col.forEach == "function") col.forEach(f, opt_obj);
    else if (goog.isArrayLike(col) || goog.isString(col)) goog.array.forEach(col, f, opt_obj);
    else {
        var keys = goog.structs.getKeys(col);
        var values = goog.structs.getValues(col);
        var l = values.length;
        for (var i = 0; i < l; i++) f.call(opt_obj, values[i], keys && keys[i], col)
    }
};
goog.structs.filter = function(col, f, opt_obj) {
    if (typeof col.filter == "function") return col.filter(f, opt_obj);
    if (goog.isArrayLike(col) || goog.isString(col)) return goog.array.filter(col, f, opt_obj);
    var rv;
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    if (keys) {
        rv = {};
        for (var i = 0; i < l; i++)
            if (f.call(opt_obj, values[i], keys[i], col)) rv[keys[i]] = values[i]
    } else {
        rv = [];
        for (var i = 0; i < l; i++)
            if (f.call(opt_obj, values[i], undefined, col)) rv.push(values[i])
    }
    return rv
};
goog.structs.map = function(col, f, opt_obj) {
    if (typeof col.map == "function") return col.map(f, opt_obj);
    if (goog.isArrayLike(col) || goog.isString(col)) return goog.array.map(col, f, opt_obj);
    var rv;
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    if (keys) {
        rv = {};
        for (var i = 0; i < l; i++) rv[keys[i]] = f.call(opt_obj, values[i], keys[i], col)
    } else {
        rv = [];
        for (var i = 0; i < l; i++) rv[i] = f.call(opt_obj, values[i], undefined, col)
    }
    return rv
};
goog.structs.some = function(col, f, opt_obj) {
    if (typeof col.some == "function") return col.some(f, opt_obj);
    if (goog.isArrayLike(col) || goog.isString(col)) return goog.array.some(col, f, opt_obj);
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++)
        if (f.call(opt_obj, values[i], keys && keys[i], col)) return true;
    return false
};
goog.structs.every = function(col, f, opt_obj) {
    if (typeof col.every == "function") return col.every(f, opt_obj);
    if (goog.isArrayLike(col) || goog.isString(col)) return goog.array.every(col, f, opt_obj);
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++)
        if (!f.call(opt_obj, values[i], keys && keys[i], col)) return false;
    return true
};
goog.provide("goog.structs.Trie");
goog.require("goog.object");
goog.require("goog.structs");
goog.structs.Trie = function(opt_trie) {
    this.value_ = undefined;
    this.childNodes_ = {};
    if (opt_trie) this.setAll(opt_trie)
};
goog.structs.Trie.prototype.set = function(key, value) {
    this.setOrAdd_(key, value, false)
};
goog.structs.Trie.prototype.add = function(key, value) {
    this.setOrAdd_(key, value, true)
};
goog.structs.Trie.prototype.setOrAdd_ = function(key, value, opt_add) {
    var node = this;
    for (var characterPosition = 0; characterPosition < key.length; characterPosition++) {
        var currentCharacter = key.charAt(characterPosition);
        if (!node.childNodes_[currentCharacter]) node.childNodes_[currentCharacter] = new goog.structs.Trie;
        node = node.childNodes_[currentCharacter]
    }
    if (opt_add && node.value_ !== undefined) throw new Error('The collection already contains the key "' + key + '"');
    else node.value_ = value
};
goog.structs.Trie.prototype.setAll = function(trie) {
    var keys = goog.structs.getKeys(trie);
    var values = goog.structs.getValues(trie);
    for (var i = 0; i < keys.length; i++) this.set(keys[i], values[i])
};
goog.structs.Trie.prototype.getChildNode_ = function(path) {
    var node = this;
    for (var characterPosition = 0; characterPosition < path.length; characterPosition++) {
        var currentCharacter = path.charAt(characterPosition);
        node = node.childNodes_[currentCharacter];
        if (!node) return undefined
    }
    return node
};
goog.structs.Trie.prototype.get = function(key) {
    var node = this.getChildNode_(key);
    return node ? node.value_ : undefined
};
goog.structs.Trie.prototype.getKeyAndPrefixes = function(key, opt_keyStartIndex) {
    var node = this;
    var matches = {};
    var characterPosition = opt_keyStartIndex || 0;
    if (node.value_ !== undefined) matches[characterPosition] = node.value_;
    for (; characterPosition < key.length; characterPosition++) {
        var currentCharacter = key.charAt(characterPosition);
        if (!(currentCharacter in node.childNodes_)) break;
        node = node.childNodes_[currentCharacter];
        if (node.value_ !== undefined) matches[characterPosition] = node.value_
    }
    return matches
};
goog.structs.Trie.prototype.getValues = function() {
    var allValues = [];
    this.getValuesInternal_(allValues);
    return allValues
};
goog.structs.Trie.prototype.getValuesInternal_ = function(allValues) {
    if (this.value_ !== undefined) allValues.push(this.value_);
    for (var childNode in this.childNodes_) this.childNodes_[childNode].getValuesInternal_(allValues)
};
goog.structs.Trie.prototype.getKeys = function(opt_prefix) {
    var allKeys = [];
    if (opt_prefix) {
        var node = this;
        for (var characterPosition = 0; characterPosition < opt_prefix.length; characterPosition++) {
            var currentCharacter = opt_prefix.charAt(characterPosition);
            if (!node.childNodes_[currentCharacter]) return [];
            node = node.childNodes_[currentCharacter]
        }
        node.getKeysInternal_(opt_prefix, allKeys)
    } else this.getKeysInternal_("", allKeys);
    return allKeys
};
goog.structs.Trie.prototype.getKeysInternal_ = function(keySoFar, allKeys) {
    if (this.value_ !== undefined) allKeys.push(keySoFar);
    for (var childNode in this.childNodes_) this.childNodes_[childNode].getKeysInternal_(keySoFar + childNode, allKeys)
};
goog.structs.Trie.prototype.containsKey = function(key) {
    return this.get(key) !== undefined
};
goog.structs.Trie.prototype.containsPrefix = function(prefix) {
    if (prefix.length == 0) return !this.isEmpty();
    return !!this.getChildNode_(prefix)
};
goog.structs.Trie.prototype.containsValue = function(value) {
    if (this.value_ === value) return true;
    for (var childNode in this.childNodes_)
        if (this.childNodes_[childNode].containsValue(value)) return true;
    return false
};
goog.structs.Trie.prototype.clear = function() {
    this.childNodes_ = {};
    this.value_ = undefined
};
goog.structs.Trie.prototype.remove = function(key) {
    var node = this;
    var parents = [];
    for (var characterPosition = 0; characterPosition < key.length; characterPosition++) {
        var currentCharacter = key.charAt(characterPosition);
        if (!node.childNodes_[currentCharacter]) throw new Error('The collection does not have the key "' + key + '"');
        parents.push([node, currentCharacter]);
        node = node.childNodes_[currentCharacter]
    }
    var oldValue = node.value_;
    delete node.value_;
    while (parents.length > 0) {
        var currentParentAndCharacter = parents.pop();
        var currentParent = currentParentAndCharacter[0];
        var currentCharacter = currentParentAndCharacter[1];
        if (currentParent.childNodes_[currentCharacter].isEmpty()) delete currentParent.childNodes_[currentCharacter];
        else break
    }
    return oldValue
};
goog.structs.Trie.prototype.clone = function() {
    return new goog.structs.Trie(this)
};
goog.structs.Trie.prototype.getCount = function() {
    return goog.structs.getCount(this.getValues())
};
goog.structs.Trie.prototype.isEmpty = function() {
    return this.value_ === undefined && goog.object.isEmpty(this.childNodes_)
};
goog.provide("goog.ui.tree.TypeAhead");
goog.provide("goog.ui.tree.TypeAhead.Offset");
goog.require("goog.array");
goog.require("goog.events.KeyCodes");
goog.require("goog.string");
goog.require("goog.structs.Trie");
goog.forwardDeclare("goog.ui.tree.BaseNode");
goog.ui.tree.TypeAhead = function() {
    this.nodeMap_ = new goog.structs.Trie;
    this.buffer_ = "";
    this.matchingLabels_ = null;
    this.matchingNodes_ = null;
    this.matchingLabelIndex_ = 0;
    this.matchingNodeIndex_ = 0
};
goog.ui.tree.TypeAhead.Offset = {
    DOWN: 1,
    UP: -1
};
goog.ui.tree.TypeAhead.prototype.handleNavigation = function(e) {
    var handled = false;
    switch (e.keyCode) {
        case goog.events.KeyCodes.DOWN:
        case goog.events.KeyCodes.UP:
            if (e.ctrlKey) {
                this.jumpTo_(e.keyCode == goog.events.KeyCodes.DOWN ? goog.ui.tree.TypeAhead.Offset.DOWN : goog.ui.tree.TypeAhead.Offset.UP);
                handled = true
            }
            break;
        case goog.events.KeyCodes.BACKSPACE:
            var length = this.buffer_.length - 1;
            handled = true;
            if (length > 0) {
                this.buffer_ = this.buffer_.substring(0, length);
                this.jumpToLabel_(this.buffer_)
            } else if (length == 0) this.buffer_ =
                "";
            else handled = false;
            break;
        case goog.events.KeyCodes.ESC:
            this.buffer_ = "";
            handled = true;
            break
    }
    return handled
};
goog.ui.tree.TypeAhead.prototype.handleTypeAheadChar = function(e) {
    var handled = false;
    if (!e.ctrlKey && !e.altKey) {
        var ch = String.fromCharCode(e.charCode || e.keyCode).toLowerCase();
        if (goog.string.isUnicodeChar(ch) && (ch != " " || this.buffer_)) {
            this.buffer_ += ch;
            handled = this.jumpToLabel_(this.buffer_)
        }
    }
    return handled
};
goog.ui.tree.TypeAhead.prototype.setNodeInMap = function(node) {
    var labelText = node.getText();
    if (labelText && !goog.string.isEmptyOrWhitespace(goog.string.makeSafe(labelText))) {
        labelText = labelText.toLowerCase();
        var previousValue = this.nodeMap_.get(labelText);
        if (previousValue) previousValue.push(node);
        else {
            var nodeList = [node];
            this.nodeMap_.set(labelText, nodeList)
        }
    }
};
goog.ui.tree.TypeAhead.prototype.removeNodeFromMap = function(node) {
    var labelText = node.getText();
    if (labelText && !goog.string.isEmptyOrWhitespace(goog.string.makeSafe(labelText))) {
        labelText = labelText.toLowerCase();
        var nodeList = this.nodeMap_.get(labelText);
        if (nodeList) {
            var count = node.getChildCount();
            for (var i = 0; i < count; i++) this.removeNodeFromMap(node.getChildAt(i));
            goog.array.remove(nodeList, node);
            if (!nodeList.length) this.nodeMap_.remove(labelText)
        }
    }
};
goog.ui.tree.TypeAhead.prototype.jumpToLabel_ = function(typeAhead) {
    var handled = false;
    var labels = this.nodeMap_.getKeys(typeAhead);
    if (labels && labels.length) {
        this.matchingNodeIndex_ = 0;
        this.matchingLabelIndex_ = 0;
        var nodes = this.nodeMap_.get(labels[0]);
        if (handled = this.selectMatchingNode_(nodes)) this.matchingLabels_ = labels
    }
    return handled
};
goog.ui.tree.TypeAhead.prototype.jumpTo_ = function(offset) {
    var handled = false;
    var labels = this.matchingLabels_;
    if (labels) {
        var nodes = null;
        var nodeIndexOutOfRange = false;
        if (this.matchingNodes_) {
            var newNodeIndex = this.matchingNodeIndex_ + offset;
            if (newNodeIndex >= 0 && newNodeIndex < this.matchingNodes_.length) {
                this.matchingNodeIndex_ = newNodeIndex;
                nodes = this.matchingNodes_
            } else nodeIndexOutOfRange = true
        }
        if (!nodes) {
            var newLabelIndex = this.matchingLabelIndex_ + offset;
            if (newLabelIndex >= 0 && newLabelIndex < labels.length) this.matchingLabelIndex_ =
                newLabelIndex;
            if (labels.length > this.matchingLabelIndex_) nodes = this.nodeMap_.get(labels[this.matchingLabelIndex_]);
            if (nodes && nodes.length && nodeIndexOutOfRange) this.matchingNodeIndex_ = offset == goog.ui.tree.TypeAhead.Offset.UP ? nodes.length - 1 : 0
        }
        if (handled = this.selectMatchingNode_(nodes)) this.matchingLabels_ = labels
    }
    return handled
};
goog.ui.tree.TypeAhead.prototype.selectMatchingNode_ = function(nodes) {
    var node;
    if (nodes) {
        if (this.matchingNodeIndex_ < nodes.length) {
            node = nodes[this.matchingNodeIndex_];
            this.matchingNodes_ = nodes
        }
        if (node) {
            node.reveal();
            node.select()
        }
    }
    return !!node
};
goog.ui.tree.TypeAhead.prototype.clear = function() {
    this.buffer_ = ""
};
goog.provide("goog.ui.tree.TreeControl");
goog.require("goog.a11y.aria");
goog.require("goog.asserts");
goog.require("goog.dom.classlist");
goog.require("goog.events.EventType");
goog.require("goog.events.FocusHandler");
goog.require("goog.events.KeyHandler");
goog.require("goog.html.SafeHtml");
goog.require("goog.log");
goog.require("goog.ui.tree.BaseNode");
goog.require("goog.ui.tree.TreeNode");
goog.require("goog.ui.tree.TypeAhead");
goog.require("goog.userAgent");
goog.ui.tree.TreeControl = function(content, opt_config, opt_domHelper) {
    goog.ui.tree.BaseNode.call(this, content, opt_config, opt_domHelper);
    this.setExpandedInternal(true);
    this.setSelectedInternal(true);
    this.selectedItem_ = this;
    this.typeAhead_ = new goog.ui.tree.TypeAhead;
    this.keyHandler_ = null;
    this.focusHandler_ = null;
    this.logger_ = goog.log.getLogger("this");
    this.focused_ = false;
    this.focusedNode_ = null;
    this.showLines_ = true;
    this.showExpandIcons_ = true;
    this.showRootNode_ = true;
    this.showRootLines_ = true;
    if (goog.userAgent.IE) try {
        document.execCommand("BackgroundImageCache",
            false, true)
    } catch (e) {
        goog.log.warning(this.logger_, "Failed to enable background image cache")
    }
};
goog.inherits(goog.ui.tree.TreeControl, goog.ui.tree.BaseNode);
goog.ui.tree.TreeControl.prototype.getTree = function() {
    return this
};
goog.ui.tree.TreeControl.prototype.getDepth = function() {
    return 0
};
goog.ui.tree.TreeControl.prototype.reveal = function() {};
goog.ui.tree.TreeControl.prototype.handleFocus_ = function(e) {
    this.focused_ = true;
    goog.dom.classlist.add(goog.asserts.assert(this.getElement()), goog.getCssName("focused"));
    if (this.selectedItem_) this.selectedItem_.select()
};
goog.ui.tree.TreeControl.prototype.handleBlur_ = function(e) {
    this.focused_ = false;
    goog.dom.classlist.remove(goog.asserts.assert(this.getElement()), goog.getCssName("focused"))
};
goog.ui.tree.TreeControl.prototype.hasFocus = function() {
    return this.focused_
};
goog.ui.tree.TreeControl.prototype.getExpanded = function() {
    return !this.showRootNode_ || goog.ui.tree.TreeControl.superClass_.getExpanded.call(this)
};
goog.ui.tree.TreeControl.prototype.setExpanded = function(expanded) {
    if (!this.showRootNode_) this.setExpandedInternal(expanded);
    else goog.ui.tree.TreeControl.superClass_.setExpanded.call(this, expanded)
};
goog.ui.tree.TreeControl.prototype.getExpandIconSafeHtml = function() {
    return goog.html.SafeHtml.EMPTY
};
goog.ui.tree.TreeControl.prototype.getIconElement = function() {
    var el = this.getRowElement();
    return el ? el.firstChild : null
};
goog.ui.tree.TreeControl.prototype.getExpandIconElement = function() {
    return null
};
goog.ui.tree.TreeControl.prototype.updateExpandIcon = function() {};
goog.ui.tree.TreeControl.prototype.getRowClassName = function() {
    return goog.ui.tree.TreeControl.superClass_.getRowClassName.call(this) + (this.showRootNode_ ? "" : " " + this.getConfig().cssHideRoot)
};
goog.ui.tree.TreeControl.prototype.getCalculatedIconClass = function() {
    var expanded = this.getExpanded();
    var expandedIconClass = this.getExpandedIconClass();
    if (expanded && expandedIconClass) return expandedIconClass;
    var iconClass = this.getIconClass();
    if (!expanded && iconClass) return iconClass;
    var config = this.getConfig();
    if (expanded && config.cssExpandedRootIcon) return config.cssTreeIcon + " " + config.cssExpandedRootIcon;
    else if (!expanded && config.cssCollapsedRootIcon) return config.cssTreeIcon + " " + config.cssCollapsedRootIcon;
    return ""
};
goog.ui.tree.TreeControl.prototype.setSelectedItem = function(node) {
    if (this.selectedItem_ == node) return;
    var hadFocus = false;
    if (this.selectedItem_) {
        hadFocus = this.selectedItem_ == this.focusedNode_;
        this.selectedItem_.setSelectedInternal(false)
    }
    this.selectedItem_ = node;
    if (node) {
        node.setSelectedInternal(true);
        if (hadFocus) node.select()
    }
    this.dispatchEvent(goog.events.EventType.CHANGE)
};
goog.ui.tree.TreeControl.prototype.getSelectedItem = function() {
    return this.selectedItem_
};
goog.ui.tree.TreeControl.prototype.setShowLines = function(b) {
    if (this.showLines_ != b) {
        this.showLines_ = b;
        if (this.isInDocument()) this.updateLinesAndExpandIcons_()
    }
};
goog.ui.tree.TreeControl.prototype.getShowLines = function() {
    return this.showLines_
};
goog.ui.tree.TreeControl.prototype.updateLinesAndExpandIcons_ = function() {
    var tree = this;
    var showLines = tree.getShowLines();
    var showRootLines = tree.getShowRootLines();

    function updateShowLines(node) {
        var childrenEl = node.getChildrenElement();
        if (childrenEl) {
            var hideLines = !showLines || tree == node.getParent() && !showRootLines;
            var childClass = hideLines ? node.getConfig().cssChildrenNoLines : node.getConfig().cssChildren;
            childrenEl.className = childClass;
            var expandIconEl = node.getExpandIconElement();
            if (expandIconEl) expandIconEl.className =
                node.getExpandIconClass()
        }
        node.forEachChild(updateShowLines)
    }
    updateShowLines(this)
};
goog.ui.tree.TreeControl.prototype.setShowRootLines = function(b) {
    if (this.showRootLines_ != b) {
        this.showRootLines_ = b;
        if (this.isInDocument()) this.updateLinesAndExpandIcons_()
    }
};
goog.ui.tree.TreeControl.prototype.getShowRootLines = function() {
    return this.showRootLines_
};
goog.ui.tree.TreeControl.prototype.setShowExpandIcons = function(b) {
    if (this.showExpandIcons_ != b) {
        this.showExpandIcons_ = b;
        if (this.isInDocument()) this.updateLinesAndExpandIcons_()
    }
};
goog.ui.tree.TreeControl.prototype.getShowExpandIcons = function() {
    return this.showExpandIcons_
};
goog.ui.tree.TreeControl.prototype.setShowRootNode = function(b) {
    if (this.showRootNode_ != b) {
        this.showRootNode_ = b;
        if (this.isInDocument()) {
            var el = this.getRowElement();
            if (el) el.className = this.getRowClassName()
        }
        if (!b && this.getSelectedItem() == this && this.getFirstChild()) this.setSelectedItem(this.getFirstChild())
    }
};
goog.ui.tree.TreeControl.prototype.getShowRootNode = function() {
    return this.showRootNode_
};
goog.ui.tree.TreeControl.prototype.initAccessibility = function() {
    goog.ui.tree.TreeControl.superClass_.initAccessibility.call(this);
    var elt = this.getElement();
    goog.asserts.assert(elt, "The DOM element for the tree cannot be null.");
    goog.a11y.aria.setRole(elt, "tree");
    goog.a11y.aria.setState(elt, "labelledby", this.getLabelElement().id)
};
goog.ui.tree.TreeControl.prototype.enterDocument = function() {
    goog.ui.tree.TreeControl.superClass_.enterDocument.call(this);
    var el = this.getElement();
    el.className = this.getConfig().cssRoot;
    el.setAttribute("hideFocus", "true");
    this.attachEvents_();
    this.initAccessibility()
};
goog.ui.tree.TreeControl.prototype.exitDocument = function() {
    goog.ui.tree.TreeControl.superClass_.exitDocument.call(this);
    this.detachEvents_()
};
goog.ui.tree.TreeControl.prototype.attachEvents_ = function() {
    var el = this.getElement();
    el.tabIndex = 0;
    var kh = this.keyHandler_ = new goog.events.KeyHandler(el);
    var fh = this.focusHandler_ = new goog.events.FocusHandler(el);
    this.getHandler().listen(fh, goog.events.FocusHandler.EventType.FOCUSOUT, this.handleBlur_).listen(fh, goog.events.FocusHandler.EventType.FOCUSIN, this.handleFocus_).listen(kh, goog.events.KeyHandler.EventType.KEY, this.handleKeyEvent).listen(el, goog.events.EventType.MOUSEDOWN, this.handleMouseEvent_).listen(el,
        goog.events.EventType.CLICK, this.handleMouseEvent_).listen(el, goog.events.EventType.DBLCLICK, this.handleMouseEvent_)
};
goog.ui.tree.TreeControl.prototype.detachEvents_ = function() {
    this.keyHandler_.dispose();
    this.keyHandler_ = null;
    this.focusHandler_.dispose();
    this.focusHandler_ = null
};
goog.ui.tree.TreeControl.prototype.handleMouseEvent_ = function(e) {
    goog.log.fine(this.logger_, "Received event " + e.type);
    var node = this.getNodeFromEvent_(e);
    if (node) switch (e.type) {
        case goog.events.EventType.MOUSEDOWN:
            node.onMouseDown(e);
            break;
        case goog.events.EventType.CLICK:
            node.onClick_(e);
            break;
        case goog.events.EventType.DBLCLICK:
            node.onDoubleClick_(e);
            break
    }
};
goog.ui.tree.TreeControl.prototype.handleKeyEvent = function(e) {
    var handled = false;
    handled = this.typeAhead_.handleNavigation(e) || this.selectedItem_ && this.selectedItem_.onKeyDown(e) || this.typeAhead_.handleTypeAheadChar(e);
    if (handled) e.preventDefault();
    return handled
};
goog.ui.tree.TreeControl.prototype.getNodeFromEvent_ = function(e) {
    var node = null;
    var target = e.target;
    while (target != null) {
        var id = target.id;
        node = goog.ui.tree.BaseNode.allNodes[id];
        if (node) return node;
        if (target == this.getElement()) break;
        target = target.parentNode
    }
    return null
};
goog.ui.tree.TreeControl.prototype.createNode = function(opt_content) {
    return new goog.ui.tree.TreeNode(opt_content || goog.html.SafeHtml.EMPTY, this.getConfig(), this.getDomHelper())
};
goog.ui.tree.TreeControl.prototype.setNode = function(node) {
    this.typeAhead_.setNodeInMap(node)
};
goog.ui.tree.TreeControl.prototype.removeNode = function(node) {
    this.typeAhead_.removeNodeFromMap(node)
};
goog.ui.tree.TreeControl.prototype.clearTypeAhead = function() {
    this.typeAhead_.clear()
};
goog.ui.tree.TreeControl.defaultConfig = goog.ui.tree.BaseNode.defaultConfig;
goog.provide("blocklyApp.AppComponent");
goog.require("Blockly");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.BlockConnectionService");
goog.require("blocklyApp.BlockOptionsModalComponent");
goog.require("blocklyApp.BlockOptionsModalService");
goog.require("blocklyApp.KeyboardInputService");
goog.require("blocklyApp.NotificationsService");
goog.require("blocklyApp.SidebarComponent");
goog.require("blocklyApp.ToolboxModalComponent");
goog.require("blocklyApp.ToolboxModalService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.TreeService");
goog.require("blocklyApp.UtilsService");
goog.require("blocklyApp.VariableAddModalComponent");
goog.require("blocklyApp.VariableModalService");
goog.require("blocklyApp.VariableRenameModalComponent");
goog.require("blocklyApp.VariableRemoveModalComponent");
goog.require("blocklyApp.WorkspaceComponent");
blocklyApp.workspace = new Blockly.Workspace;
blocklyApp.AppComponent = ng.core.Component({
    selector: "blockly-app",
    template: '\n    <blockly-workspace></blockly-workspace>\n    <blockly-sidebar></blockly-sidebar>\n    \x3c!-- Warning: Hiding this when there is no content looks visually nicer,\n    but it can have unexpected side effects. In particular, it sometimes stops\n    screenreaders from reading anything in this div. --\x3e\n    <div class="blocklyAriaLiveStatus">\n      <span aria-live="polite" role="status">{{getAriaLiveReadout()}}</span>\n    </div>\n\n    <blockly-add-variable-modal></blockly-add-variable-modal>\n    <blockly-rename-variable-modal></blockly-rename-variable-modal>\n    <blockly-remove-variable-modal></blockly-remove-variable-modal>\n    <blockly-toolbox-modal></blockly-toolbox-modal>\n    <blockly-block-options-modal></blockly-block-options-modal>\n\n    <label id="blockly-translate-button" aria-hidden="true" hidden>\n      {{\'BUTTON\'|translate}}\n    </label>\n    <label id="blockly-translate-workspace-block" aria-hidden="true" hidden>\n      {{\'WORKSPACE_BLOCK\'|translate}}\n    </label>\n  ',
    directives: [blocklyApp.BlockOptionsModalComponent,
        blocklyApp.SidebarComponent, blocklyApp.ToolboxModalComponent, blocklyApp.VariableAddModalComponent, blocklyApp.VariableRenameModalComponent, blocklyApp.VariableRemoveModalComponent, blocklyApp.WorkspaceComponent
    ],
    pipes: [blocklyApp.TranslatePipe],
    providers: [blocklyApp.AudioService, blocklyApp.BlockConnectionService, blocklyApp.BlockOptionsModalService, blocklyApp.KeyboardInputService, blocklyApp.NotificationsService, blocklyApp.ToolboxModalService, blocklyApp.TreeService, blocklyApp.UtilsService, blocklyApp.VariableModalService]
}).Class({
    constructor: [blocklyApp.NotificationsService,
        function(notificationsService) {
            this.notificationsService = notificationsService
        }
    ],
    getAriaLiveReadout: function() {
        return this.notificationsService.getDisplayedMessage()
    }
});
goog.provide("blocklyApp.AudioService");
goog.require("blocklyApp.NotificationsService");
blocklyApp.AudioService = ng.core.Class({
    constructor: [blocklyApp.NotificationsService, function(notificationsService) {
        this.notificationsService = notificationsService;
        this.canPlayAudio = false;
        if (ACCESSIBLE_GLOBALS.hasOwnProperty("mediaPathPrefix")) {
            this.canPlayAudio = true;
            var mediaPathPrefix = ACCESSIBLE_GLOBALS["mediaPathPrefix"];
            this.AUDIO_PATHS_ = {
                "connect": mediaPathPrefix + "click.mp3",
                "delete": mediaPathPrefix + "delete.mp3",
                "oops": mediaPathPrefix + "oops.mp3"
            }
        }
        this.cachedAudioFiles_ = {};
        this.onEndedCallbacks_ = {
            "connect": [],
            "delete": [],
            "oops": []
        }
    }],
    play_: function(audioId, onEndedCallback) {
        if (this.canPlayAudio) {
            if (!this.cachedAudioFiles_.hasOwnProperty(audioId)) this.cachedAudioFiles_[audioId] = new Audio(this.AUDIO_PATHS_[audioId]);
            if (onEndedCallback) {
                this.onEndedCallbacks_[audioId].push(onEndedCallback);
                this.cachedAudioFiles_[audioId].addEventListener("ended", onEndedCallback)
            } else {
                var that = this;
                this.onEndedCallbacks_[audioId].forEach(function(callback) {
                    that.cachedAudioFiles_[audioId].removeEventListener("ended",
                        callback)
                });
                this.onEndedCallbacks_[audioId].length = 0
            }
            this.cachedAudioFiles_[audioId].play()
        }
    },
    playConnectSound: function() {
        this.play_("connect")
    },
    playDeleteSound: function() {
        this.play_("delete")
    },
    playOopsSound: function(optionalStatusMessage) {
        if (optionalStatusMessage) {
            var that = this;
            this.play_("oops", function() {
                that.notificationsService.speak(optionalStatusMessage)
            })
        } else this.play_("oops")
    }
});
goog.provide("blocklyApp.BlockConnectionService");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.NotificationsService");
blocklyApp.BlockConnectionService = ng.core.Class({
    constructor: [blocklyApp.NotificationsService, blocklyApp.AudioService, function(_notificationsService, _audioService) {
        this.notificationsService = _notificationsService;
        this.audioService = _audioService;
        this.markedConnection_ = null
    }],
    findCompatibleConnection_: function(block, targetConnection) {
        if (!targetConnection || !targetConnection.getSourceBlock().workspace) return null;
        var desiredType = Blockly.OPPOSITE_TYPE[targetConnection.type];
        var potentialConnection = desiredType ==
            Blockly.OUTPUT_VALUE ? block.outputConnection : desiredType == Blockly.PREVIOUS_STATEMENT ? block.previousConnection : desiredType == Blockly.NEXT_STATEMENT ? block.nextConnection : null;
        if (potentialConnection && potentialConnection.checkType_(targetConnection)) return potentialConnection;
        else return null
    },
    isAnyConnectionMarked: function() {
        return Boolean(this.markedConnection_)
    },
    getMarkedConnectionSourceBlock: function() {
        return this.markedConnection_ ? this.markedConnection_.getSourceBlock() : null
    },
    canBeAttachedToMarkedConnection: function(block) {
        return Boolean(this.findCompatibleConnection_(block,
            this.markedConnection_))
    },
    canBeMovedToMarkedConnection: function(block) {
        if (!this.markedConnection_) return false;
        var ancestorBlock = this.getMarkedConnectionSourceBlock();
        while (ancestorBlock) {
            if (ancestorBlock.id == block.id) return false;
            ancestorBlock = ancestorBlock.getParent()
        }
        return this.canBeAttachedToMarkedConnection(block)
    },
    markConnection: function(connection) {
        this.markedConnection_ = connection;
        this.notificationsService.speak(Blockly.Msg.ADDED_LINK_MSG)
    },
    attachToMarkedConnection: function(block) {
        var xml =
            Blockly.Xml.blockToDom(block);
        var reconstitutedBlock = Blockly.Xml.domToBlock(xml, blocklyApp.workspace);
        var targetConnection = null;
        if (this.markedConnection_.targetBlock() && this.markedConnection_.type == Blockly.PREVIOUS_STATEMENT) targetConnection = this.markedConnection_.targetConnection;
        else targetConnection = this.markedConnection_;
        var connection = this.findCompatibleConnection_(reconstitutedBlock, targetConnection);
        if (connection) {
            targetConnection.connect(connection);
            this.markedConnection_ = null;
            this.audioService.playConnectSound();
            return reconstitutedBlock.id
        } else throw Error("Unable to connect block to marked connection. This should not " + "happen.");
    }
});
goog.provide("blocklyApp.BlockOptionsModalComponent");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.BlockOptionsModalService");
goog.require("blocklyApp.KeyboardInputService");
goog.require("blocklyApp.TranslatePipe");
goog.require("Blockly.CommonModal");
blocklyApp.BlockOptionsModalComponent = ng.core.Component({
    selector: "blockly-block-options-modal",
    template: '\n    <div *ngIf="modalIsVisible" class="blocklyModalCurtain"\n         (click)="dismissModal()">\n      \x3c!-- $event.stopPropagation() prevents the modal from closing when its\n      interior is clicked. --\x3e\n      <div id="blockOptionsModal" class="blocklyModal" role="alertdialog"\n           (click)="$event.stopPropagation()" tabindex="-1"\n           aria-labelledby="blockOptionsModalHeading">\n        <h3 id="blockOptionsModalHeading">{{\'BLOCK_OPTIONS\'|translate}}</h3>\n        <div role="document">\n          <div class="blocklyModalButtonContainer"\n               *ngFor="#buttonInfo of actionButtonsInfo; #buttonIndex=index">\n            <button [id]="getOptionId(buttonIndex)"\n                    (click)="buttonInfo.action(); hideModal();"\n                    [ngClass]="{activeButton: activeButtonIndex == buttonIndex}">\n              {{buttonInfo.translationIdForText|translate}}\n            </button>\n          </div>\n        </div>\n\n        <div class="blocklyModalButtonContainer">\n          <button [id]="getCancelOptionId()"\n                  (click)="dismissModal()"\n                  [ngClass]="{activeButton: activeButtonIndex == actionButtonsInfo.length}">\n            {{\'CANCEL\'|translate}}\n          </button>\n        </div>\n      </div>\n    </div>\n  ',
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.BlockOptionsModalService,
        blocklyApp.KeyboardInputService, blocklyApp.AudioService,
        function(blockOptionsModalService_, keyboardInputService_, audioService_) {
            this.blockOptionsModalService = blockOptionsModalService_;
            this.keyboardInputService = keyboardInputService_;
            this.audioService = audioService_;
            this.modalIsVisible = false;
            this.actionButtonsInfo = [];
            this.activeButtonIndex = -1;
            this.onDismissCallback = null;
            var that = this;
            this.blockOptionsModalService.registerPreShowHook(function(newActionButtonsInfo, onDismissCallback) {
                that.modalIsVisible =
                    true;
                that.actionButtonsInfo = newActionButtonsInfo;
                that.activeActionButtonIndex = -1;
                that.onDismissCallback = onDismissCallback;
                Blockly.CommonModal.setupKeyboardOverrides(that);
                that.keyboardInputService.addOverride("13", function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (that.activeButtonIndex == -1) return;
                    var button = document.getElementById(that.getOptionId(that.activeButtonIndex));
                    if (that.activeButtonIndex < that.actionButtonsInfo.length) that.actionButtonsInfo[that.activeButtonIndex].action();
                    else that.dismissModal();
                    that.hideModal()
                });
                setTimeout(function() {
                    document.getElementById("blockOptionsModal").focus()
                }, 150)
            })
        }
    ],
    focusOnOption: function(index) {
        var button = document.getElementById(this.getOptionId(index));
        button.focus()
    },
    numInteractiveElements: function() {
        return this.actionButtonsInfo.length + 1
    },
    getOptionId: function(index) {
        return "block-options-modal-option-" + index
    },
    getCancelOptionId: function() {
        return this.getOptionId(this.actionButtonsInfo.length)
    },
    dismissModal: function() {
        this.onDismissCallback();
        this.hideModal()
    },
    hideModal: function() {
        this.modalIsVisible = false;
        this.keyboardInputService.clearOverride();
        this.blockOptionsModalService.hideModal()
    }
});
goog.provide("blocklyApp.BlockOptionsModalService");
blocklyApp.BlockOptionsModalService = ng.core.Class({
    constructor: [function() {
        this.actionButtonsInfo = [];
        this.preShowHook = function() {
            throw Error("A pre-show hook must be defined for the block options modal " + "before it can be shown.");
        };
        this.modalIsShown = false;
        this.onDismissCallback = null
    }],
    registerPreShowHook: function(preShowHook) {
        var that = this;
        this.preShowHook = function() {
            preShowHook(that.actionButtonsInfo, that.onDismissCallback)
        }
    },
    isModalShown: function() {
        return this.modalIsShown
    },
    showModal: function(actionButtonsInfo,
        onDismissCallback) {
        this.actionButtonsInfo = actionButtonsInfo;
        this.onDismissCallback = onDismissCallback;
        this.preShowHook();
        this.modalIsShown = true
    },
    hideModal: function() {
        this.modalIsShown = false
    }
});
goog.provide("Blockly.CommonModal");
Blockly.CommonModal = function() {};
Blockly.CommonModal.setupKeyboardOverrides = function(component) {
    component.keyboardInputService.setOverride({
        9: function(evt) {
            evt.preventDefault();
            evt.stopPropagation();
            if (evt.shiftKey)
                if (component.activeButtonIndex <= 0) {
                    component.activeActionButtonIndex = 0;
                    component.audioService.playOopsSound()
                } else component.activeButtonIndex--;
            else if (component.activeButtonIndex == component.numInteractiveElements(component) - 1) component.audioService.playOopsSound();
            else component.activeButtonIndex++;
            component.focusOnOption(component.activeButtonIndex,
                component)
        },
        27: function() {
            component.dismissModal()
        },
        38: function(evt) {
            evt.preventDefault()
        },
        40: function(evt) {
            evt.preventDefault()
        }
    })
};
Blockly.CommonModal.getInteractiveElements = function(component) {
    return Array.prototype.filter.call(component.getInteractiveContainer().elements, function(element) {
        if (element.type === "hidden") return false;
        if (element.disabled) return false;
        if (element.tabIndex < 0) return false;
        return true
    })
};
Blockly.CommonModal.numInteractiveElements = function(component) {
    var elements = this.getInteractiveElements(component);
    return elements.length
};
Blockly.CommonModal.focusOnOption = function(index, component) {
    var elements = this.getInteractiveElements(component);
    var button = elements[index];
    button.focus()
};
Blockly.CommonModal.hideModal = function() {
    this.modalIsVisible = false;
    this.keyboardInputService.clearOverride()
};
goog.provide("blocklyApp.FieldSegmentComponent");
goog.require("blocklyApp.NotificationsService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.VariableModalService");
blocklyApp.FieldSegmentComponent = ng.core.Component({
    selector: "blockly-field-segment",
    template: '\n    <template [ngIf]="!mainField">\n      <label [id]="mainFieldId">{{getPrefixText()}}</label>\n    </template>\n\n    <template [ngIf]="mainField">\n      <template [ngIf]="isTextInput()">\n        {{getPrefixText()}}\n        <input [id]="mainFieldId" type="text"\n               [ngModel]="mainField.getValue()" (ngModelChange)="setTextValue($event)"\n               [attr.aria-label]="getFieldDescription() + \'. \' + (\'PRESS_ENTER_TO_EDIT_TEXT\'|translate)"\n               tabindex="-1">\n      </template>\n\n      <template [ngIf]="isNumberInput()">\n        {{getPrefixText()}}\n        <input [id]="mainFieldId" type="number"\n               [ngModel]="mainField.getValue()" (ngModelChange)="setNumberValue($event)"\n               [attr.aria-label]="getFieldDescription() + \'. \' + (\'PRESS_ENTER_TO_EDIT_NUMBER\'|translate)"\n               tabindex="-1">\n      </template>\n\n      <template [ngIf]="isDropdown()">\n        {{getPrefixText()}}\n        <select [id]="mainFieldId" [name]="mainFieldId"\n                [ngModel]="selectedOption" (ngModelChange)="setDropdownValue($event)"\n                (keydown.enter)="selectOption()"\n                tabindex="-1">\n          <option *ngFor="#option of dropdownOptions" value="{{option.value}}">\n            {{option.text}}\n          </option>\n        </select>\n      </template>\n    </template>\n  ',
    inputs: ["prefixFields",
        "mainField", "mainFieldId", "level"
    ],
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.NotificationsService, blocklyApp.VariableModalService, function(notificationsService, variableModalService) {
        this.notificationsService = notificationsService;
        this.variableModalService = variableModalService;
        this.dropdownOptions = [];
        this.rawOptions = []
    }],
    ngAfterContentInit: function() {
        if (this.mainField) this.mainField.initModel()
    },
    ngDoCheck: function() {
        if (this.isDropdown() && this.shouldBreakCache()) {
            this.optionValue =
                this.mainField.getValue();
            this.fieldValue = this.mainField.getValue();
            this.rawOptions = this.mainField.getOptions();
            this.dropdownOptions = this.rawOptions.map(function(valueAndText) {
                return {
                    text: valueAndText[0],
                    value: valueAndText[1]
                }
            });
            for (var i = 0; i < this.dropdownOptions.length; i++)
                if (this.dropdownOptions[i].text === this.fieldValue) this.selectedOption = this.dropdownOptions[i].value
        }
    },
    shouldBreakCache: function() {
        var newOptions = this.mainField.getOptions();
        if (newOptions.length != this.rawOptions.length) return true;
        for (var i = 0; i < this.rawOptions.length; i++)
            if (newOptions[i][0] != this.rawOptions[i][0]) return true;
        if (this.fieldValue != this.mainField.getValue()) return true;
        return false
    },
    getPrefixText: function() {
        var prefixTexts = this.prefixFields.map(function(prefixField) {
            return prefixField.getText()
        });
        return prefixTexts.join(" ")
    },
    getFieldDescription: function() {
        var description = this.mainField.getText();
        if (this.prefixFields.length > 0) description = this.getPrefixText() + ": " + description;
        return description
    },
    isTextInput: function() {
        return this.mainField instanceof
        Blockly.FieldTextInput && !(this.mainField instanceof Blockly.FieldNumber)
    },
    isNumberInput: function() {
        return this.mainField instanceof Blockly.FieldNumber
    },
    isDropdown: function() {
        return this.mainField instanceof Blockly.FieldDropdown
    },
    setTextValue: function(newValue) {
        this.mainField.setValue(newValue)
    },
    setNumberValue: function(newValue) {
        this.mainField.setValue(newValue || 0)
    },
    selectOption: function() {
        if (this.optionValue != Blockly.RENAME_VARIABLE_ID && this.optionValue != Blockly.DELETE_VARIABLE_ID) this.mainField.setValue(this.optionValue);
        if (this.optionValue == Blockly.RENAME_VARIABLE_ID) this.variableModalService.showRenameModal_(this.mainField.getValue());
        if (this.optionValue == Blockly.DELETE_VARIABLE_ID) this.variableModalService.showRemoveModal_(this.mainField.getValue())
    },
    setDropdownValue: function(optionValue) {
        this.optionValue = optionValue;
        if (this.optionValue == "NO_ACTION") return;
        var optionText = undefined;
        for (var i = 0; i < this.dropdownOptions.length; i++)
            if (this.dropdownOptions[i].value == optionValue) {
                optionText = this.dropdownOptions[i].text;
                break
            } if (!optionText) throw Error("There is no option text corresponding to the value: " + this.optionValue);
        this.notificationsService.speak("Selected option " + optionText)
    }
});
goog.provide("blocklyApp.KeyboardInputService");
blocklyApp.KeyboardInputService = ng.core.Class({
    constructor: [function() {
        this.keysToActions = {};
        this.keysToActionsOverride = null;
        var that = this;
        document.addEventListener("keydown", function(evt) {
            var stringifiedKeycode = String(evt.keyCode);
            var actionsObject = that.keysToActionsOverride || that.keysToActions;
            if (actionsObject.hasOwnProperty(stringifiedKeycode)) actionsObject[stringifiedKeycode](evt)
        })
    }],
    setOverride: function(newKeysToActions) {
        this.keysToActionsOverride = newKeysToActions
    },
    addOverride: function(keyCode,
        action) {
        this.keysToActionsOverride[keyCode] = action
    },
    clearOverride: function() {
        this.keysToActionsOverride = null
    }
});
goog.provide("blocklyApp.NotificationsService");
blocklyApp.NotificationsService = ng.core.Class({
    constructor: [function() {
        this.currentMessage = "";
        this.timeouts = []
    }],
    setDisplayedMessage_: function(newMessage) {
        this.currentMessage = newMessage
    },
    getDisplayedMessage: function() {
        return this.currentMessage
    },
    speak: function(newMessage) {
        this.timeouts.forEach(function(timeout) {
            clearTimeout(timeout)
        });
        this.timeouts.length = 0;
        this.setDisplayedMessage_("");
        var that = this;
        this.timeouts.push(setTimeout(function() {
            that.setDisplayedMessage_(newMessage)
        }, 20));
        this.timeouts.push(setTimeout(function() {
                that.setDisplayedMessage_("")
            },
            5E3))
    }
});
goog.provide("blocklyApp.SidebarComponent");
goog.require("blocklyApp.UtilsService");
goog.require("blocklyApp.BlockConnectionService");
goog.require("blocklyApp.ToolboxModalService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.TreeService");
goog.require("blocklyApp.VariableModalService");
blocklyApp.SidebarComponent = ng.core.Component({
    selector: "blockly-sidebar",
    template: '\n    <div class="blocklySidebarColumn">\n      <button *ngFor="#buttonConfig of customSidebarButtons"\n              id="{{buttonConfig.id || undefined}}"\n              (click)="buttonConfig.action()"\n              class="blocklySidebarButton">\n        {{buttonConfig.text}}\n      </button>\n      <button id="{{ID_FOR_ATTACH_TO_LINK_BUTTON}}"\n              (click)="showToolboxModalForAttachToMarkedConnection()"\n              [attr.disabled]="!isAnyConnectionMarked() ? \'disabled\' : undefined"\n              [attr.aria-disabled]="!isAnyConnectionMarked()"\n              class="blocklySidebarButton">\n        {{\'ATTACH_NEW_BLOCK_TO_LINK\'|translate}}\n      </button>\n      <button id="{{ID_FOR_CREATE_NEW_GROUP_BUTTON}}"\n              (click)="showToolboxModalForCreateNewGroup()"\n              class="blocklySidebarButton">\n        {{\'CREATE_NEW_BLOCK_GROUP\'|translate}}\n      </button>\n      <button id="clear-workspace" (click)="clearWorkspace()"\n              [attr.disabled]="isWorkspaceEmpty() ? \'disabled\' : undefined"\n              [attr.aria-disabled]="isWorkspaceEmpty()"\n              class="blocklySidebarButton">\n        {{\'ERASE_WORKSPACE\'|translate}}\n      </button>\n      <button *ngIf="hasVariableCategory()" id="add-variable"\n              (click)="showAddVariableModal()"\n              class="blocklySidebarButton">\n        Add Variable\n      </button>\n    </div>\n  ',
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.BlockConnectionService,
        blocklyApp.ToolboxModalService, blocklyApp.TreeService, blocklyApp.UtilsService, blocklyApp.VariableModalService,
        function(blockConnectionService, toolboxModalService, treeService, utilsService, variableService) {
            this.customSidebarButtons = ACCESSIBLE_GLOBALS && ACCESSIBLE_GLOBALS.customSidebarButtons ? ACCESSIBLE_GLOBALS.customSidebarButtons : [];
            this.blockConnectionService = blockConnectionService;
            this.toolboxModalService = toolboxModalService;
            this.treeService = treeService;
            this.utilsService = utilsService;
            this.variableModalService =
                variableService;
            this.ID_FOR_ATTACH_TO_LINK_BUTTON = "blocklyAttachToLinkBtn";
            this.ID_FOR_CREATE_NEW_GROUP_BUTTON = "blocklyCreateNewGroupBtn"
        }
    ],
    isAnyConnectionMarked: function() {
        return this.blockConnectionService.isAnyConnectionMarked()
    },
    isWorkspaceEmpty: function() {
        return this.utilsService.isWorkspaceEmpty()
    },
    hasVariableCategory: function() {
        return this.toolboxModalService.toolboxHasVariableCategory()
    },
    clearWorkspace: function() {
        blocklyApp.workspace.clear();
        this.treeService.clearAllActiveDescs();
        setTimeout(function() {
                document.getElementById(blocklyApp.ID_FOR_EMPTY_WORKSPACE_BTN).focus()
            },
            50)
    },
    showToolboxModalForAttachToMarkedConnection: function() {
        this.toolboxModalService.showToolboxModalForAttachToMarkedConnection(this.ID_FOR_ATTACH_TO_LINK_BUTTON)
    },
    showToolboxModalForCreateNewGroup: function() {
        this.toolboxModalService.showToolboxModalForCreateNewGroup(this.ID_FOR_CREATE_NEW_GROUP_BUTTON)
    },
    showAddVariableModal: function() {
        this.variableModalService.showAddModal_("item")
    }
});
goog.provide("blocklyApp.ToolboxModalComponent");
goog.require("Blockly.CommonModal");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.KeyboardInputService");
goog.require("blocklyApp.ToolboxModalService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.TreeService");
goog.require("blocklyApp.UtilsService");
blocklyApp.ToolboxModalComponent = ng.core.Component({
    selector: "blockly-toolbox-modal",
    template: '\n    <div *ngIf="modalIsVisible" class="blocklyModalCurtain"\n         (click)="dismissModal()">\n      \x3c!-- $event.stopPropagation() prevents the modal from closing when its\n      interior is clicked. --\x3e\n      <div id="toolboxModal" class="blocklyModal" role="alertdialog"\n           (click)="$event.stopPropagation()" tabindex="-1"\n           aria-labelledby="toolboxModalHeading">\n        <h3 id="toolboxModalHeading">{{\'SELECT_A_BLOCK\'|translate}}</h3>\n\n        <div *ngFor="#toolboxCategory of toolboxCategories; #categoryIndex=index">\n          <h4 *ngIf="toolboxCategory.categoryName">{{toolboxCategory.categoryName}}</h4>\n          <div class="blocklyModalButtonContainer"\n               *ngFor="#block of toolboxCategory.blocks; #blockIndex=index">\n            <button [id]="getOptionId(getOverallIndex(categoryIndex, blockIndex))"\n                    (click)="selectBlock(getBlock(categoryIndex, blockIndex))"\n                    [ngClass]="{activeButton: activeButtonIndex == getOverallIndex(categoryIndex, blockIndex)}">\n              {{getBlockDescription(block)}}\n            </button>\n          </div>\n        </div>\n        <hr>\n        <div class="blocklyModalButtonContainer">\n          <button [id]="getCancelOptionId()" (click)="dismissModal()"\n                  [ngClass]="{activeButton: activeButtonIndex == totalNumBlocks}">\n            {{\'CANCEL\'|translate}}\n          </button>\n        </div>\n      </div>\n    </div>\n  ',
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.ToolboxModalService,
        blocklyApp.KeyboardInputService, blocklyApp.AudioService, blocklyApp.UtilsService, blocklyApp.TreeService,
        function(toolboxModalService_, keyboardInputService_, audioService_, utilsService_, treeService_) {
            this.toolboxModalService = toolboxModalService_;
            this.keyboardInputService = keyboardInputService_;
            this.audioService = audioService_;
            this.utilsService = utilsService_;
            this.treeService = treeService_;
            this.modalIsVisible = false;
            this.toolboxCategories = [];
            this.onSelectBlockCallback = null;
            this.onDismissCallback = null;
            this.firstBlockIndexes = [];
            this.activeButtonIndex = -1;
            this.totalNumBlocks = 0;
            var that = this;
            this.toolboxModalService.registerPreShowHook(function(toolboxCategories, onSelectBlockCallback, onDismissCallback) {
                that.modalIsVisible = true;
                that.toolboxCategories = toolboxCategories;
                that.onSelectBlockCallback = onSelectBlockCallback;
                that.onDismissCallback = onDismissCallback;
                that.firstBlockIndexes = [];
                that.activeButtonIndex = -1;
                that.totalNumBlocks = 0;
                var cumulativeIndex = 0;
                that.toolboxCategories.forEach(function(category) {
                    that.firstBlockIndexes.push(cumulativeIndex);
                    cumulativeIndex += category.blocks.length
                });
                that.firstBlockIndexes.push(cumulativeIndex);
                that.totalNumBlocks = cumulativeIndex;
                Blockly.CommonModal.setupKeyboardOverrides(that);
                that.keyboardInputService.addOverride("13", function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (that.activeButtonIndex == -1) return;
                    var button = document.getElementById(that.getOptionId(that.activeButtonIndex));
                    for (var i = 0; i < that.toolboxCategories.length; i++)
                        if (that.firstBlockIndexes[i + 1] > that.activeButtonIndex) {
                            var categoryIndex =
                                i;
                            var blockIndex = that.activeButtonIndex - that.firstBlockIndexes[i];
                            var block = that.getBlock(categoryIndex, blockIndex);
                            that.selectBlock(block);
                            return
                        } that.dismissModal()
                });
                setTimeout(function() {
                    document.getElementById("toolboxModal").focus()
                }, 150)
            })
        }
    ],
    hideModal_: Blockly.CommonModal.hideModal,
    focusOnOption: function(index) {
        var button = document.getElementById(this.getOptionId(index));
        button.focus()
    },
    numInteractiveElements: function() {
        return this.totalNumBlocks + 1
    },
    getOverallIndex: function(categoryIndex, blockIndex) {
        return this.firstBlockIndexes[categoryIndex] +
            blockIndex
    },
    getBlock: function(categoryIndex, blockIndex) {
        return this.toolboxCategories[categoryIndex].blocks[blockIndex]
    },
    getBlockDescription: function(block) {
        return this.utilsService.getBlockDescription(block)
    },
    getOptionId: function(index) {
        return "toolbox-modal-option-" + index
    },
    getCancelOptionId: function() {
        return "toolbox-modal-option-" + this.totalNumBlocks
    },
    selectBlock: function(block) {
        this.onSelectBlockCallback(block);
        this.hideModal_()
    },
    dismissModal: function() {
        this.hideModal_();
        this.onDismissCallback()
    }
});
goog.provide("blocklyApp.ToolboxModalService");
goog.require("blocklyApp.UtilsService");
goog.require("blocklyApp.BlockConnectionService");
goog.require("blocklyApp.NotificationsService");
goog.require("blocklyApp.TreeService");
blocklyApp.ToolboxModalService = ng.core.Class({
    constructor: [blocklyApp.BlockConnectionService, blocklyApp.NotificationsService, blocklyApp.TreeService, blocklyApp.UtilsService, function(blockConnectionService, notificationsService, treeService, utilsService) {
        this.blockConnectionService = blockConnectionService;
        this.notificationsService = notificationsService;
        this.treeService = treeService;
        this.utilsService = utilsService;
        this.modalIsShown = false;
        this.selectedToolboxCategories = null;
        this.onSelectBlockCallback = null;
        this.onDismissCallback = null;
        this.hasVariableCategory = null;
        this.preShowHook = function() {
            throw Error("A pre-show hook must be defined for the toolbox modal before it " + "can be shown.");
        }
    }],
    populateToolbox_: function() {
        this.allToolboxCategories = [];
        var toolboxXmlElt = document.getElementById("blockly-toolbox-xml");
        var toolboxCategoryElts = toolboxXmlElt.getElementsByTagName("category");
        if (toolboxCategoryElts.length) {
            this.allToolboxCategories = Array.from(toolboxCategoryElts).map(function(categoryElt) {
                var tmpWorkspace =
                    new Blockly.Workspace;
                var custom = categoryElt.attributes.custom;
                if (custom && custom.value == Blockly.VARIABLE_CATEGORY_NAME) {
                    var varBlocks = Blockly.Variables.flyoutCategoryBlocks(blocklyApp.workspace);
                    varBlocks.forEach(function(block) {
                        Blockly.Xml.domToBlock(block, tmpWorkspace)
                    })
                } else Blockly.Xml.domToWorkspace(categoryElt, tmpWorkspace);
                return {
                    categoryName: categoryElt.attributes.name.value,
                    blocks: tmpWorkspace.topBlocks_
                }
            });
            this.computeCategoriesForCreateNewGroupModal_()
        } else {
            var that = this;
            var tmpWorkspace =
                new Blockly.Workspace;
            Array.from(toolboxXmlElt.children).forEach(function(topLevelNode) {
                Blockly.Xml.domToBlock(topLevelNode, tmpWorkspace)
            });
            that.allToolboxCategories = [{
                categoryName: "",
                blocks: tmpWorkspace.topBlocks_
            }];
            that.computeCategoriesForCreateNewGroupModal_()
        }
    },
    computeCategoriesForCreateNewGroupModal_: function() {
        this.toolboxCategoriesForNewGroup = [];
        var that = this;
        this.allToolboxCategories.forEach(function(toolboxCategory) {
            var baseBlocks = toolboxCategory.blocks.filter(function(block) {
                return !block.outputConnection
            });
            if (baseBlocks.length > 0) that.toolboxCategoriesForNewGroup.push({
                categoryName: toolboxCategory.categoryName,
                blocks: baseBlocks
            })
        })
    },
    registerPreShowHook: function(preShowHook) {
        var that = this;
        this.preShowHook = function() {
            preShowHook(that.selectedToolboxCategories, that.onSelectBlockCallback, that.onDismissCallback)
        }
    },
    isModalShown: function() {
        return this.modalIsShown
    },
    toolboxHasVariableCategory: function() {
        if (this.hasVariableCategory === null) {
            var toolboxXmlElt = document.getElementById("blockly-toolbox-xml");
            var toolboxCategoryElts =
                toolboxXmlElt.getElementsByTagName("category");
            var that = this;
            Array.from(toolboxCategoryElts).forEach(function(categoryElt) {
                var custom = categoryElt.attributes.custom;
                if (custom && custom.value == Blockly.VARIABLE_CATEGORY_NAME) that.hasVariableCategory = true
            });
            if (this.hasVariableCategory === null) this.hasVariableCategory = false
        }
        return this.hasVariableCategory
    },
    showModal_: function(selectedToolboxCategories, onSelectBlockCallback, onDismissCallback) {
        this.selectedToolboxCategories = selectedToolboxCategories;
        this.onSelectBlockCallback =
            onSelectBlockCallback;
        this.onDismissCallback = onDismissCallback;
        this.preShowHook();
        this.modalIsShown = true
    },
    hideModal: function() {
        this.modalIsShown = false
    },
    showToolboxModalForAttachToMarkedConnection: function(sourceButtonId) {
        var that = this;
        var selectedToolboxCategories = [];
        this.populateToolbox_();
        this.allToolboxCategories.forEach(function(toolboxCategory) {
            var selectedBlocks = toolboxCategory.blocks.filter(function(block) {
                return that.blockConnectionService.canBeAttachedToMarkedConnection(block)
            });
            if (selectedBlocks.length >
                0) selectedToolboxCategories.push({
                categoryName: toolboxCategory.categoryName,
                blocks: selectedBlocks
            })
        });
        this.showModal_(selectedToolboxCategories, function(block) {
            var blockDescription = that.utilsService.getBlockDescription(block);
            var destinationTreeId = that.treeService.getTreeIdForBlock(that.blockConnectionService.getMarkedConnectionSourceBlock().id);
            that.treeService.clearActiveDesc(destinationTreeId);
            var newBlockId = that.blockConnectionService.attachToMarkedConnection(block);
            setTimeout(function() {
                that.treeService.focusOnBlock(newBlockId);
                that.notificationsService.speak("Attached. Now on, " + blockDescription + ", block in workspace.")
            })
        }, function() {
            document.getElementById(sourceButtonId).focus()
        })
    },
    showToolboxModalForCreateNewGroup: function(sourceButtonId) {
        var that = this;
        this.populateToolbox_();
        this.showModal_(this.toolboxCategoriesForNewGroup, function(block) {
            var blockDescription = that.utilsService.getBlockDescription(block);
            var xml = Blockly.Xml.blockToDom(block);
            var newBlockId = Blockly.Xml.domToBlock(xml, blocklyApp.workspace).id;
            setTimeout(function() {
                that.treeService.focusOnBlock(newBlockId);
                that.notificationsService.speak("Created new group in workspace. Now on, " + blockDescription + ", block in workspace.")
            })
        }, function() {
            document.getElementById(sourceButtonId).focus()
        })
    }
});
goog.provide("blocklyApp.TranslatePipe");
blocklyApp.TranslatePipe = ng.core.Pipe({
    name: "translate"
}).Class({
    constructor: function() {},
    transform: function(messageId) {
        return Blockly.Msg[messageId]
    }
});
goog.provide("blocklyApp.TreeService");
goog.require("blocklyApp.UtilsService");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.BlockConnectionService");
goog.require("blocklyApp.BlockOptionsModalService");
goog.require("blocklyApp.NotificationsService");
goog.require("blocklyApp.VariableModalService");
blocklyApp.TreeService = ng.core.Class({
    constructor: [blocklyApp.AudioService, blocklyApp.BlockConnectionService, blocklyApp.BlockOptionsModalService, blocklyApp.NotificationsService, blocklyApp.UtilsService, blocklyApp.VariableModalService, function(audioService, blockConnectionService, blockOptionsModalService, notificationsService, utilsService, variableModalService) {
        this.audioService = audioService;
        this.blockConnectionService = blockConnectionService;
        this.blockOptionsModalService = blockOptionsModalService;
        this.notificationsService =
            notificationsService;
        this.utilsService = utilsService;
        this.variableModalService = variableModalService;
        this.BLOCK_ROOT_ID_SUFFIX_ = blocklyApp.BLOCK_ROOT_ID_SUFFIX;
        this.activeDescendantIds_ = {};
        this.sidebarButtonElements_ = Array.from(document.querySelectorAll("button.blocklySidebarButton"))
    }],
    scrollToElement_: function(elementId) {
        var element = document.getElementById(elementId);
        var documentElement = document.body || document.documentElement;
        if (element.offsetTop < documentElement.scrollTop || element.offsetTop > documentElement.scrollTop +
            window.innerHeight) window.scrollTo(0, element.offsetTop - 10)
    },
    isLi_: function(node) {
        return node.tagName == "LI"
    },
    getParentLi_: function(element) {
        var nextNode = element.parentNode;
        while (nextNode && !this.isLi_(nextNode)) nextNode = nextNode.parentNode;
        return nextNode
    },
    getFirstChildLi_: function(element) {
        var childList = element.children;
        for (var i = 0; i < childList.length; i++)
            if (this.isLi_(childList[i])) return childList[i];
            else {
                var potentialElement = this.getFirstChildLi_(childList[i]);
                if (potentialElement) return potentialElement
            } return null
    },
    getLastChildLi_: function(element) {
        var childList = element.children;
        for (var i = childList.length - 1; i >= 0; i--)
            if (this.isLi_(childList[i])) return childList[i];
            else {
                var potentialElement = this.getLastChildLi_(childList[i]);
                if (potentialElement) return potentialElement
            } return null
    },
    getInitialSiblingLi_: function(element) {
        while (true) {
            var previousSibling = this.getPreviousSiblingLi_(element);
            if (previousSibling && previousSibling.id != element.id) element = previousSibling;
            else return element
        }
    },
    getPreviousSiblingLi_: function(element) {
        if (element.previousElementSibling) {
            var sibling =
                element.previousElementSibling;
            return this.isLi_(sibling) ? sibling : this.getLastChildLi_(sibling)
        } else {
            var parent = element.parentNode;
            while (parent && parent.tagName != "OL")
                if (parent.previousElementSibling) {
                    var node = parent.previousElementSibling;
                    return this.isLi_(node) ? node : this.getLastChildLi_(node)
                } else parent = parent.parentNode;
            return null
        }
    },
    getNextSiblingLi_: function(element) {
        if (element.nextElementSibling) {
            var sibling = element.nextElementSibling;
            return this.isLi_(sibling) ? sibling : this.getFirstChildLi_(sibling)
        } else {
            var parent =
                element.parentNode;
            while (parent && parent.tagName != "OL")
                if (parent.nextElementSibling) {
                    var node = parent.nextElementSibling;
                    return this.isLi_(node) ? node : this.getFirstChildLi_(node)
                } else parent = parent.parentNode;
            return null
        }
    },
    getFinalSiblingLi_: function(element) {
        while (true) {
            var nextSibling = this.getNextSiblingLi_(element);
            if (nextSibling && nextSibling.id != element.id) element = nextSibling;
            else return element
        }
    },
    getWorkspaceFocusTargets_: function() {
        return Array.from(document.querySelectorAll(".blocklyWorkspaceFocusTarget"))
    },
    getAllFocusTargets_: function() {
        return this.getWorkspaceFocusTargets_().concat(this.sidebarButtonElements_)
    },
    getNextFocusTargetId_: function(treeId) {
        var trees = this.getAllFocusTargets_();
        for (var i = 0; i < trees.length - 1; i++)
            if (trees[i].id == treeId) return trees[i + 1].id;
        return null
    },
    getPreviousFocusTargetId_: function(treeId) {
        var trees = this.getAllFocusTargets_();
        for (var i = trees.length - 1; i > 0; i--)
            if (trees[i].id == treeId) return trees[i - 1].id;
        return null
    },
    getActiveDescId: function(treeId) {
        return this.activeDescendantIds_[treeId] ||
            ""
    },
    initActiveDesc: function(treeId) {
        var tree = document.getElementById(treeId);
        this.setActiveDesc(this.getFirstChildLi_(tree).id, treeId)
    },
    setActiveDesc: function(newActiveDescId, treeId) {
        if (this.getActiveDescId(treeId)) this.clearActiveDesc(treeId);
        document.getElementById(newActiveDescId).classList.add("blocklyActiveDescendant");
        this.activeDescendantIds_[treeId] = newActiveDescId;
        this.scrollToElement_(newActiveDescId)
    },
    clearActiveDesc: function(treeId) {
        var activeDesc = document.getElementById(this.getActiveDescId(treeId));
        if (activeDesc) activeDesc.classList.remove("blocklyActiveDescendant");
        if (this.activeDescendantIds_[treeId]) delete this.activeDescendantIds_[treeId]
    },
    clearAllActiveDescs: function() {
        for (var treeId in this.activeDescendantIds_) {
            var activeDesc = document.getElementById(this.getActiveDescId(treeId));
            if (activeDesc) activeDesc.classList.remove("blocklyActiveDescendant")
        }
        this.activeDescendantIds_ = {}
    },
    isTreeRoot_: function(element) {
        return element.classList.contains("blocklyTree")
    },
    getBlockRootId_: function(blockId) {
        return blockId +
            this.BLOCK_ROOT_ID_SUFFIX_
    },
    getContainingBlock_: function(domElement) {
        var potentialBlockRoot = domElement;
        while (potentialBlockRoot.id.indexOf(this.BLOCK_ROOT_ID_SUFFIX_) === -1) potentialBlockRoot = potentialBlockRoot.parentNode;
        var blockRootId = potentialBlockRoot.id;
        var blockId = blockRootId.substring(0, blockRootId.length - this.BLOCK_ROOT_ID_SUFFIX_.length);
        return blocklyApp.workspace.getBlockById(blockId)
    },
    isTopLevelBlock_: function(block) {
        return !block.getParent()
    },
    isIsolatedTopLevelBlock_: function(block) {
        var blockHasNoSiblings =
            (!block.nextConnection || !block.nextConnection.targetConnection) && (!block.previousConnection || !block.previousConnection.targetConnection);
        return this.isTopLevelBlock_(block) && blockHasNoSiblings
    },
    safelyRemoveBlock_: function(block, deleteBlockFunc, areNextBlocksRemoved) {
        var treeId = this.getTreeIdForBlock(block.id);
        var treeCeasesToExist = areNextBlocksRemoved ? this.isTopLevelBlock_(block) : this.isIsolatedTopLevelBlock_(block);
        if (treeCeasesToExist) {
            var nextElementToFocusOn = null;
            var focusTargets = this.getWorkspaceFocusTargets_();
            for (var i = 0; i < focusTargets.length; i++)
                if (focusTargets[i].id == treeId) {
                    if (i + 1 < focusTargets.length) nextElementToFocusOn = focusTargets[i + 1];
                    else if (i > 0) nextElementToFocusOn = focusTargets[i - 1];
                    break
                } this.clearActiveDesc(treeId);
            deleteBlockFunc();
            setTimeout(function() {
                if (nextElementToFocusOn) nextElementToFocusOn.focus();
                else document.getElementById(blocklyApp.ID_FOR_EMPTY_WORKSPACE_BTN).focus()
            })
        } else {
            var blockRootId = this.getBlockRootId_(block.id);
            var blockRootElement = document.getElementById(blockRootId);
            if (areNextBlocksRemoved) var newActiveDesc = this.getParentLi_(blockRootElement) || this.getPreviousSiblingLi_(blockRootElement);
            else var newActiveDesc = this.getParentLi_(blockRootElement) || this.getNextSiblingLi_(blockRootElement) || this.getPreviousSiblingLi_(blockRootElement);
            this.clearActiveDesc(treeId);
            deleteBlockFunc();
            var that = this;
            setTimeout(function() {
                that.setActiveDesc(newActiveDesc.id, treeId);
                document.getElementById(treeId).focus()
            })
        }
    },
    getTreeIdForBlock: function(blockId) {
        var potentialRoot = document.getElementById(this.getBlockRootId_(blockId));
        while (!this.isTreeRoot_(potentialRoot)) potentialRoot = potentialRoot.parentNode;
        return potentialRoot.id
    },
    focusOnBlock: function(blockId) {
        var that = this;
        setTimeout(function() {
            var treeId = that.getTreeIdForBlock(blockId);
            document.getElementById(treeId).focus();
            that.setActiveDesc(that.getBlockRootId_(blockId), treeId)
        })
    },
    showBlockOptionsModal: function(block) {
        var that = this;
        var actionButtonsInfo = [];
        if (block.previousConnection) actionButtonsInfo.push({
            action: function() {
                that.blockConnectionService.markConnection(block.previousConnection);
                that.focusOnBlock(block.id)
            },
            translationIdForText: "MARK_SPOT_BEFORE"
        });
        if (block.nextConnection) actionButtonsInfo.push({
            action: function() {
                that.blockConnectionService.markConnection(block.nextConnection);
                that.focusOnBlock(block.id)
            },
            translationIdForText: "MARK_SPOT_AFTER"
        });
        if (this.blockConnectionService.canBeMovedToMarkedConnection(block)) actionButtonsInfo.push({
            action: function() {
                var blockDescription = that.utilsService.getBlockDescription(block);
                var oldDestinationTreeId = that.getTreeIdForBlock(that.blockConnectionService.getMarkedConnectionSourceBlock().id);
                that.clearActiveDesc(oldDestinationTreeId);
                var newBlockId = that.blockConnectionService.attachToMarkedConnection(block);
                that.safelyRemoveBlock_(block, function() {
                    block.dispose(false)
                }, true);
                setTimeout(function() {
                    that.focusOnBlock(newBlockId);
                    var newDestinationTreeId = that.getTreeIdForBlock(newBlockId);
                    if (newDestinationTreeId != oldDestinationTreeId)
                        if (document.getElementById(oldDestinationTreeId)) {
                            var activeDescId = that.getActiveDescId(oldDestinationTreeId);
                            var activeDescTreeId = null;
                            if (activeDescId) {
                                var oldDestinationBlock =
                                    that.getContainingBlock_(document.getElementById(activeDescId));
                                activeDescTreeId = that.getTreeIdForBlock(oldDestinationBlock);
                                if (activeDescTreeId != oldDestinationTreeId) that.clearActiveDesc(oldDestinationTreeId)
                            }
                            that.initActiveDesc(oldDestinationTreeId)
                        } that.notificationsService.speak(blockDescription + " " + Blockly.Msg.ATTACHED_BLOCK_TO_LINK_MSG + ". Now on attached block in workspace.")
                })
            },
            translationIdForText: "MOVE_TO_MARKED_SPOT"
        });
        actionButtonsInfo.push({
            action: function() {
                var blockDescription = that.utilsService.getBlockDescription(block);
                that.safelyRemoveBlock_(block, function() {
                    block.dispose(true);
                    that.audioService.playDeleteSound()
                }, false);
                setTimeout(function() {
                    var message = blockDescription + " deleted. " + (that.utilsService.isWorkspaceEmpty() ? "Workspace is empty." : "Now on workspace.");
                    that.notificationsService.speak(message)
                })
            },
            translationIdForText: "DELETE"
        });
        this.blockOptionsModalService.showModal(actionButtonsInfo, function() {
            that.focusOnBlock(block.id)
        })
    },
    moveUpOneLevel_: function(treeId) {
        var activeDesc = document.getElementById(this.getActiveDescId(treeId));
        var nextNode = this.getParentLi_(activeDesc);
        if (nextNode) this.setActiveDesc(nextNode.id, treeId);
        else this.audioService.playOopsSound()
    },
    onKeypress: function(e, tree) {
        if (this.blockOptionsModalService.isModalShown() || this.variableModalService.isModalShown()) return;
        var treeId = tree.id;
        var activeDesc = document.getElementById(this.getActiveDescId(treeId));
        if (!activeDesc) {
            this.initActiveDesc(treeId);
            activeDesc = document.getElementById(this.getActiveDescId(treeId))
        }
        if (e.altKey || e.ctrlKey) return;
        if (document.activeElement.tagName ==
            "INPUT" || document.activeElement.tagName == "SELECT") {
            if (e.keyCode == 9 || e.keyCode == 13 || e.keyCode == 27) {
                document.getElementById(treeId).focus();
                if (e.keyCode == 27 || e.keyCode == 13) {
                    e.preventDefault();
                    e.stopPropagation()
                }
            }
        } else if (e.keyCode == 13) {
            e.stopPropagation();
            var found = false;
            var dfsStack = Array.from(activeDesc.children);
            while (dfsStack.length) {
                var currentNode = dfsStack.shift();
                if (currentNode.tagName == "BUTTON") {
                    currentNode.click();
                    found = true;
                    break
                } else if (currentNode.tagName == "INPUT") {
                    currentNode.focus();
                    currentNode.select();
                    this.notificationsService.speak("Type a value, then press Escape to exit");
                    found = true;
                    break
                } else if (currentNode.tagName == "SELECT") {
                    currentNode.focus();
                    found = true;
                    return
                } else if (currentNode.tagName == "LI") continue;
                if (currentNode.children) {
                    var reversedChildren = Array.from(currentNode.children).reverse();
                    reversedChildren.forEach(function(childNode) {
                        dfsStack.unshift(childNode)
                    })
                }
            }
            if (!found) {
                var block = this.getContainingBlock_(activeDesc);
                this.showBlockOptionsModal(block)
            }
        } else if (e.keyCode ==
            9);
        else if ([27, 35, 36, 37, 38, 39, 40].indexOf(e.keyCode) !== -1) {
            if (e.keyCode == 27 || e.keyCode == 37) this.moveUpOneLevel_(treeId);
            else if (e.keyCode == 35) {
                var potentialFinalSibling = this.getFinalSiblingLi_(activeDesc);
                if (potentialFinalSibling) this.setActiveDesc(potentialFinalSibling.id, treeId)
            } else if (e.keyCode == 36) {
                var potentialInitialSibling = this.getInitialSiblingLi_(activeDesc);
                if (potentialInitialSibling) this.setActiveDesc(potentialInitialSibling.id, treeId)
            } else if (e.keyCode == 38) {
                var potentialPrevSibling = this.getPreviousSiblingLi_(activeDesc);
                if (potentialPrevSibling) this.setActiveDesc(potentialPrevSibling.id, treeId);
                else {
                    var statusMessage = "Reached top of list.";
                    if (this.getParentLi_(activeDesc)) statusMessage += " Press left to go to parent list.";
                    this.audioService.playOopsSound(statusMessage)
                }
            } else if (e.keyCode == 39) {
                var potentialFirstChild = this.getFirstChildLi_(activeDesc);
                if (potentialFirstChild) this.setActiveDesc(potentialFirstChild.id, treeId);
                else this.audioService.playOopsSound()
            } else if (e.keyCode == 40) {
                var potentialNextSibling = this.getNextSiblingLi_(activeDesc);
                if (potentialNextSibling) this.setActiveDesc(potentialNextSibling.id, treeId);
                else this.audioService.playOopsSound("Reached bottom of list.")
            }
            e.preventDefault();
            e.stopPropagation()
        }
    }
});
goog.provide("blocklyApp.UtilsService");
blocklyApp.ID_FOR_EMPTY_WORKSPACE_BTN = "blocklyEmptyWorkspaceBtn";
blocklyApp.BLOCK_ROOT_ID_SUFFIX = "-blockRoot";
blocklyApp.UtilsService = ng.core.Class({
    constructor: [function() {}],
    getBlockDescription: function(block) {
        return block.toString(undefined, "BLANK")
    },
    isWorkspaceEmpty: function() {
        return !blocklyApp.workspace.topBlocks_.length
    }
});
goog.provide("blocklyApp.VariableAddModalComponent");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.KeyboardInputService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.VariableModalService");
goog.require("Blockly.CommonModal");
blocklyApp.VariableAddModalComponent = ng.core.Component({
    selector: "blockly-add-variable-modal",
    template: '\n    <div *ngIf="modalIsVisible"class="blocklyModalCurtain"\n         (click)="dismissModal()">\n      \x3c!-- $event.stopPropagation() prevents the modal from closing when its\n      interior is clicked. --\x3e\n      <div id="varModal" class="blocklyModal" role="alertdialog"\n           (click)="$event.stopPropagation()" tabindex="0"\n           aria-labelledby="variableModalHeading">\n          <h3 id="variableModalHeading">Add a variable...</h3>\n\n          <form id="varForm">\n            <p id="inputLabel">New Variable Name:\n              <input id="mainFieldId" type="text" [ngModel]="VALUE"\n                     (ngModelChange)="setTextValue($event)" tabindex="0"\n                     aria-labelledby="inputLabel" />\n            </p>\n            <hr>\n            <button type="button" id="submitButton" (click)="submit()">\n              SUBMIT\n            </button>\n            <button type="button" id="cancelButton" (click)="dismissModal()">\n              CANCEL\n            </button>\n          </form>\n      </div>\n    </div>\n  ',
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.AudioService,
        blocklyApp.KeyboardInputService, blocklyApp.VariableModalService,
        function(audioService, keyboardService, variableService) {
            this.workspace = blocklyApp.workspace;
            this.variableModalService = variableService;
            this.audioService = audioService;
            this.keyboardInputService = keyboardService;
            this.modalIsVisible = false;
            this.activeButtonIndex = -1;
            var that = this;
            this.variableModalService.registerPreAddShowHook(function() {
                that.modalIsVisible = true;
                Blockly.CommonModal.setupKeyboardOverrides(that);
                setTimeout(function() {
                        document.getElementById("varModal").focus()
                    },
                    150)
            })
        }
    ],
    setTextValue: function(newValue) {
        this.variableName = newValue
    },
    hideModal_: Blockly.CommonModal.hideModal,
    focusOnOption: Blockly.CommonModal.focusOnOption,
    numInteractiveElements: Blockly.CommonModal.numInteractiveElements,
    getInteractiveElements: Blockly.CommonModal.getInteractiveElements,
    getInteractiveContainer: function() {
        return document.getElementById("varForm")
    },
    submit: function() {
        this.workspace.createVariable(this.variableName);
        this.dismissModal()
    },
    dismissModal: function() {
        this.variableModalService.hideModal();
        this.hideModal_()
    }
});
goog.provide("blocklyApp.VariableModalService");
blocklyApp.VariableModalService = ng.core.Class({
    constructor: [function() {
        this.modalIsShown = false
    }],
    registerPreAddShowHook: function(preShowHook) {
        this.preAddShowHook = function() {
            preShowHook()
        }
    },
    registerPreRenameShowHook: function(preShowHook) {
        this.preRenameShowHook = function(oldName) {
            preShowHook(oldName)
        }
    },
    registerPreRemoveShowHook: function(preShowHook) {
        this.preRemoveShowHook = function(oldName, count) {
            preShowHook(oldName, count)
        }
    },
    isModalShown: function() {
        return this.modalIsShown
    },
    showAddModal_: function() {
        this.preAddShowHook();
        this.modalIsShown = true
    },
    showRenameModal_: function(oldName) {
        this.preRenameShowHook(oldName);
        this.modalIsShown = true
    },
    showRemoveModal_: function(oldName) {
        var count = this.getNumVariables(oldName);
        this.modalIsShown = true;
        if (count > 1) this.preRemoveShowHook(oldName, count);
        else {
            var variable = blocklyApp.workspace.getVariable(oldName);
            blocklyApp.workspace.deleteVariableInternal_(variable);
            var that = this;
            setTimeout(function() {
                that.modalIsShown = false
            })
        }
    },
    getNumVariables: function(oldName) {
        return blocklyApp.workspace.getVariableUses(oldName).length
    },
    hideModal: function() {
        this.modalIsShown = false
    }
});
goog.provide("blocklyApp.VariableRemoveModalComponent");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.KeyboardInputService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.TreeService");
goog.require("blocklyApp.VariableModalService");
goog.require("Blockly.CommonModal");
blocklyApp.VariableRemoveModalComponent = ng.core.Component({
    selector: "blockly-remove-variable-modal",
    template: '\n    <div *ngIf="modalIsVisible"class="blocklyModalCurtain"\n         (click)="dismissModal()">\n      \x3c!-- $event.stopPropagation() prevents the modal from closing when its\n      interior is clicked. --\x3e\n      <div id="varModal" class="blocklyModal" role="alertdialog"\n           (click)="$event.stopPropagation()" tabindex="0"\n           aria-labelledby="variableModalHeading">\n          <h3 id="variableModalHeading">\n            Delete {{getNumVariables()}} uses of the "{{currentVariableName}}"\n            variable?\n          </h3>\n\n          <form id="varForm">\n            <hr>\n            <button type="button" id="yesButton" (click)="submit()">\n              YES\n            </button>\n            <button type="button" id="noButton" (click)="dismissModal()">\n              NO\n            </button>\n          </form>\n      </div>\n    </div>\n  ',
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.AudioService,
        blocklyApp.KeyboardInputService, blocklyApp.TreeService, blocklyApp.VariableModalService,
        function(audioService, keyboardService, treeService, variableService) {
            this.workspace = blocklyApp.workspace;
            this.treeService = treeService;
            this.variableModalService = variableService;
            this.audioService = audioService;
            this.keyboardInputService = keyboardService;
            this.modalIsVisible = false;
            this.activeButtonIndex = -1;
            this.currentVariableName = "";
            this.count = 0;
            var that = this;
            this.variableModalService.registerPreRemoveShowHook(function(name,
                count) {
                that.currentVariableName = name;
                that.count = count;
                that.modalIsVisible = true;
                Blockly.CommonModal.setupKeyboardOverrides(that);
                setTimeout(function() {
                    document.getElementById("varModal").focus()
                }, 150)
            })
        }
    ],
    hideModal_: Blockly.CommonModal.hideModal,
    focusOnOption: Blockly.CommonModal.focusOnOption,
    numInteractiveElements: Blockly.CommonModal.numInteractiveElements,
    getInteractiveElements: Blockly.CommonModal.getInteractiveElements,
    getInteractiveContainer: function() {
        return document.getElementById("varForm")
    },
    getNumVariables: function() {
        return this.variableModalService.getNumVariables(this.currentVariableName)
    },
    submit: function() {
        var variable = blocklyApp.workspace.getVariable(this.currentVariableName);
        blocklyApp.workspace.deleteVariableInternal_(variable);
        this.dismissModal()
    },
    dismissModal: function() {
        this.variableModalService.hideModal();
        this.hideModal_()
    }
});
goog.provide("blocklyApp.VariableRenameModalComponent");
goog.require("Blockly.CommonModal");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.KeyboardInputService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.VariableModalService");
blocklyApp.VariableRenameModalComponent = ng.core.Component({
    selector: "blockly-rename-variable-modal",
    template: '\n    <div *ngIf="modalIsVisible"class="blocklyModalCurtain"\n         (click)="dismissModal()">\n      \x3c!-- $event.stopPropagation() prevents the modal from closing when its\n      interior is clicked. --\x3e\n      <div id="varModal" class="blocklyModal" role="alertdialog"\n           (click)="$event.stopPropagation()" tabindex="0"\n           aria-labelledby="variableModalHeading">\n          <h3 id="variableModalHeading">\n            Rename the "{{currentVariableName}}" variable...\n          </h3>\n\n          <form id="varForm">\n            <p id="inputLabel">New Variable Name:\n              <input id="mainFieldId" type="text" [ngModel]="VALUE"\n                     (ngModelChange)="setTextValue($event)" tabindex="0"\n                     aria-labelledby="inputLabel" />\n            </p>\n            <hr>\n            <button type="button" id="submitButton" (click)="submit()">\n              SUBMIT\n            </button>\n            <button type="button" id="cancelButton" (click)="dismissModal()">\n              CANCEL\n            </button>\n          </form>\n      </div>\n    </div>\n  ',
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.AudioService,
        blocklyApp.KeyboardInputService, blocklyApp.VariableModalService,
        function(audioService, keyboardService, variableService) {
            this.workspace = blocklyApp.workspace;
            this.variableModalService = variableService;
            this.audioService = audioService;
            this.keyboardInputService = keyboardService;
            this.modalIsVisible = false;
            this.activeButtonIndex = -1;
            this.currentVariableName = "";
            var that = this;
            this.variableModalService.registerPreRenameShowHook(function(oldName) {
                that.currentVariableName = oldName;
                that.modalIsVisible = true;
                Blockly.CommonModal.setupKeyboardOverrides(that);
                setTimeout(function() {
                    document.getElementById("varModal").focus()
                }, 150)
            })
        }
    ],
    setTextValue: function(newValue) {
        this.variableName = newValue
    },
    hideModal_: Blockly.CommonModal.hideModal,
    focusOnOption: Blockly.CommonModal.focusOnOption,
    numInteractiveElements: Blockly.CommonModal.numInteractiveElements,
    getInteractiveElements: Blockly.CommonModal.getInteractiveElements,
    getInteractiveContainer: function() {
        return document.getElementById("varForm")
    },
    submit: function() {
        this.workspace.renameVariable(this.currentVariableName,
            this.variableName);
        this.dismissModal()
    },
    dismissModal: function() {
        this.variableModalService.hideModal();
        this.hideModal_()
    }
});
goog.provide("blocklyApp.WorkspaceBlockComponent");
goog.require("blocklyApp.UtilsService");
goog.require("blocklyApp.AudioService");
goog.require("blocklyApp.BlockConnectionService");
goog.require("blocklyApp.FieldSegmentComponent");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.TreeService");
blocklyApp.WorkspaceBlockComponent = ng.core.Component({
    selector: "blockly-workspace-block",
    template: '\n    <li [id]="componentIds.blockRoot" role="treeitem"\n        [attr.aria-labelledBy]="generateAriaLabelledByAttr(componentIds.blockSummary, \'blockly-translate-workspace-block\')"\n        [attr.aria-level]="level">\n      <label #blockSummaryLabel [id]="componentIds.blockSummary">{{getBlockDescription()}}</label>\n\n      <ol role="group">\n        <template ngFor #blockInput [ngForOf]="block.inputList" #i="index">\n          <li [id]="componentIds.inputs[i].inputLi" role="treeitem"\n              *ngIf="blockInput.fieldRow.length"\n              [attr.aria-labelledBy]="generateAriaLabelledByAttr(componentIds.inputs[i].fieldLabel)"\n              [attr.aria-level]="level + 1">\n            <blockly-field-segment *ngFor="#fieldSegment of inputListAsFieldSegments[i]"\n                                   [prefixFields]="fieldSegment.prefixFields"\n                                   [mainField]="fieldSegment.mainField"\n                                   [mainFieldId]="componentIds.inputs[i].fieldLabel"\n                                   [level]="level + 2">\n            </blockly-field-segment>\n          </li>\n\n          <template [ngIf]="blockInput.connection">\n            <blockly-workspace-block *ngIf="blockInput.connection.targetBlock()"\n                                     [block]="blockInput.connection.targetBlock()"\n                                     [level]="level + 1"\n                                     [tree]="tree">\n            </blockly-workspace-block>\n            <li [id]="componentIds.inputs[i].actionButtonLi" role="treeitem"\n                *ngIf="!blockInput.connection.targetBlock()"\n                [attr.aria-labelledBy]="generateAriaLabelledByAttr(componentIds.inputs[i].buttonLabel)"\n                [attr.aria-level]="level + 1">\n              <label [id]="componentIds.inputs[i].label">\n                {{getBlockNeededLabel(blockInput)}}\n              </label>\n              <button [id]="componentIds.inputs[i].actionButton"\n                      (click)="addInteriorLink(blockInput.connection)"\n                      tabindex="-1">\n                {{\'MARK_THIS_SPOT\'|translate}}\n              </button>\n            </li>\n          </template>\n        </template>\n      </ol>\n    </li>\n\n    <blockly-workspace-block *ngIf= "block.nextConnection && block.nextConnection.targetBlock()"\n                             [block]="block.nextConnection.targetBlock()"\n                             [level]="level" [tree]="tree">\n    </blockly-workspace-block>\n  ',
    directives: [blocklyApp.FieldSegmentComponent,
        ng.core.forwardRef(function() {
            return blocklyApp.WorkspaceBlockComponent
        })
    ],
    inputs: ["block", "level", "tree"],
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.AudioService, blocklyApp.BlockConnectionService, blocklyApp.TreeService, blocklyApp.UtilsService, function(audioService, blockConnectionService, treeService, utilsService) {
        this.audioService = audioService;
        this.blockConnectionService = blockConnectionService;
        this.treeService = treeService;
        this.utilsService = utilsService;
        this.cachedBlockId = null
    }],
    ngDoCheck: function() {
        if (this.cachedBlockId != this.block.id) {
            this.cachedBlockId = this.block.id;
            var SUPPORTED_FIELDS = [Blockly.FieldTextInput, Blockly.FieldDropdown];
            this.inputListAsFieldSegments = this.block.inputList.map(function(input) {
                var fieldSegments = [];
                var bufferedFields = [];
                input.fieldRow.forEach(function(field) {
                    var fieldIsSupported = SUPPORTED_FIELDS.some(function(fieldType) {
                        return field instanceof fieldType
                    });
                    if (fieldIsSupported) {
                        var fieldSegment = {
                            prefixFields: [],
                            mainField: field
                        };
                        bufferedFields.forEach(function(bufferedField) {
                            fieldSegment.prefixFields.push(bufferedField)
                        });
                        fieldSegments.push(fieldSegment);
                        bufferedFields = []
                    } else bufferedFields.push(field)
                });
                if (bufferedFields.length) fieldSegments.push({
                    prefixFields: bufferedFields,
                    mainField: null
                });
                return fieldSegments
            });
            this.componentIds = {};
            this.componentIds.blockRoot = this.block.id + blocklyApp.BLOCK_ROOT_ID_SUFFIX;
            this.componentIds.blockSummary = this.block.id + "-blockSummary";
            var that = this;
            this.componentIds.inputs = this.block.inputList.map(function(input, i) {
                var idsToGenerate = ["inputLi", "fieldLabel"];
                if (input.connection && !input.connection.targetBlock()) idsToGenerate.push("actionButtonLi",
                    "actionButton", "buttonLabel");
                var inputIds = {};
                idsToGenerate.forEach(function(idBaseString) {
                    inputIds[idBaseString] = [that.block.id, i, idBaseString].join("-")
                });
                return inputIds
            })
        }
    },
    ngAfterViewInit: function() {
        var that = this;
        setTimeout(function() {
            if (that.level === 0 && !that.treeService.getActiveDescId(that.tree.id)) that.treeService.setActiveDesc(that.componentIds.blockRoot, that.tree.id)
        })
    },
    addInteriorLink: function(connection) {
        this.blockConnectionService.markConnection(connection)
    },
    getBlockDescription: function() {
        var blockDescription =
            this.utilsService.getBlockDescription(this.block);
        var parentBlock = this.block.getSurroundParent();
        if (parentBlock) {
            var fullDescription = blockDescription + " inside " + this.utilsService.getBlockDescription(parentBlock);
            return fullDescription
        } else return blockDescription
    },
    getBlockNeededLabel: function(blockInput) {
        var inputTypeLabel = blockInput.connection.check_ ? blockInput.connection.check_.join(", ") : Blockly.Msg.ANY;
        var blockTypeLabel = blockInput.type == Blockly.NEXT_STATEMENT ? Blockly.Msg.BLOCK : Blockly.Msg.VALUE;
        return inputTypeLabel + " " + blockTypeLabel + " needed:"
    },
    generateAriaLabelledByAttr: function(mainLabel, secondLabel) {
        return mainLabel + (secondLabel ? " " + secondLabel : "")
    }
});
goog.provide("blocklyApp.WorkspaceComponent");
goog.require("blocklyApp.NotificationsService");
goog.require("blocklyApp.ToolboxModalService");
goog.require("blocklyApp.TranslatePipe");
goog.require("blocklyApp.TreeService");
goog.require("blocklyApp.WorkspaceBlockComponent");
blocklyApp.WorkspaceComponent = ng.core.Component({
    selector: "blockly-workspace",
    template: '\n    <div class="blocklyWorkspaceColumn">\n      <h3 #workspaceTitle id="blockly-workspace-title">{{\'WORKSPACE\'|translate}}</h3>\n\n      <div *ngIf="workspace" class="blocklyWorkspace">\n        <ol #tree *ngFor="#topBlock of workspace.topBlocks_; #groupIndex = index"\n            [id]="tree.id || getNewTreeId()"\n            tabindex="0" role="tree" class="blocklyTree blocklyWorkspaceFocusTarget"\n            [attr.aria-activedescendant]="getActiveDescId(tree.id)"\n            [attr.aria-labelledby]="workspaceTitle.id"\n            (keydown)="onKeypress($event, tree)"\n            (focus)="speakLocation(groupIndex, tree.id)">\n          <blockly-workspace-block [level]="0" [block]="topBlock" [tree]="tree">\n          </blockly-workspace-block>\n        </ol>\n\n        <span *ngIf="workspace.topBlocks_.length === 0">\n          <p id="emptyWorkspaceBtnLabel">\n            {{\'NO_BLOCKS_IN_WORKSPACE\'|translate}}\n            <button (click)="showToolboxModalForCreateNewGroup()"\n                    class="blocklyWorkspaceFocusTarget"\n                    id="{{ID_FOR_EMPTY_WORKSPACE_BTN}}"\n                    aria-describedby="emptyWorkspaceBtnLabel">\n              {{\'CREATE_NEW_BLOCK_GROUP\'|translate}}\n            </button>\n          </p>\n        </span>\n      </div>\n    </div>\n  ',
    directives: [blocklyApp.WorkspaceBlockComponent],
    pipes: [blocklyApp.TranslatePipe]
}).Class({
    constructor: [blocklyApp.NotificationsService, blocklyApp.ToolboxModalService, blocklyApp.TreeService, function(notificationsService, toolboxModalService, treeService) {
        this.notificationsService = notificationsService;
        this.toolboxModalService = toolboxModalService;
        this.treeService = treeService;
        this.ID_FOR_EMPTY_WORKSPACE_BTN = blocklyApp.ID_FOR_EMPTY_WORKSPACE_BTN;
        this.workspace = blocklyApp.workspace;
        this.currentTreeId = 0
    }],
    getNewTreeId: function() {
        this.currentTreeId++;
        return "blockly-tree-" +
            this.currentTreeId
    },
    getActiveDescId: function(treeId) {
        return this.treeService.getActiveDescId(treeId)
    },
    onKeypress: function(e, tree) {
        this.treeService.onKeypress(e, tree)
    },
    showToolboxModalForCreateNewGroup: function() {
        this.toolboxModalService.showToolboxModalForCreateNewGroup(this.ID_FOR_EMPTY_WORKSPACE_BTN)
    },
    speakLocation: function(groupIndex, treeId) {
        this.notificationsService.speak("Now in workspace group " + (groupIndex + 1) + " of " + this.workspace.topBlocks_.length)
    }
});
goog.provide("Blockly.Block");
goog.require("Blockly.Blocks");
goog.require("Blockly.Comment");
goog.require("Blockly.Connection");
goog.require("Blockly.Events.BlockChange");
goog.require("Blockly.Events.BlockCreate");
goog.require("Blockly.Events.BlockDelete");
goog.require("Blockly.Events.BlockMove");
goog.require("Blockly.Extensions");
goog.require("Blockly.Input");
goog.require("Blockly.Mutator");
goog.require("Blockly.utils");
goog.require("Blockly.Warning");
goog.require("Blockly.Workspace");
goog.require("goog.math.Coordinate");
Blockly.Block = function(workspace, prototypeName, opt_id) {
    if (typeof Blockly.Generator.prototype[prototypeName] !== "undefined") throw Error('Block prototypeName "' + prototypeName + '" conflicts with Blockly.Generator members.');
    this.id = opt_id && !workspace.getBlockById(opt_id) ? opt_id : Blockly.utils.genUid();
    workspace.blockDB_[this.id] = this;
    this.outputConnection = null;
    this.nextConnection = null;
    this.previousConnection = null;
    this.inputList = [];
    this.inputsInline = undefined;
    this.disabled = false;
    this.tooltip = "";
    this.contextMenu =
        true;
    this.parentBlock_ = null;
    this.childBlocks_ = [];
    this.deletable_ = true;
    this.movable_ = true;
    this.editable_ = true;
    this.isShadow_ = false;
    this.collapsed_ = false;
    this.comment = null;
    this.xy_ = new goog.math.Coordinate(0, 0);
    this.workspace = workspace;
    this.isInFlyout = workspace.isFlyout;
    this.isInMutator = workspace.isMutator;
    this.RTL = workspace.RTL;
    this.isInsertionMarker_ = false;
    if (prototypeName) {
        this.type = prototypeName;
        var prototype = Blockly.Blocks[prototypeName];
        if (!prototype || typeof prototype != "object") throw TypeError("Unknown block type: " +
            prototypeName);
        goog.mixin(this, prototype)
    }
    workspace.addTopBlock(this);
    if (typeof this.init == "function") this.init();
    this.inputsInlineDefault = this.inputsInline;
    if (Blockly.Events.isEnabled()) {
        var existingGroup = Blockly.Events.getGroup();
        if (!existingGroup) Blockly.Events.setGroup(true);
        try {
            Blockly.Events.fire(new Blockly.Events.BlockCreate(this))
        } finally {
            if (!existingGroup) Blockly.Events.setGroup(false)
        }
    }
    if (typeof this.onchange == "function") this.setOnChange(this.onchange)
};
Blockly.Block.obtain = function(workspace, prototypeName) {
    console.warn("Deprecated call to Blockly.Block.obtain, " + "use workspace.newBlock instead.");
    return workspace.newBlock(prototypeName)
};
Blockly.Block.prototype.data = null;
Blockly.Block.prototype.colour_ = "#000000";
Blockly.Block.prototype.hue_ = null;
Blockly.Block.prototype.dispose = function(healStack) {
    if (!this.workspace) return;
    if (this.onchangeWrapper_) this.workspace.removeChangeListener(this.onchangeWrapper_);
    this.unplug(healStack);
    if (Blockly.Events.isEnabled()) Blockly.Events.fire(new Blockly.Events.BlockDelete(this));
    Blockly.Events.disable();
    try {
        if (this.workspace) {
            this.workspace.removeTopBlock(this);
            delete this.workspace.blockDB_[this.id];
            this.workspace = null
        }
        if (Blockly.selected == this) Blockly.selected = null;
        for (var i = this.childBlocks_.length - 1; i >=
            0; i--) this.childBlocks_[i].dispose(false);
        for (var i = 0, input; input = this.inputList[i]; i++) input.dispose();
        this.inputList.length = 0;
        var connections = this.getConnections_(true);
        for (var i = 0; i < connections.length; i++) {
            var connection = connections[i];
            if (connection.isConnected()) connection.disconnect();
            connections[i].dispose()
        }
    } finally {
        Blockly.Events.enable()
    }
};
Blockly.Block.prototype.initModel = function() {
    for (var i = 0, input; input = this.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++)
            if (field.initModel) field.initModel()
};
Blockly.Block.prototype.unplug = function(opt_healStack) {
    if (this.outputConnection) this.unplugFromRow_(opt_healStack);
    else if (this.previousConnection) this.unplugFromStack_(opt_healStack)
};
Blockly.Block.prototype.unplugFromRow_ = function(opt_healStack) {
    var parentConnection = null;
    if (this.outputConnection.isConnected()) {
        parentConnection = this.outputConnection.targetConnection;
        this.outputConnection.disconnect()
    }
    if (!parentConnection || !opt_healStack) return;
    var thisConnection = this.getOnlyValueConnection_();
    if (!thisConnection || !thisConnection.isConnected()) return;
    var childConnection = thisConnection.targetConnection;
    if (childConnection.checkType_(parentConnection)) {
        childConnection.disconnect();
        parentConnection.connect(childConnection)
    }
};
Blockly.Block.prototype.getOnlyValueConnection_ = function() {
    var connection = null;
    for (var i = 0; i < this.inputList.length; i++) {
        var thisConnection = this.inputList[i].connection;
        if (thisConnection && thisConnection.type == Blockly.INPUT_VALUE) {
            if (connection) return null;
            connection = thisConnection
        }
    }
    return connection
};
Blockly.Block.prototype.unplugFromStack_ = function(opt_healStack) {
    var previousTarget = null;
    if (this.previousConnection.isConnected()) {
        previousTarget = this.previousConnection.targetConnection;
        this.previousConnection.disconnect()
    }
    var nextBlock = this.getNextBlock();
    if (opt_healStack && nextBlock) {
        var nextTarget = this.nextConnection.targetConnection;
        nextTarget.disconnect();
        if (previousTarget && previousTarget.checkType_(nextTarget)) previousTarget.connect(nextTarget)
    }
};
Blockly.Block.prototype.getConnections_ = function(_all) {
    var myConnections = [];
    if (this.outputConnection) myConnections.push(this.outputConnection);
    if (this.previousConnection) myConnections.push(this.previousConnection);
    if (this.nextConnection) myConnections.push(this.nextConnection);
    for (var i = 0, input; input = this.inputList[i]; i++)
        if (input.connection) myConnections.push(input.connection);
    return myConnections
};
Blockly.Block.prototype.lastConnectionInStack = function() {
    var nextConnection = this.nextConnection;
    while (nextConnection) {
        var nextBlock = nextConnection.targetBlock();
        if (!nextBlock) return nextConnection;
        nextConnection = nextBlock.nextConnection
    }
    return null
};
Blockly.Block.prototype.bumpNeighbours_ = function() {
    console.warn("Not expected to reach this bumpNeighbours_ function. The " + "BlockSvg function for bumpNeighbours_ was expected to be called instead.")
};
Blockly.Block.prototype.getParent = function() {
    return this.parentBlock_
};
Blockly.Block.prototype.getInputWithBlock = function(block) {
    for (var i = 0, input; input = this.inputList[i]; i++)
        if (input.connection && input.connection.targetBlock() == block) return input;
    return null
};
Blockly.Block.prototype.getSurroundParent = function() {
    var block = this;
    do {
        var prevBlock = block;
        block = block.getParent();
        if (!block) return null
    } while (block.getNextBlock() == prevBlock);
    return block
};
Blockly.Block.prototype.getNextBlock = function() {
    return this.nextConnection && this.nextConnection.targetBlock()
};
Blockly.Block.prototype.getPreviousBlock = function() {
    return this.previousConnection && this.previousConnection.targetBlock()
};
Blockly.Block.prototype.getFirstStatementConnection = function() {
    for (var i = 0, input; input = this.inputList[i]; i++)
        if (input.connection && input.connection.type == Blockly.NEXT_STATEMENT) return input.connection;
    return null
};
Blockly.Block.prototype.getRootBlock = function() {
    var rootBlock;
    var block = this;
    do {
        rootBlock = block;
        block = rootBlock.parentBlock_
    } while (block);
    return rootBlock
};
Blockly.Block.prototype.getChildren = function(ordered) {
    if (!ordered) return this.childBlocks_;
    var blocks = [];
    for (var i = 0, input; input = this.inputList[i]; i++)
        if (input.connection) {
            var child = input.connection.targetBlock();
            if (child) blocks.push(child)
        } var next = this.getNextBlock();
    if (next) blocks.push(next);
    return blocks
};
Blockly.Block.prototype.setParent = function(newParent) {
    if (newParent == this.parentBlock_) return;
    if (this.parentBlock_) {
        Blockly.utils.arrayRemove(this.parentBlock_.childBlocks_, this);
        if (this.previousConnection && this.previousConnection.isConnected()) throw Error("Still connected to previous block.");
        if (this.outputConnection && this.outputConnection.isConnected()) throw Error("Still connected to parent block.");
        this.parentBlock_ = null
    } else this.workspace.removeTopBlock(this);
    this.parentBlock_ = newParent;
    if (newParent) newParent.childBlocks_.push(this);
    else this.workspace.addTopBlock(this)
};
Blockly.Block.prototype.getDescendants = function(ordered) {
    var blocks = [this];
    var childBlocks = this.getChildren(ordered);
    for (var child, i = 0; child = childBlocks[i]; i++) blocks.push.apply(blocks, child.getDescendants(ordered));
    return blocks
};
Blockly.Block.prototype.isDeletable = function() {
    return this.deletable_ && !this.isShadow_ && !(this.workspace && this.workspace.options.readOnly)
};
Blockly.Block.prototype.setDeletable = function(deletable) {
    this.deletable_ = deletable
};
Blockly.Block.prototype.isMovable = function() {
    return this.movable_ && !this.isShadow_ && !(this.workspace && this.workspace.options.readOnly)
};
Blockly.Block.prototype.setMovable = function(movable) {
    this.movable_ = movable
};
Blockly.Block.prototype.isShadow = function() {
    return this.isShadow_
};
Blockly.Block.prototype.setShadow = function(shadow) {
    this.isShadow_ = shadow
};
Blockly.Block.prototype.isInsertionMarker = function() {
    return this.isInsertionMarker_
};
Blockly.Block.prototype.setInsertionMarker = function(insertionMarker) {
    this.isInsertionMarker_ = insertionMarker
};
Blockly.Block.prototype.isEditable = function() {
    return this.editable_ && !(this.workspace && this.workspace.options.readOnly)
};
Blockly.Block.prototype.setEditable = function(editable) {
    this.editable_ = editable;
    for (var i = 0, input; input = this.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++) field.updateEditable()
};
Blockly.Block.prototype.setConnectionsHidden = function(hidden) {
    if (!hidden && this.isCollapsed()) {
        if (this.outputConnection) this.outputConnection.setHidden(hidden);
        if (this.previousConnection) this.previousConnection.setHidden(hidden);
        if (this.nextConnection) {
            this.nextConnection.setHidden(hidden);
            var child = this.nextConnection.targetBlock();
            if (child) child.setConnectionsHidden(hidden)
        }
    } else {
        var myConnections = this.getConnections_(true);
        for (var i = 0, connection; connection = myConnections[i]; i++) {
            connection.setHidden(hidden);
            if (connection.isSuperior()) {
                var child = connection.targetBlock();
                if (child) child.setConnectionsHidden(hidden)
            }
        }
    }
};
Blockly.Block.prototype.getMatchingConnection = function(otherBlock, conn) {
    var connections = this.getConnections_(true);
    var otherConnections = otherBlock.getConnections_(true);
    if (connections.length != otherConnections.length) throw Error("Connection lists did not match in length.");
    for (var i = 0; i < otherConnections.length; i++)
        if (otherConnections[i] == conn) return connections[i];
    return null
};
Blockly.Block.prototype.setHelpUrl = function(url) {
    this.helpUrl = url
};
Blockly.Block.prototype.setTooltip = function(newTip) {
    this.tooltip = newTip
};
Blockly.Block.prototype.getColour = function() {
    return this.colour_
};
Blockly.Block.prototype.getHue = function() {
    return this.hue_
};
Blockly.Block.prototype.setColour = function(colour) {
    var dereferenced = typeof colour == "string" ? Blockly.utils.replaceMessageReferences(colour) : colour;
    var hue = Number(dereferenced);
    if (!isNaN(hue) && 0 <= hue && hue <= 360) {
        this.hue_ = hue;
        this.colour_ = Blockly.hueToRgb(hue)
    } else if (typeof dereferenced == "string" && /^#[0-9a-fA-F]{6}$/.test(dereferenced)) {
        this.colour_ = dereferenced;
        this.hue_ = null
    } else {
        var errorMsg = 'Invalid colour: "' + dereferenced + '"';
        if (colour != dereferenced) errorMsg += ' (from "' + colour + '")';
        throw errorMsg;
    }
};
Blockly.Block.prototype.setOnChange = function(onchangeFn) {
    if (onchangeFn && typeof onchangeFn != "function") throw Error("onchange must be a function.");
    if (this.onchangeWrapper_) this.workspace.removeChangeListener(this.onchangeWrapper_);
    this.onchange = onchangeFn;
    if (this.onchange) {
        this.onchangeWrapper_ = onchangeFn.bind(this);
        this.workspace.addChangeListener(this.onchangeWrapper_)
    }
};
Blockly.Block.prototype.getField = function(name) {
    for (var i = 0, input; input = this.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++)
            if (field.name === name) return field;
    return null
};
Blockly.Block.prototype.getVars = function() {
    var vars = [];
    for (var i = 0, input; input = this.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++)
            if (field.referencesVariables()) vars.push(field.getValue());
    return vars
};
Blockly.Block.prototype.getVarModels = function() {
    var vars = [];
    for (var i = 0, input; input = this.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++)
            if (field.referencesVariables()) {
                var model = this.workspace.getVariableById(field.getValue());
                if (model) vars.push(model)
            } return vars
};
Blockly.Block.prototype.updateVarName = function(variable) {
    for (var i = 0, input; input = this.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++)
            if (field.referencesVariables() && variable.getId() == field.getValue()) field.setText(variable.name)
};
Blockly.Block.prototype.renameVarById = function(oldId, newId) {
    for (var i = 0, input; input = this.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++)
            if (field.referencesVariables() && oldId == field.getValue()) field.setValue(newId)
};
Blockly.Block.prototype.getFieldValue = function(name) {
    var field = this.getField(name);
    if (field) return field.getValue();
    return null
};
Blockly.Block.prototype.setFieldValue = function(newValue, name) {
    var field = this.getField(name);
    if (!field) throw Error('Field "' + name + '" not found.');
    field.setValue(newValue)
};
Blockly.Block.prototype.setPreviousStatement = function(newBoolean, opt_check) {
    if (newBoolean) {
        if (opt_check === undefined) opt_check = null;
        if (!this.previousConnection) {
            if (this.outputConnection) throw Error("Remove output connection prior to adding previous " + "connection.");
            this.previousConnection = this.makeConnection_(Blockly.PREVIOUS_STATEMENT)
        }
        this.previousConnection.setCheck(opt_check)
    } else if (this.previousConnection) {
        if (this.previousConnection.isConnected()) throw Error("Must disconnect previous statement before removing " + "connection.");
        this.previousConnection.dispose();
        this.previousConnection = null
    }
};
Blockly.Block.prototype.setNextStatement = function(newBoolean, opt_check) {
    if (newBoolean) {
        if (opt_check === undefined) opt_check = null;
        if (!this.nextConnection) this.nextConnection = this.makeConnection_(Blockly.NEXT_STATEMENT);
        this.nextConnection.setCheck(opt_check)
    } else if (this.nextConnection) {
        if (this.nextConnection.isConnected()) throw Error("Must disconnect next statement before removing " + "connection.");
        this.nextConnection.dispose();
        this.nextConnection = null
    }
};
Blockly.Block.prototype.setOutput = function(newBoolean, opt_check) {
    if (newBoolean) {
        if (opt_check === undefined) opt_check = null;
        if (!this.outputConnection) {
            if (this.previousConnection) throw Error("Remove previous connection prior to adding output " + "connection.");
            this.outputConnection = this.makeConnection_(Blockly.OUTPUT_VALUE)
        }
        this.outputConnection.setCheck(opt_check)
    } else if (this.outputConnection) {
        if (this.outputConnection.isConnected()) throw Error("Must disconnect output value before removing connection.");
        this.outputConnection.dispose();
        this.outputConnection = null
    }
};
Blockly.Block.prototype.setInputsInline = function(newBoolean) {
    if (this.inputsInline != newBoolean) {
        Blockly.Events.fire(new Blockly.Events.BlockChange(this, "inline", null, this.inputsInline, newBoolean));
        this.inputsInline = newBoolean
    }
};
Blockly.Block.prototype.getInputsInline = function() {
    if (this.inputsInline != undefined) return this.inputsInline;
    for (var i = 1; i < this.inputList.length; i++)
        if (this.inputList[i - 1].type == Blockly.DUMMY_INPUT && this.inputList[i].type == Blockly.DUMMY_INPUT) return false;
    for (var i = 1; i < this.inputList.length; i++)
        if (this.inputList[i - 1].type == Blockly.INPUT_VALUE && this.inputList[i].type == Blockly.DUMMY_INPUT) return true;
    return false
};
Blockly.Block.prototype.setDisabled = function(disabled) {
    if (this.disabled != disabled) {
        Blockly.Events.fire(new Blockly.Events.BlockChange(this, "disabled", null, this.disabled, disabled));
        this.disabled = disabled
    }
};
Blockly.Block.prototype.getInheritedDisabled = function() {
    var ancestor = this.getSurroundParent();
    while (ancestor) {
        if (ancestor.disabled) return true;
        ancestor = ancestor.getSurroundParent()
    }
    return false
};
Blockly.Block.prototype.isCollapsed = function() {
    return this.collapsed_
};
Blockly.Block.prototype.setCollapsed = function(collapsed) {
    if (this.collapsed_ != collapsed) {
        Blockly.Events.fire(new Blockly.Events.BlockChange(this, "collapsed", null, this.collapsed_, collapsed));
        this.collapsed_ = collapsed
    }
};
Blockly.Block.prototype.toString = function(opt_maxLength, opt_emptyToken) {
    var text = [];
    var emptyFieldPlaceholder = opt_emptyToken || "?";
    if (this.collapsed_) text.push(this.getInput("_TEMP_COLLAPSED_INPUT").fieldRow[0].text_);
    else
        for (var i = 0, input; input = this.inputList[i]; i++) {
            for (var j = 0, field; field = input.fieldRow[j]; j++)
                if (field instanceof Blockly.FieldDropdown && !field.getValue()) text.push(emptyFieldPlaceholder);
                else text.push(field.getText());
            if (input.connection) {
                var child = input.connection.targetBlock();
                if (child) text.push(child.toString(undefined, opt_emptyToken));
                else text.push(emptyFieldPlaceholder)
            }
        }
    text = text.join(" ").trim() || "???";
    if (opt_maxLength)
        if (text.length > opt_maxLength) text = text.substring(0, opt_maxLength - 3) + "...";
    return text
};
Blockly.Block.prototype.appendValueInput = function(name) {
    return this.appendInput_(Blockly.INPUT_VALUE, name)
};
Blockly.Block.prototype.appendStatementInput = function(name) {
    return this.appendInput_(Blockly.NEXT_STATEMENT, name)
};
Blockly.Block.prototype.appendDummyInput = function(opt_name) {
    return this.appendInput_(Blockly.DUMMY_INPUT, opt_name || "")
};
Blockly.Block.prototype.jsonInit = function(json) {
    var warningPrefix = json["type"] ? 'Block "' + json["type"] + '": ' : "";
    if (json["output"] && json["previousStatement"]) throw Error(warningPrefix + "Must not have both an output and a previousStatement.");
    this.jsonInitColour_(json, warningPrefix);
    var i = 0;
    while (json["message" + i] !== undefined) {
        this.interpolate_(json["message" + i], json["args" + i] || [], json["lastDummyAlign" + i]);
        i++
    }
    if (json["inputsInline"] !== undefined) this.setInputsInline(json["inputsInline"]);
    if (json["output"] !==
        undefined) this.setOutput(true, json["output"]);
    if (json["previousStatement"] !== undefined) this.setPreviousStatement(true, json["previousStatement"]);
    if (json["nextStatement"] !== undefined) this.setNextStatement(true, json["nextStatement"]);
    if (json["tooltip"] !== undefined) {
        var rawValue = json["tooltip"];
        var localizedText = Blockly.utils.replaceMessageReferences(rawValue);
        this.setTooltip(localizedText)
    }
    if (json["enableContextMenu"] !== undefined) {
        var rawValue = json["enableContextMenu"];
        this.contextMenu = !!rawValue
    }
    if (json["helpUrl"] !==
        undefined) {
        var rawValue = json["helpUrl"];
        var localizedValue = Blockly.utils.replaceMessageReferences(rawValue);
        this.setHelpUrl(localizedValue)
    }
    if (typeof json["extensions"] == "string") {
        console.warn(warningPrefix + "JSON attribute 'extensions' should be an array of" + " strings. Found raw string in JSON for '" + json["type"] + "' block.");
        json["extensions"] = [json["extensions"]]
    }
    if (json["mutator"] !== undefined) Blockly.Extensions.apply(json["mutator"], this, true);
    if (Array.isArray(json["extensions"])) {
        var extensionNames =
            json["extensions"];
        for (var j = 0; j < extensionNames.length; ++j) {
            var extensionName = extensionNames[j];
            Blockly.Extensions.apply(extensionName, this, false)
        }
    }
};
Blockly.Block.prototype.jsonInitColour_ = function(json, warningPrefix) {
    if ("colour" in json)
        if (json["colour"] === undefined) console.warn(warningPrefix + "Undefined color value.");
        else {
            var rawValue = json["colour"];
            try {
                this.setColour(rawValue)
            } catch (colorError) {
                console.warn(warningPrefix + "Illegal color value: ", rawValue)
            }
        }
};
Blockly.Block.prototype.mixin = function(mixinObj, opt_disableCheck) {
    if (opt_disableCheck !== undefined && typeof opt_disableCheck != "boolean") throw Error("opt_disableCheck must be a boolean if provided");
    if (!opt_disableCheck) {
        var overwrites = [];
        for (var key in mixinObj)
            if (this[key] !== undefined) overwrites.push(key);
        if (overwrites.length) throw Error("Mixin will overwrite block members: " + JSON.stringify(overwrites));
    }
    goog.mixin(this, mixinObj)
};
Blockly.Block.prototype.interpolate_ = function(message, args, lastDummyAlign) {
    var tokens = Blockly.utils.tokenizeInterpolation(message);
    var indexDup = [];
    var indexCount = 0;
    var elements = [];
    for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];
        if (typeof token == "number") {
            if (token <= 0 || token > args.length) throw Error('Block "' + this.type + '": ' + "Message index %" + token + " out of range.");
            if (indexDup[token]) throw Error('Block "' + this.type + '": ' + "Message index %" + token + " duplicated.");
            indexDup[token] = true;
            indexCount++;
            elements.push(args[token - 1])
        } else {
            token = token.trim();
            if (token) elements.push(token)
        }
    }
    if (indexCount != args.length) throw Error('Block "' + this.type + '": ' + "Message does not reference all " + args.length + " arg(s).");
    if (elements.length && (typeof elements[elements.length - 1] == "string" || Blockly.utils.startsWith(elements[elements.length - 1]["type"], "field_"))) {
        var dummyInput = {
            type: "input_dummy"
        };
        if (lastDummyAlign) dummyInput["align"] = lastDummyAlign;
        elements.push(dummyInput)
    }
    var alignmentLookup = {
        "LEFT": Blockly.ALIGN_LEFT,
        "RIGHT": Blockly.ALIGN_RIGHT,
        "CENTRE": Blockly.ALIGN_CENTRE
    };
    var fieldStack = [];
    for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        if (typeof element == "string") fieldStack.push([element, undefined]);
        else {
            var field = null;
            var input = null;
            do {
                var altRepeat = false;
                if (typeof element == "string") field = new Blockly.FieldLabel(element);
                else switch (element["type"]) {
                    case "input_value":
                        input = this.appendValueInput(element["name"]);
                        break;
                    case "input_statement":
                        input = this.appendStatementInput(element["name"]);
                        break;
                    case "input_dummy":
                        input = this.appendDummyInput(element["name"]);
                        break;
                    default:
                        field = Blockly.Field.fromJson(element);
                        if (!field)
                            if (element["alt"]) {
                                element = element["alt"];
                                altRepeat = true
                            } else console.warn("Blockly could not create a field of type " + element["type"] + ". You may need to register your custom field.  See " + "github.com/google/blockly/issues/1584")
                }
            } while (altRepeat);
            if (field) fieldStack.push([field, element["name"]]);
            else if (input) {
                if (element["check"]) input.setCheck(element["check"]);
                if (element["align"]) input.setAlign(alignmentLookup[element["align"]]);
                for (var j = 0; j < fieldStack.length; j++) input.appendField(fieldStack[j][0], fieldStack[j][1]);
                fieldStack.length = 0
            }
        }
    }
};
Blockly.Block.prototype.appendInput_ = function(type, name) {
    var connection = null;
    if (type == Blockly.INPUT_VALUE || type == Blockly.NEXT_STATEMENT) connection = this.makeConnection_(type);
    var input = new Blockly.Input(type, name, this, connection);
    this.inputList.push(input);
    return input
};
Blockly.Block.prototype.moveInputBefore = function(name, refName) {
    if (name == refName) return;
    var inputIndex = -1;
    var refIndex = refName ? -1 : this.inputList.length;
    for (var i = 0, input; input = this.inputList[i]; i++)
        if (input.name == name) {
            inputIndex = i;
            if (refIndex != -1) break
        } else if (refName && input.name == refName) {
        refIndex = i;
        if (inputIndex != -1) break
    }
    if (inputIndex == -1) throw Error('Named input "' + name + '" not found.');
    if (refIndex == -1) throw Error('Reference input "' + refName + '" not found.');
    this.moveNumberedInputBefore(inputIndex,
        refIndex)
};
Blockly.Block.prototype.moveNumberedInputBefore = function(inputIndex, refIndex) {
    if (inputIndex == refIndex) throw Error("Can't move input to itself.");
    if (inputIndex >= this.inputList.length) throw RangeError("Input index " + inputIndex + " out of bounds.");
    if (refIndex > this.inputList.length) throw RangeError("Reference input " + refIndex + " out of bounds.");
    var input = this.inputList[inputIndex];
    this.inputList.splice(inputIndex, 1);
    if (inputIndex < refIndex) refIndex--;
    this.inputList.splice(refIndex, 0, input)
};
Blockly.Block.prototype.removeInput = function(name, opt_quiet) {
    for (var i = 0, input; input = this.inputList[i]; i++)
        if (input.name == name) {
            if (input.connection && input.connection.isConnected()) {
                input.connection.setShadowDom(null);
                var block = input.connection.targetBlock();
                if (block.isShadow()) block.dispose();
                else block.unplug()
            }
            input.dispose();
            this.inputList.splice(i, 1);
            return
        } if (!opt_quiet) throw Error("Input not found: " + name);
};
Blockly.Block.prototype.getInput = function(name) {
    for (var i = 0, input; input = this.inputList[i]; i++)
        if (input.name == name) return input;
    return null
};
Blockly.Block.prototype.getInputTargetBlock = function(name) {
    var input = this.getInput(name);
    return input && input.connection && input.connection.targetBlock()
};
Blockly.Block.prototype.getCommentText = function() {
    return this.comment || ""
};
Blockly.Block.prototype.setCommentText = function(text) {
    if (this.comment != text) {
        Blockly.Events.fire(new Blockly.Events.BlockChange(this, "comment", null, this.comment, text || ""));
        this.comment = text
    }
};
Blockly.Block.prototype.setWarningText = function(_text, _opt_id) {};
Blockly.Block.prototype.setMutator = function(_mutator) {};
Blockly.Block.prototype.getRelativeToSurfaceXY = function() {
    return this.xy_
};
Blockly.Block.prototype.moveBy = function(dx, dy) {
    if (this.parentBlock_) throw Error("Block has parent.");
    var event = new Blockly.Events.BlockMove(this);
    this.xy_.translate(dx, dy);
    event.recordNew();
    Blockly.Events.fire(event)
};
Blockly.Block.prototype.makeConnection_ = function(type) {
    return new Blockly.Connection(this, type)
};
Blockly.Block.prototype.allInputsFilled = function(opt_shadowBlocksAreFilled) {
    if (opt_shadowBlocksAreFilled === undefined) opt_shadowBlocksAreFilled = true;
    if (!opt_shadowBlocksAreFilled && this.isShadow()) return false;
    for (var i = 0, input; input = this.inputList[i]; i++) {
        if (!input.connection) continue;
        var target = input.connection.targetBlock();
        if (!target || !target.allInputsFilled(opt_shadowBlocksAreFilled)) return false
    }
    var next = this.getNextBlock();
    if (next) return next.allInputsFilled(opt_shadowBlocksAreFilled);
    return true
};
Blockly.Block.prototype.toDevString = function() {
    var msg = this.type ? '"' + this.type + '" block' : "Block";
    if (this.id) msg += ' (id="' + this.id + '")';
    return msg
};
goog.provide("Blockly.BlockAnimations");
goog.require("Blockly.utils");
Blockly.BlockAnimations.disconnectPid_ = 0;
Blockly.BlockAnimations.disconnectGroup_ = null;
Blockly.BlockAnimations.disposeUiEffect = function(block) {
    var workspace = block.workspace;
    var svgGroup = block.getSvgRoot();
    workspace.getAudioManager().play("delete");
    var xy = workspace.getSvgXY(svgGroup);
    var clone = svgGroup.cloneNode(true);
    clone.translateX_ = xy.x;
    clone.translateY_ = xy.y;
    clone.setAttribute("transform", "translate(" + xy.x + "," + xy.y + ")");
    workspace.getParentSvg().appendChild(clone);
    clone.bBox_ = clone.getBBox();
    Blockly.BlockAnimations.disposeUiStep_(clone, workspace.RTL, new Date, workspace.scale)
};
Blockly.BlockAnimations.disposeUiStep_ = function(clone, rtl, start, workspaceScale) {
    var ms = new Date - start;
    var percent = ms / 150;
    if (percent > 1) Blockly.utils.removeNode(clone);
    else {
        var x = clone.translateX_ + (rtl ? -1 : 1) * clone.bBox_.width * workspaceScale / 2 * percent;
        var y = clone.translateY_ + clone.bBox_.height * workspaceScale * percent;
        var scale = (1 - percent) * workspaceScale;
        clone.setAttribute("transform", "translate(" + x + "," + y + ")" + " scale(" + scale + ")");
        setTimeout(Blockly.BlockAnimations.disposeUiStep_, 10, clone, rtl, start, workspaceScale)
    }
};
Blockly.BlockAnimations.connectionUiEffect = function(block) {
    var workspace = block.workspace;
    var scale = workspace.scale;
    workspace.getAudioManager().play("click");
    if (scale < 1) return;
    var xy = workspace.getSvgXY(block.getSvgRoot());
    if (block.outputConnection) {
        xy.x += (block.RTL ? 3 : -3) * scale;
        xy.y += 13 * scale
    } else if (block.previousConnection) {
        xy.x += (block.RTL ? -23 : 23) * scale;
        xy.y += 3 * scale
    }
    var ripple = Blockly.utils.createSvgElement("circle", {
        "cx": xy.x,
        "cy": xy.y,
        "r": 0,
        "fill": "none",
        "stroke": "#888",
        "stroke-width": 10
    }, workspace.getParentSvg());
    Blockly.BlockAnimations.connectionUiStep_(ripple, new Date, scale)
};
Blockly.BlockAnimations.connectionUiStep_ = function(ripple, start, scale) {
    var ms = new Date - start;
    var percent = ms / 150;
    if (percent > 1) Blockly.utils.removeNode(ripple);
    else {
        ripple.setAttribute("r", percent * 25 * scale);
        ripple.style.opacity = 1 - percent;
        Blockly.BlockAnimations.disconnectPid_ = setTimeout(Blockly.BlockAnimations.connectionUiStep_, 10, ripple, start, scale)
    }
};
Blockly.BlockAnimations.disconnectUiEffect = function(block) {
    block.workspace.getAudioManager().play("disconnect");
    if (block.workspace.scale < 1) return;
    var DISPLACEMENT = 10;
    var height = block.getHeightWidth().height;
    var magnitude = Math.atan(DISPLACEMENT / height) / Math.PI * 180;
    if (!block.RTL) magnitude *= -1;
    Blockly.BlockAnimations.disconnectUiStep_(block.getSvgRoot(), magnitude, new Date)
};
Blockly.BlockAnimations.disconnectUiStep_ = function(group, magnitude, start) {
    var DURATION = 200;
    var WIGGLES = 3;
    var ms = new Date - start;
    var percent = ms / DURATION;
    if (percent > 1) group.skew_ = "";
    else {
        var skew = Math.round(Math.sin(percent * Math.PI * WIGGLES) * (1 - percent) * magnitude);
        group.skew_ = "skewX(" + skew + ")";
        Blockly.BlockAnimations.disconnectGroup_ = group;
        Blockly.BlockAnimations.disconnectPid_ = setTimeout(Blockly.BlockAnimations.disconnectUiStep_, 10, group, magnitude, start)
    }
    group.setAttribute("transform", group.translate_ +
        group.skew_)
};
Blockly.BlockAnimations.disconnectUiStop = function() {
    if (Blockly.BlockAnimations.disconnectGroup_) {
        clearTimeout(Blockly.BlockAnimations.disconnectPid_);
        var group = Blockly.BlockAnimations.disconnectGroup_;
        group.skew_ = "";
        group.setAttribute("transform", group.translate_);
        Blockly.BlockAnimations.disconnectGroup_ = null
    }
};
goog.provide("Blockly.BlockDragSurfaceSvg");
goog.require("Blockly.utils");
goog.require("goog.math.Coordinate");
Blockly.BlockDragSurfaceSvg = function(container) {
    this.container_ = container;
    this.createDom()
};
Blockly.BlockDragSurfaceSvg.prototype.SVG_ = null;
Blockly.BlockDragSurfaceSvg.prototype.dragGroup_ = null;
Blockly.BlockDragSurfaceSvg.prototype.container_ = null;
Blockly.BlockDragSurfaceSvg.prototype.scale_ = 1;
Blockly.BlockDragSurfaceSvg.prototype.surfaceXY_ = null;
Blockly.BlockDragSurfaceSvg.prototype.createDom = function() {
    if (this.SVG_) return;
    this.SVG_ = Blockly.utils.createSvgElement("svg", {
        "xmlns": Blockly.SVG_NS,
        "xmlns:html": Blockly.HTML_NS,
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "version": "1.1",
        "class": "blocklyBlockDragSurface"
    }, this.container_);
    this.dragGroup_ = Blockly.utils.createSvgElement("g", {}, this.SVG_)
};
Blockly.BlockDragSurfaceSvg.prototype.setBlocksAndShow = function(blocks) {
    if (this.dragGroup_.childNodes.length) throw Error("Already dragging a block.");
    this.dragGroup_.appendChild(blocks);
    this.SVG_.style.display = "block";
    this.surfaceXY_ = new goog.math.Coordinate(0, 0)
};
Blockly.BlockDragSurfaceSvg.prototype.translateAndScaleGroup = function(x, y, scale) {
    this.scale_ = scale;
    var fixedX = x.toFixed(0);
    var fixedY = y.toFixed(0);
    this.dragGroup_.setAttribute("transform", "translate(" + fixedX + "," + fixedY + ") scale(" + scale + ")")
};
Blockly.BlockDragSurfaceSvg.prototype.translateSurfaceInternal_ = function() {
    var x = this.surfaceXY_.x;
    var y = this.surfaceXY_.y;
    x = x.toFixed(0);
    y = y.toFixed(0);
    this.SVG_.style.display = "block";
    Blockly.utils.setCssTransform(this.SVG_, "translate3d(" + x + "px, " + y + "px, 0px)")
};
Blockly.BlockDragSurfaceSvg.prototype.translateSurface = function(x, y) {
    this.surfaceXY_ = new goog.math.Coordinate(x * this.scale_, y * this.scale_);
    this.translateSurfaceInternal_()
};
Blockly.BlockDragSurfaceSvg.prototype.getSurfaceTranslation = function() {
    var xy = Blockly.utils.getRelativeXY(this.SVG_);
    return new goog.math.Coordinate(xy.x / this.scale_, xy.y / this.scale_)
};
Blockly.BlockDragSurfaceSvg.prototype.getGroup = function() {
    return this.dragGroup_
};
Blockly.BlockDragSurfaceSvg.prototype.getCurrentBlock = function() {
    return this.dragGroup_.firstChild
};
Blockly.BlockDragSurfaceSvg.prototype.clearAndHide = function(opt_newSurface) {
    if (opt_newSurface) opt_newSurface.appendChild(this.getCurrentBlock());
    else this.dragGroup_.removeChild(this.getCurrentBlock());
    this.SVG_.style.display = "none";
    if (this.dragGroup_.childNodes.length) throw Error("Drag group was not cleared.");
    this.surfaceXY_ = null
};
goog.provide("Blockly.BlockDragger");
goog.require("Blockly.BlockAnimations");
goog.require("Blockly.DraggedConnectionManager");
goog.require("Blockly.Events.BlockMove");
goog.require("goog.math.Coordinate");
Blockly.BlockDragger = function(block, workspace) {
    this.draggingBlock_ = block;
    this.workspace_ = workspace;
    this.draggedConnectionManager_ = new Blockly.DraggedConnectionManager(this.draggingBlock_);
    this.deleteArea_ = null;
    this.wouldDeleteBlock_ = false;
    this.startXY_ = this.draggingBlock_.getRelativeToSurfaceXY();
    this.dragIconData_ = Blockly.BlockDragger.initIconData_(block)
};
Blockly.BlockDragger.prototype.dispose = function() {
    this.draggingBlock_ = null;
    this.workspace_ = null;
    this.startWorkspace_ = null;
    this.dragIconData_.length = 0;
    if (this.draggedConnectionManager_) {
        this.draggedConnectionManager_.dispose();
        this.draggedConnectionManager_ = null
    }
};
Blockly.BlockDragger.initIconData_ = function(block) {
    var dragIconData = [];
    var descendants = block.getDescendants(false);
    for (var i = 0, descendant; descendant = descendants[i]; i++) {
        var icons = descendant.getIcons();
        for (var j = 0; j < icons.length; j++) {
            var data = {
                location: icons[j].getIconLocation(),
                icon: icons[j]
            };
            dragIconData.push(data)
        }
    }
    return dragIconData
};
Blockly.BlockDragger.prototype.startBlockDrag = function(currentDragDeltaXY, healStack) {
    if (!Blockly.Events.getGroup()) Blockly.Events.setGroup(true);
    if (this.workspace_.isMutator) this.draggingBlock_.bringToFront();
    this.workspace_.setResizesEnabled(false);
    Blockly.BlockAnimations.disconnectUiStop();
    if (this.draggingBlock_.getParent() || healStack && this.draggingBlock_.nextConnection && this.draggingBlock_.nextConnection.targetBlock()) {
        this.draggingBlock_.unplug(healStack);
        var delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);
        var newLoc = goog.math.Coordinate.sum(this.startXY_, delta);
        this.draggingBlock_.translate(newLoc.x, newLoc.y);
        Blockly.BlockAnimations.disconnectUiEffect(this.draggingBlock_)
    }
    this.draggingBlock_.setDragging(true);
    this.draggingBlock_.moveToDragSurface_();
    var toolbox = this.workspace_.getToolbox();
    if (toolbox) {
        var style = this.draggingBlock_.isDeletable() ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
        toolbox.addStyle(style)
    }
};
Blockly.BlockDragger.prototype.dragBlock = function(e, currentDragDeltaXY) {
    var delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);
    var newLoc = goog.math.Coordinate.sum(this.startXY_, delta);
    this.draggingBlock_.moveDuringDrag(newLoc);
    this.dragIcons_(delta);
    this.deleteArea_ = this.workspace_.isDeleteArea(e);
    this.draggedConnectionManager_.update(delta, this.deleteArea_);
    this.updateCursorDuringBlockDrag_()
};
Blockly.BlockDragger.prototype.endBlockDrag = function(e, currentDragDeltaXY) {
    this.dragBlock(e, currentDragDeltaXY);
    this.dragIconData_ = [];
    Blockly.BlockAnimations.disconnectUiStop();
    var delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);
    var newLoc = goog.math.Coordinate.sum(this.startXY_, delta);
    this.draggingBlock_.moveOffDragSurface_(newLoc);
    var deleted = this.maybeDeleteBlock_();
    if (!deleted) {
        this.draggingBlock_.moveConnections_(delta.x, delta.y);
        this.draggingBlock_.setDragging(false);
        this.fireMoveEvent_();
        if (this.draggedConnectionManager_.wouldConnectBlock()) this.draggedConnectionManager_.applyConnections();
        else this.draggingBlock_.render();
        this.draggingBlock_.scheduleSnapAndBump()
    }
    this.workspace_.setResizesEnabled(true);
    var toolbox = this.workspace_.getToolbox();
    if (toolbox) {
        var style = this.draggingBlock_.isDeletable() ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
        toolbox.removeStyle(style)
    }
    Blockly.Events.setGroup(false)
};
Blockly.BlockDragger.prototype.fireMoveEvent_ = function() {
    var event = new Blockly.Events.BlockMove(this.draggingBlock_);
    event.oldCoordinate = this.startXY_;
    event.recordNew();
    Blockly.Events.fire(event)
};
Blockly.BlockDragger.prototype.maybeDeleteBlock_ = function() {
    var trashcan = this.workspace_.trashcan;
    if (this.wouldDeleteBlock_) {
        if (trashcan) setTimeout(trashcan.close.bind(trashcan), 100);
        this.fireMoveEvent_();
        this.draggingBlock_.dispose(false, true)
    } else if (trashcan) trashcan.close();
    return this.wouldDeleteBlock_
};
Blockly.BlockDragger.prototype.updateCursorDuringBlockDrag_ = function() {
    this.wouldDeleteBlock_ = this.draggedConnectionManager_.wouldDeleteBlock();
    var trashcan = this.workspace_.trashcan;
    if (this.wouldDeleteBlock_) {
        this.draggingBlock_.setDeleteStyle(true);
        if (this.deleteArea_ == Blockly.DELETE_AREA_TRASH && trashcan) trashcan.setOpen_(true)
    } else {
        this.draggingBlock_.setDeleteStyle(false);
        if (trashcan) trashcan.setOpen_(false)
    }
};
Blockly.BlockDragger.prototype.pixelsToWorkspaceUnits_ = function(pixelCoord) {
    var result = new goog.math.Coordinate(pixelCoord.x / this.workspace_.scale, pixelCoord.y / this.workspace_.scale);
    if (this.workspace_.isMutator) {
        var mainScale = this.workspace_.options.parentWorkspace.scale;
        result = result.scale(1 / mainScale)
    }
    return result
};
Blockly.BlockDragger.prototype.dragIcons_ = function(dxy) {
    for (var i = 0; i < this.dragIconData_.length; i++) {
        var data = this.dragIconData_[i];
        data.icon.setIconLocation(goog.math.Coordinate.sum(data.location, dxy))
    }
};
goog.provide("Blockly.Events.BlockBase");
goog.provide("Blockly.Events.BlockChange");
goog.provide("Blockly.Events.BlockCreate");
goog.provide("Blockly.Events.BlockDelete");
goog.provide("Blockly.Events.BlockMove");
goog.provide("Blockly.Events.Change");
goog.provide("Blockly.Events.Create");
goog.provide("Blockly.Events.Delete");
goog.provide("Blockly.Events.Move");
goog.require("Blockly.Events");
goog.require("Blockly.Events.Abstract");
goog.require("Blockly.Xml.utils");
goog.require("goog.math.Coordinate");
Blockly.Events.BlockBase = function(block) {
    Blockly.Events.BlockBase.superClass_.constructor.call(this);
    this.blockId = block.id;
    this.workspaceId = block.workspace.id
};
goog.inherits(Blockly.Events.BlockBase, Blockly.Events.Abstract);
Blockly.Events.BlockBase.prototype.toJson = function() {
    var json = Blockly.Events.BlockBase.superClass_.toJson.call(this);
    json["blockId"] = this.blockId;
    return json
};
Blockly.Events.BlockBase.prototype.fromJson = function(json) {
    Blockly.Events.BlockBase.superClass_.toJson.call(this);
    this.blockId = json["blockId"]
};
Blockly.Events.Change = function(block, element, name, oldValue, newValue) {
    if (!block) return;
    Blockly.Events.Change.superClass_.constructor.call(this, block);
    this.element = element;
    this.name = name;
    this.oldValue = oldValue;
    this.newValue = newValue
};
goog.inherits(Blockly.Events.Change, Blockly.Events.BlockBase);
Blockly.Events.BlockChange = Blockly.Events.Change;
Blockly.Events.Change.prototype.type = Blockly.Events.CHANGE;
Blockly.Events.Change.prototype.toJson = function() {
    var json = Blockly.Events.Change.superClass_.toJson.call(this);
    json["element"] = this.element;
    if (this.name) json["name"] = this.name;
    json["newValue"] = this.newValue;
    return json
};
Blockly.Events.Change.prototype.fromJson = function(json) {
    Blockly.Events.Change.superClass_.fromJson.call(this, json);
    this.element = json["element"];
    this.name = json["name"];
    this.newValue = json["newValue"]
};
Blockly.Events.Change.prototype.isNull = function() {
    return this.oldValue == this.newValue
};
Blockly.Events.Change.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    var block = workspace.getBlockById(this.blockId);
    if (!block) {
        console.warn("Can't change non-existent block: " + this.blockId);
        return
    }
    if (block.mutator) block.mutator.setVisible(false);
    var value = forward ? this.newValue : this.oldValue;
    switch (this.element) {
        case "field":
            var field = block.getField(this.name);
            if (field) {
                field.callValidator(value);
                field.setValue(value)
            } else console.warn("Can't set non-existent field: " + this.name);
            break;
        case "comment":
            block.setCommentText(value || null);
            break;
        case "collapsed":
            block.setCollapsed(value);
            break;
        case "disabled":
            block.setDisabled(value);
            break;
        case "inline":
            block.setInputsInline(value);
            break;
        case "mutation":
            var oldMutation = "";
            if (block.mutationToDom) {
                var oldMutationDom = block.mutationToDom();
                oldMutation = oldMutationDom && Blockly.Xml.domToText(oldMutationDom)
            }
            if (block.domToMutation) {
                value = value || "<mutation></mutation>";
                var dom = Blockly.Xml.textToDom("<xml>" + value + "</xml>");
                block.domToMutation(dom.firstChild)
            }
            Blockly.Events.fire(new Blockly.Events.Change(block,
                "mutation", null, oldMutation, value));
            break;
        default:
            console.warn("Unknown change type: " + this.element)
    }
};
Blockly.Events.Create = function(block) {
    if (!block) return;
    Blockly.Events.Create.superClass_.constructor.call(this, block);
    if (block.workspace.rendered) this.xml = Blockly.Xml.blockToDomWithXY(block);
    else this.xml = Blockly.Xml.blockToDom(block);
    this.ids = Blockly.Events.getDescendantIds_(block)
};
goog.inherits(Blockly.Events.Create, Blockly.Events.BlockBase);
Blockly.Events.BlockCreate = Blockly.Events.Create;
Blockly.Events.Create.prototype.type = Blockly.Events.CREATE;
Blockly.Events.Create.prototype.toJson = function() {
    var json = Blockly.Events.Create.superClass_.toJson.call(this);
    json["xml"] = Blockly.Xml.domToText(this.xml);
    json["ids"] = this.ids;
    return json
};
Blockly.Events.Create.prototype.fromJson = function(json) {
    Blockly.Events.Create.superClass_.fromJson.call(this, json);
    this.xml = Blockly.Xml.textToDom("<xml>" + json["xml"] + "</xml>").firstChild;
    this.ids = json["ids"]
};
Blockly.Events.Create.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    if (forward) {
        var xml = Blockly.Xml.utils.createElement("xml");
        xml.appendChild(this.xml);
        Blockly.Xml.domToWorkspace(xml, workspace)
    } else
        for (var i = 0, id; id = this.ids[i]; i++) {
            var block = workspace.getBlockById(id);
            if (block) block.dispose(false, false);
            else if (id == this.blockId) console.warn("Can't uncreate non-existent block: " + id)
        }
};
Blockly.Events.Delete = function(block) {
    if (!block) return;
    if (block.getParent()) throw Error("Connected blocks cannot be deleted.");
    Blockly.Events.Delete.superClass_.constructor.call(this, block);
    if (block.workspace.rendered) this.oldXml = Blockly.Xml.blockToDomWithXY(block);
    else this.oldXml = Blockly.Xml.blockToDom(block);
    this.ids = Blockly.Events.getDescendantIds_(block)
};
goog.inherits(Blockly.Events.Delete, Blockly.Events.BlockBase);
Blockly.Events.BlockDelete = Blockly.Events.Delete;
Blockly.Events.Delete.prototype.type = Blockly.Events.DELETE;
Blockly.Events.Delete.prototype.toJson = function() {
    var json = Blockly.Events.Delete.superClass_.toJson.call(this);
    json["ids"] = this.ids;
    return json
};
Blockly.Events.Delete.prototype.fromJson = function(json) {
    Blockly.Events.Delete.superClass_.fromJson.call(this, json);
    this.ids = json["ids"]
};
Blockly.Events.Delete.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    if (forward)
        for (var i = 0, id; id = this.ids[i]; i++) {
            var block = workspace.getBlockById(id);
            if (block) block.dispose(false, false);
            else if (id == this.blockId) console.warn("Can't delete non-existent block: " + id)
        } else {
            var xml = Blockly.Xml.utils.createElement("xml");
            xml.appendChild(this.oldXml);
            Blockly.Xml.domToWorkspace(xml, workspace)
        }
};
Blockly.Events.Move = function(block) {
    if (!block) return;
    Blockly.Events.Move.superClass_.constructor.call(this, block);
    var location = this.currentLocation_();
    this.oldParentId = location.parentId;
    this.oldInputName = location.inputName;
    this.oldCoordinate = location.coordinate
};
goog.inherits(Blockly.Events.Move, Blockly.Events.BlockBase);
Blockly.Events.BlockMove = Blockly.Events.Move;
Blockly.Events.Move.prototype.type = Blockly.Events.MOVE;
Blockly.Events.Move.prototype.toJson = function() {
    var json = Blockly.Events.Move.superClass_.toJson.call(this);
    if (this.newParentId) json["newParentId"] = this.newParentId;
    if (this.newInputName) json["newInputName"] = this.newInputName;
    if (this.newCoordinate) json["newCoordinate"] = Math.round(this.newCoordinate.x) + "," + Math.round(this.newCoordinate.y);
    return json
};
Blockly.Events.Move.prototype.fromJson = function(json) {
    Blockly.Events.Move.superClass_.fromJson.call(this, json);
    this.newParentId = json["newParentId"];
    this.newInputName = json["newInputName"];
    if (json["newCoordinate"]) {
        var xy = json["newCoordinate"].split(",");
        this.newCoordinate = new goog.math.Coordinate(parseFloat(xy[0]), parseFloat(xy[1]))
    }
};
Blockly.Events.Move.prototype.recordNew = function() {
    var location = this.currentLocation_();
    this.newParentId = location.parentId;
    this.newInputName = location.inputName;
    this.newCoordinate = location.coordinate
};
Blockly.Events.Move.prototype.currentLocation_ = function() {
    var workspace = Blockly.Workspace.getById(this.workspaceId);
    var block = workspace.getBlockById(this.blockId);
    var location = {};
    var parent = block.getParent();
    if (parent) {
        location.parentId = parent.id;
        var input = parent.getInputWithBlock(block);
        if (input) location.inputName = input.name
    } else location.coordinate = block.getRelativeToSurfaceXY();
    return location
};
Blockly.Events.Move.prototype.isNull = function() {
    return this.oldParentId == this.newParentId && this.oldInputName == this.newInputName && goog.math.Coordinate.equals(this.oldCoordinate, this.newCoordinate)
};
Blockly.Events.Move.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    var block = workspace.getBlockById(this.blockId);
    if (!block) {
        console.warn("Can't move non-existent block: " + this.blockId);
        return
    }
    var parentId = forward ? this.newParentId : this.oldParentId;
    var inputName = forward ? this.newInputName : this.oldInputName;
    var coordinate = forward ? this.newCoordinate : this.oldCoordinate;
    var parentBlock = null;
    if (parentId) {
        parentBlock = workspace.getBlockById(parentId);
        if (!parentBlock) {
            console.warn("Can't connect to non-existent block: " +
                parentId);
            return
        }
    }
    if (block.getParent()) block.unplug();
    if (coordinate) {
        var xy = block.getRelativeToSurfaceXY();
        block.moveBy(coordinate.x - xy.x, coordinate.y - xy.y)
    } else {
        var blockConnection = block.outputConnection || block.previousConnection;
        var parentConnection;
        if (inputName) {
            var input = parentBlock.getInput(inputName);
            if (input) parentConnection = input.connection
        } else if (blockConnection.type == Blockly.PREVIOUS_STATEMENT) parentConnection = parentBlock.nextConnection;
        if (parentConnection) blockConnection.connect(parentConnection);
        else console.warn("Can't connect to non-existent input: " + inputName)
    }
};
goog.provide("Blockly.BlockSvg.render");
goog.require("Blockly.BlockSvg");
Blockly.BlockSvg.PathObject = function() {
    this.steps = [];
    this.highlightSteps = [];
    this.inlineSteps = [];
    this.highlightInlineSteps = []
};
Blockly.BlockSvg.SEP_SPACE_X = 10;
Blockly.BlockSvg.SEP_SPACE_Y = 10;
Blockly.BlockSvg.INLINE_PADDING_Y = 7.5;
Blockly.BlockSvg.MIN_BLOCK_Y = 30;
Blockly.BlockSvg.TAB_HEIGHT = 22.5;
Blockly.BlockSvg.TAB_WIDTH = 8;
Blockly.BlockSvg.NOTCH_WIDTH = 30;
Blockly.BlockSvg.CORNER_RADIUS = 8;
Blockly.BlockSvg.START_HAT = false;
Blockly.BlockSvg.START_HAT_HEIGHT = 15;
Blockly.BlockSvg.START_HAT_PATH = "c 30,-" + Blockly.BlockSvg.START_HAT_HEIGHT + " 70,-" + Blockly.BlockSvg.START_HAT_HEIGHT + " 100,0";
Blockly.BlockSvg.START_HAT_HIGHLIGHT_LTR = "c 17.8,-9.2 45.3,-14.9 75,-8.7 M 100.5,0.5";
Blockly.BlockSvg.START_HAT_HIGHLIGHT_RTL = "m 25,-8.7 c 29.7,-6.2 57.2,-0.5 75,8.7";
Blockly.BlockSvg.DISTANCE_45_INSIDE = (1 - Math.SQRT1_2) * (Blockly.BlockSvg.CORNER_RADIUS - .5) + .5;
Blockly.BlockSvg.DISTANCE_45_OUTSIDE = (1 - Math.SQRT1_2) * (Blockly.BlockSvg.CORNER_RADIUS + .5) - .5;
Blockly.BlockSvg.NOTCH_PATH_LEFT = "l 7,4 2,0 7,-4";
Blockly.BlockSvg.NOTCH_PATH_LEFT_HIGHLIGHT = "l 7,4 2,0 7,-4";
Blockly.BlockSvg.NOTCH_PATH_RIGHT = "l -7,4 -2,0 -7,-4";
Blockly.BlockSvg.JAGGED_TEETH = "l 8,0 0,4 8,4 -16,8 8,4";
Blockly.BlockSvg.JAGGED_TEETH_HEIGHT = 20;
Blockly.BlockSvg.JAGGED_TEETH_WIDTH = 15;
Blockly.BlockSvg.TAB_PATH_DOWN = "v 7.5 c 0,10 -" + Blockly.BlockSvg.TAB_WIDTH + ",-8 -" + Blockly.BlockSvg.TAB_WIDTH + ",7.5 s " + Blockly.BlockSvg.TAB_WIDTH + ",-2.5 " + Blockly.BlockSvg.TAB_WIDTH + ",7.5";
Blockly.BlockSvg.TAB_PATH_DOWN_HIGHLIGHT_RTL = "v 6.5 m -" + Blockly.BlockSvg.TAB_WIDTH * .97 + ",3 q -" + Blockly.BlockSvg.TAB_WIDTH * .05 + ",10 " + Blockly.BlockSvg.TAB_WIDTH * .3 + ",9.5 m " + Blockly.BlockSvg.TAB_WIDTH * .67 + ",-1.9 v 1.4";
Blockly.BlockSvg.TOP_LEFT_CORNER_START = "m 0," + Blockly.BlockSvg.CORNER_RADIUS;
Blockly.BlockSvg.TOP_LEFT_CORNER_START_HIGHLIGHT_RTL = "m " + Blockly.BlockSvg.DISTANCE_45_INSIDE + "," + Blockly.BlockSvg.DISTANCE_45_INSIDE;
Blockly.BlockSvg.TOP_LEFT_CORNER_START_HIGHLIGHT_LTR = "m 0.5," + (Blockly.BlockSvg.CORNER_RADIUS - .5);
Blockly.BlockSvg.TOP_LEFT_CORNER = "A " + Blockly.BlockSvg.CORNER_RADIUS + "," + Blockly.BlockSvg.CORNER_RADIUS + " 0 0,1 " + Blockly.BlockSvg.CORNER_RADIUS + ",0";
Blockly.BlockSvg.TOP_LEFT_CORNER_HIGHLIGHT = "A " + (Blockly.BlockSvg.CORNER_RADIUS - .5) + "," + (Blockly.BlockSvg.CORNER_RADIUS - .5) + " 0 0,1 " + Blockly.BlockSvg.CORNER_RADIUS + ",0.5";
Blockly.BlockSvg.INNER_TOP_LEFT_CORNER = Blockly.BlockSvg.NOTCH_PATH_RIGHT + " h -" + (Blockly.BlockSvg.NOTCH_WIDTH - 15 - Blockly.BlockSvg.CORNER_RADIUS) + " a " + Blockly.BlockSvg.CORNER_RADIUS + "," + Blockly.BlockSvg.CORNER_RADIUS + " 0 0,0 -" + Blockly.BlockSvg.CORNER_RADIUS + "," + Blockly.BlockSvg.CORNER_RADIUS;
Blockly.BlockSvg.INNER_BOTTOM_LEFT_CORNER = "a " + Blockly.BlockSvg.CORNER_RADIUS + "," + Blockly.BlockSvg.CORNER_RADIUS + " 0 0,0 " + Blockly.BlockSvg.CORNER_RADIUS + "," + Blockly.BlockSvg.CORNER_RADIUS;
Blockly.BlockSvg.INNER_TOP_LEFT_CORNER_HIGHLIGHT_RTL = "a " + Blockly.BlockSvg.CORNER_RADIUS + "," + Blockly.BlockSvg.CORNER_RADIUS + " 0 0,0 " + (-Blockly.BlockSvg.DISTANCE_45_OUTSIDE - .5) + "," + (Blockly.BlockSvg.CORNER_RADIUS - Blockly.BlockSvg.DISTANCE_45_OUTSIDE);
Blockly.BlockSvg.INNER_BOTTOM_LEFT_CORNER_HIGHLIGHT_RTL = "a " + (Blockly.BlockSvg.CORNER_RADIUS + .5) + "," + (Blockly.BlockSvg.CORNER_RADIUS + .5) + " 0 0,0 " + (Blockly.BlockSvg.CORNER_RADIUS + .5) + "," + (Blockly.BlockSvg.CORNER_RADIUS + .5);
Blockly.BlockSvg.INNER_BOTTOM_LEFT_CORNER_HIGHLIGHT_LTR = "a " + (Blockly.BlockSvg.CORNER_RADIUS + .5) + "," + (Blockly.BlockSvg.CORNER_RADIUS + .5) + " 0 0,0 " + (Blockly.BlockSvg.CORNER_RADIUS - Blockly.BlockSvg.DISTANCE_45_OUTSIDE) + "," + (Blockly.BlockSvg.DISTANCE_45_OUTSIDE + .5);
Blockly.BlockSvg.prototype.getHeightWidth = function() {
    var height = this.height;
    var width = this.width;
    var nextBlock = this.getNextBlock();
    if (nextBlock) {
        var nextHeightWidth = nextBlock.getHeightWidth();
        height += nextHeightWidth.height - 4;
        width = Math.max(width, nextHeightWidth.width)
    } else if (!this.nextConnection && !this.outputConnection) height += 2;
    return {
        height: height,
        width: width
    }
};
Blockly.BlockSvg.prototype.render = function(opt_bubble) {
    Blockly.Field.startCache();
    this.rendered = true;
    var cursorX = Blockly.BlockSvg.SEP_SPACE_X;
    if (this.RTL) cursorX = -cursorX;
    var icons = this.getIcons();
    for (var i = 0; i < icons.length; i++) cursorX = icons[i].renderIcon(cursorX);
    cursorX += this.RTL ? Blockly.BlockSvg.SEP_SPACE_X : -Blockly.BlockSvg.SEP_SPACE_X;
    var inputRows = this.renderCompute_(cursorX);
    this.renderDraw_(cursorX, inputRows);
    this.renderMoveConnections_();
    if (opt_bubble !== false) {
        var parentBlock = this.getParent();
        if (parentBlock) parentBlock.render(true);
        else this.workspace.resizeContents()
    }
    Blockly.Field.stopCache()
};
Blockly.BlockSvg.prototype.renderFields_ = function(fieldList, cursorX, cursorY) {
    cursorY += Blockly.BlockSvg.INLINE_PADDING_Y;
    if (this.RTL) cursorX = -cursorX;
    for (var t = 0, field; field = fieldList[t]; t++) {
        var root = field.getSvgRoot();
        if (!root) continue;
        if (this.RTL) {
            cursorX -= field.renderSep + field.renderWidth;
            root.setAttribute("transform", "translate(" + cursorX + "," + cursorY + ")");
            if (field.renderWidth) cursorX -= Blockly.BlockSvg.SEP_SPACE_X
        } else {
            root.setAttribute("transform", "translate(" + (cursorX + field.renderSep) + "," + cursorY +
                ")");
            if (field.renderWidth) cursorX += field.renderSep + field.renderWidth + Blockly.BlockSvg.SEP_SPACE_X
        }
    }
    return this.RTL ? -cursorX : cursorX
};
Blockly.BlockSvg.prototype.renderCompute_ = function(iconWidth) {
    var inputList = this.inputList;
    var inputRows = [];
    inputRows.rightEdge = iconWidth + Blockly.BlockSvg.SEP_SPACE_X * 2;
    if (this.previousConnection || this.nextConnection) inputRows.rightEdge = Math.max(inputRows.rightEdge, Blockly.BlockSvg.NOTCH_WIDTH + Blockly.BlockSvg.SEP_SPACE_X);
    var fieldValueWidth = 0;
    var fieldStatementWidth = 0;
    var hasValue = false;
    var hasStatement = false;
    var hasDummy = false;
    var lastType = undefined;
    var isInline = this.getInputsInline() && !this.isCollapsed();
    for (var i = 0, input; input = inputList[i]; i++) {
        if (!input.isVisible()) continue;
        var row;
        if (!isInline || !lastType || lastType == Blockly.NEXT_STATEMENT || input.type == Blockly.NEXT_STATEMENT) {
            lastType = input.type;
            row = [];
            if (isInline && input.type != Blockly.NEXT_STATEMENT) row.type = Blockly.BlockSvg.INLINE;
            else row.type = input.type;
            row.height = 0;
            inputRows.push(row)
        } else row = inputRows[inputRows.length - 1];
        row.push(input);
        input.renderHeight = Blockly.BlockSvg.MIN_BLOCK_Y;
        if (isInline && input.type == Blockly.INPUT_VALUE) input.renderWidth =
            Blockly.BlockSvg.TAB_WIDTH + Blockly.BlockSvg.SEP_SPACE_X * 1.25;
        else input.renderWidth = 0;
        if (input.connection && input.connection.isConnected()) {
            var linkedBlock = input.connection.targetBlock();
            var bBox = linkedBlock.getHeightWidth();
            input.renderHeight = Math.max(input.renderHeight, bBox.height);
            input.renderWidth = Math.max(input.renderWidth, bBox.width)
        }
        if (!isInline && i == inputList.length - 1) input.renderHeight--;
        else if (!isInline && input.type == Blockly.INPUT_VALUE && inputList[i + 1] && inputList[i + 1].type == Blockly.NEXT_STATEMENT) input.renderHeight--;
        row.height = Math.max(row.height, input.renderHeight);
        input.fieldWidth = 0;
        if (inputRows.length == 1) input.fieldWidth += this.RTL ? -iconWidth : iconWidth;
        var previousFieldEditable = false;
        for (var j = 0, field; field = input.fieldRow[j]; j++) {
            if (j != 0) input.fieldWidth += Blockly.BlockSvg.SEP_SPACE_X;
            var fieldSize = field.getSize();
            field.renderWidth = fieldSize.width;
            field.renderSep = previousFieldEditable && field.EDITABLE ? Blockly.BlockSvg.SEP_SPACE_X : 0;
            input.fieldWidth += field.renderWidth + field.renderSep;
            row.height = Math.max(row.height,
                fieldSize.height);
            previousFieldEditable = field.EDITABLE
        }
        if (row.type != Blockly.BlockSvg.INLINE)
            if (row.type == Blockly.NEXT_STATEMENT) {
                hasStatement = true;
                fieldStatementWidth = Math.max(fieldStatementWidth, input.fieldWidth)
            } else {
                if (row.type == Blockly.INPUT_VALUE) hasValue = true;
                else if (row.type == Blockly.DUMMY_INPUT) hasDummy = true;
                fieldValueWidth = Math.max(fieldValueWidth, input.fieldWidth)
            }
    }
    for (var y = 0, row; row = inputRows[y]; y++) {
        row.thicker = false;
        if (row.type == Blockly.BlockSvg.INLINE)
            for (var z = 0, input; input = row[z]; z++)
                if (input.type ==
                    Blockly.INPUT_VALUE) {
                    row.height += 2 * Blockly.BlockSvg.INLINE_PADDING_Y;
                    row.thicker = true;
                    break
                }
    }
    inputRows.statementEdge = 2 * Blockly.BlockSvg.SEP_SPACE_X + fieldStatementWidth;
    if (hasStatement) inputRows.rightEdge = Math.max(inputRows.rightEdge, inputRows.statementEdge + Blockly.BlockSvg.NOTCH_WIDTH);
    if (hasValue) inputRows.rightEdge = Math.max(inputRows.rightEdge, fieldValueWidth + Blockly.BlockSvg.SEP_SPACE_X * 2 + Blockly.BlockSvg.TAB_WIDTH);
    else if (hasDummy) inputRows.rightEdge = Math.max(inputRows.rightEdge, fieldValueWidth +
        Blockly.BlockSvg.SEP_SPACE_X * 2);
    inputRows.hasValue = hasValue;
    inputRows.hasStatement = hasStatement;
    inputRows.hasDummy = hasDummy;
    return inputRows
};
Blockly.BlockSvg.prototype.renderDraw_ = function(iconWidth, inputRows) {
    this.startHat_ = false;
    this.height = 0;
    if (this.outputConnection) {
        this.squareTopLeftCorner_ = true;
        this.squareBottomLeftCorner_ = true
    } else {
        this.squareTopLeftCorner_ = false;
        this.squareBottomLeftCorner_ = false;
        if (this.previousConnection) {
            var prevBlock = this.previousConnection.targetBlock();
            if (prevBlock && prevBlock.getNextBlock() == this) this.squareTopLeftCorner_ = true
        } else if (Blockly.BlockSvg.START_HAT) {
            this.squareTopLeftCorner_ = true;
            this.startHat_ =
                true;
            this.height += Blockly.BlockSvg.START_HAT_HEIGHT;
            inputRows.rightEdge = Math.max(inputRows.rightEdge, 100)
        }
        var nextBlock = this.getNextBlock();
        if (nextBlock) this.squareBottomLeftCorner_ = true
    }
    var pathObject = new Blockly.BlockSvg.PathObject;
    this.renderDrawTop_(pathObject, inputRows.rightEdge);
    var cursorY = this.renderDrawRight_(pathObject, inputRows, iconWidth);
    this.renderDrawBottom_(pathObject, cursorY);
    this.renderDrawLeft_(pathObject);
    this.setPaths_(pathObject)
};
Blockly.BlockSvg.prototype.setPaths_ = function(pathObject) {
    var pathString = pathObject.steps.join(" ") + "\n" + pathObject.inlineSteps.join(" ");
    this.svgPath_.setAttribute("d", pathString);
    this.svgPathDark_.setAttribute("d", pathString);
    pathString = pathObject.highlightSteps.join(" ") + "\n" + pathObject.highlightInlineSteps.join(" ");
    this.svgPathLight_.setAttribute("d", pathString);
    if (this.RTL) {
        this.svgPath_.setAttribute("transform", "scale(-1 1)");
        this.svgPathLight_.setAttribute("transform", "scale(-1 1)");
        this.svgPathDark_.setAttribute("transform",
            "translate(1,1) scale(-1 1)")
    }
};
Blockly.BlockSvg.prototype.renderMoveConnections_ = function() {
    var blockTL = this.getRelativeToSurfaceXY();
    if (this.previousConnection) this.previousConnection.moveToOffset(blockTL);
    if (this.outputConnection) this.outputConnection.moveToOffset(blockTL);
    for (var i = 0; i < this.inputList.length; i++) {
        var conn = this.inputList[i].connection;
        if (conn) {
            conn.moveToOffset(blockTL);
            if (conn.isConnected()) conn.tighten_()
        }
    }
    if (this.nextConnection) {
        this.nextConnection.moveToOffset(blockTL);
        if (this.nextConnection.isConnected()) this.nextConnection.tighten_()
    }
};
Blockly.BlockSvg.prototype.renderDrawTop_ = function(pathObject, rightEdge) {
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    if (this.squareTopLeftCorner_) {
        steps.push("m 0,0");
        highlightSteps.push("m 0.5,0.5");
        if (this.startHat_) {
            steps.push(Blockly.BlockSvg.START_HAT_PATH);
            highlightSteps.push(this.RTL ? Blockly.BlockSvg.START_HAT_HIGHLIGHT_RTL : Blockly.BlockSvg.START_HAT_HIGHLIGHT_LTR)
        }
    } else {
        steps.push(Blockly.BlockSvg.TOP_LEFT_CORNER_START);
        highlightSteps.push(this.RTL ? Blockly.BlockSvg.TOP_LEFT_CORNER_START_HIGHLIGHT_RTL :
            Blockly.BlockSvg.TOP_LEFT_CORNER_START_HIGHLIGHT_LTR);
        steps.push(Blockly.BlockSvg.TOP_LEFT_CORNER);
        highlightSteps.push(Blockly.BlockSvg.TOP_LEFT_CORNER_HIGHLIGHT)
    }
    if (this.previousConnection) {
        steps.push("H", Blockly.BlockSvg.NOTCH_WIDTH - 15);
        highlightSteps.push("H", Blockly.BlockSvg.NOTCH_WIDTH - 15);
        steps.push(Blockly.BlockSvg.NOTCH_PATH_LEFT);
        highlightSteps.push(Blockly.BlockSvg.NOTCH_PATH_LEFT_HIGHLIGHT);
        var connectionX = this.RTL ? -Blockly.BlockSvg.NOTCH_WIDTH : Blockly.BlockSvg.NOTCH_WIDTH;
        this.previousConnection.setOffsetInBlock(connectionX,
            0)
    }
    steps.push("H", rightEdge);
    highlightSteps.push("H", rightEdge - .5);
    this.width = rightEdge
};
Blockly.BlockSvg.prototype.renderDrawRight_ = function(pathObject, inputRows, iconWidth) {
    var cursor = {
        x: 0,
        y: 0
    };
    var connectionPos = {
        x: 0,
        y: 0
    };
    for (var y = 0, row; row = inputRows[y]; y++) {
        cursor.x = Blockly.BlockSvg.SEP_SPACE_X;
        if (y == 0) cursor.x += this.RTL ? -iconWidth : iconWidth;
        pathObject.highlightSteps.push("M", inputRows.rightEdge - .5 + "," + (cursor.y + .5));
        if (this.isCollapsed()) this.renderJaggedEdge_(pathObject, row, cursor);
        else if (row.type == Blockly.BlockSvg.INLINE) this.renderInlineRow_(pathObject, row, cursor, connectionPos,
            inputRows.rightEdge);
        else if (row.type == Blockly.INPUT_VALUE) this.renderExternalValueInput_(pathObject, row, cursor, connectionPos, inputRows.rightEdge);
        else if (row.type == Blockly.DUMMY_INPUT) this.renderDummyInput_(pathObject, row, cursor, inputRows.rightEdge, inputRows.hasValue);
        else if (row.type == Blockly.NEXT_STATEMENT) this.renderStatementInput_(pathObject, row, cursor, connectionPos, inputRows, y);
        cursor.y += row.height
    }
    if (!inputRows.length) {
        cursor.y = Blockly.BlockSvg.MIN_BLOCK_Y;
        pathObject.steps.push("V", cursor.y);
        if (this.RTL) pathObject.highlightSteps.push("V", cursor.y - 1)
    }
    return cursor.y
};
Blockly.BlockSvg.prototype.renderDrawBottom_ = function(pathObject, cursorY) {
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    this.height += cursorY + 1;
    if (this.nextConnection) {
        steps.push("H", Blockly.BlockSvg.NOTCH_WIDTH + (this.RTL ? .5 : -.5) + " " + Blockly.BlockSvg.NOTCH_PATH_RIGHT);
        var connectionX;
        if (this.RTL) connectionX = -Blockly.BlockSvg.NOTCH_WIDTH;
        else connectionX = Blockly.BlockSvg.NOTCH_WIDTH;
        this.nextConnection.setOffsetInBlock(connectionX, cursorY + 1);
        this.height += 4
    }
    if (this.squareBottomLeftCorner_) {
        steps.push("H 0");
        if (!this.RTL) highlightSteps.push("M", "0.5," + (cursorY - .5))
    } else {
        steps.push("H", Blockly.BlockSvg.CORNER_RADIUS);
        steps.push("a", Blockly.BlockSvg.CORNER_RADIUS + "," + Blockly.BlockSvg.CORNER_RADIUS + " 0 0,1 -" + Blockly.BlockSvg.CORNER_RADIUS + ",-" + Blockly.BlockSvg.CORNER_RADIUS);
        if (!this.RTL) {
            highlightSteps.push("M", Blockly.BlockSvg.DISTANCE_45_INSIDE + "," + (cursorY - Blockly.BlockSvg.DISTANCE_45_INSIDE));
            highlightSteps.push("A", Blockly.BlockSvg.CORNER_RADIUS - .5 + "," + (Blockly.BlockSvg.CORNER_RADIUS - .5) + " 0 0,1 " +
                "0.5," + (cursorY - Blockly.BlockSvg.CORNER_RADIUS))
        }
    }
};
Blockly.BlockSvg.prototype.renderDrawLeft_ = function(pathObject) {
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    if (this.outputConnection) {
        this.outputConnection.setOffsetInBlock(0, 0);
        steps.push("V", Blockly.BlockSvg.TAB_HEIGHT);
        steps.push("c 0,-10 -" + Blockly.BlockSvg.TAB_WIDTH + ",8 -" + Blockly.BlockSvg.TAB_WIDTH + ",-7.5 s " + Blockly.BlockSvg.TAB_WIDTH + ",2.5 " + Blockly.BlockSvg.TAB_WIDTH + ",-7.5");
        if (this.RTL) {
            highlightSteps.push("M", Blockly.BlockSvg.TAB_WIDTH * -.25 + ",8.4");
            highlightSteps.push("l",
                Blockly.BlockSvg.TAB_WIDTH * -.45 + ",-2.1")
        } else {
            highlightSteps.push("V", Blockly.BlockSvg.TAB_HEIGHT - 1.5);
            highlightSteps.push("m", Blockly.BlockSvg.TAB_WIDTH * -.92 + ",-0.5 q " + Blockly.BlockSvg.TAB_WIDTH * -.19 + ",-5.5 0,-11");
            highlightSteps.push("m", Blockly.BlockSvg.TAB_WIDTH * .92 + ",1 V 0.5 H 1")
        }
        this.width += Blockly.BlockSvg.TAB_WIDTH
    } else if (!this.RTL)
        if (this.squareTopLeftCorner_) highlightSteps.push("V", .5);
        else highlightSteps.push("V", Blockly.BlockSvg.CORNER_RADIUS);
    steps.push("z")
};
Blockly.BlockSvg.prototype.renderJaggedEdge_ = function(pathObject, row, cursor) {
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    var input = row[0];
    this.renderFields_(input.fieldRow, cursor.x, cursor.y);
    steps.push(Blockly.BlockSvg.JAGGED_TEETH);
    highlightSteps.push("h 8");
    var remainder = row.height - Blockly.BlockSvg.JAGGED_TEETH_HEIGHT;
    steps.push("v", remainder);
    if (this.RTL) {
        highlightSteps.push("v 3.9 l 7.2,3.4 m -14.5,8.9 l 7.3,3.5");
        highlightSteps.push("v", remainder - .7)
    }
    this.width += Blockly.BlockSvg.JAGGED_TEETH_WIDTH
};
Blockly.BlockSvg.prototype.renderInlineRow_ = function(pathObject, row, cursor, connectionPos, rightEdge) {
    var inlineSteps = pathObject.inlineSteps;
    var highlightInlineSteps = pathObject.highlightInlineSteps;
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    for (var x = 0, input; input = row[x]; x++) {
        var fieldX = cursor.x;
        var fieldY = cursor.y;
        if (row.thicker) fieldY += Blockly.BlockSvg.INLINE_PADDING_Y;
        cursor.x = this.renderFields_(input.fieldRow, fieldX, fieldY);
        if (input.type != Blockly.DUMMY_INPUT) cursor.x +=
            input.renderWidth + Blockly.BlockSvg.SEP_SPACE_X;
        if (input.type == Blockly.INPUT_VALUE) {
            inlineSteps.push("M", cursor.x - Blockly.BlockSvg.SEP_SPACE_X + "," + (cursor.y + Blockly.BlockSvg.INLINE_PADDING_Y));
            inlineSteps.push("h", Blockly.BlockSvg.TAB_WIDTH - 2 - input.renderWidth);
            inlineSteps.push(Blockly.BlockSvg.TAB_PATH_DOWN);
            inlineSteps.push("v", input.renderHeight + 1 - Blockly.BlockSvg.TAB_HEIGHT);
            inlineSteps.push("h", input.renderWidth + 2 - Blockly.BlockSvg.TAB_WIDTH);
            inlineSteps.push("z");
            if (this.RTL) {
                highlightInlineSteps.push("M",
                    cursor.x - Blockly.BlockSvg.SEP_SPACE_X - 2.5 + Blockly.BlockSvg.TAB_WIDTH - input.renderWidth + "," + (cursor.y + Blockly.BlockSvg.INLINE_PADDING_Y + .5));
                highlightInlineSteps.push(Blockly.BlockSvg.TAB_PATH_DOWN_HIGHLIGHT_RTL);
                highlightInlineSteps.push("v", input.renderHeight - Blockly.BlockSvg.TAB_HEIGHT + 2.5);
                highlightInlineSteps.push("h", input.renderWidth - Blockly.BlockSvg.TAB_WIDTH + 2)
            } else {
                highlightInlineSteps.push("M", cursor.x - Blockly.BlockSvg.SEP_SPACE_X + .5 + "," + (cursor.y + Blockly.BlockSvg.INLINE_PADDING_Y + .5));
                highlightInlineSteps.push("v", input.renderHeight + 1);
                highlightInlineSteps.push("h", Blockly.BlockSvg.TAB_WIDTH - 2 - input.renderWidth);
                highlightInlineSteps.push("M", cursor.x - input.renderWidth - Blockly.BlockSvg.SEP_SPACE_X + .9 + "," + (cursor.y + Blockly.BlockSvg.INLINE_PADDING_Y + Blockly.BlockSvg.TAB_HEIGHT - .7));
                highlightInlineSteps.push("l", Blockly.BlockSvg.TAB_WIDTH * .46 + ",-2.1")
            }
            if (this.RTL) connectionPos.x = -cursor.x - Blockly.BlockSvg.TAB_WIDTH + Blockly.BlockSvg.SEP_SPACE_X + input.renderWidth + 1;
            else connectionPos.x =
                cursor.x + Blockly.BlockSvg.TAB_WIDTH - Blockly.BlockSvg.SEP_SPACE_X - input.renderWidth - 1;
            connectionPos.y = cursor.y + Blockly.BlockSvg.INLINE_PADDING_Y + 1;
            input.connection.setOffsetInBlock(connectionPos.x, connectionPos.y)
        }
    }
    cursor.x = Math.max(cursor.x, rightEdge);
    this.width = Math.max(this.width, cursor.x);
    steps.push("H", cursor.x);
    highlightSteps.push("H", cursor.x - .5);
    steps.push("v", row.height);
    if (this.RTL) highlightSteps.push("v", row.height - 1)
};
Blockly.BlockSvg.prototype.renderExternalValueInput_ = function(pathObject, row, cursor, connectionPos, rightEdge) {
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    var input = row[0];
    var fieldX = cursor.x;
    var fieldY = cursor.y;
    if (input.align != Blockly.ALIGN_LEFT) {
        var fieldRightX = rightEdge - input.fieldWidth - Blockly.BlockSvg.TAB_WIDTH - 2 * Blockly.BlockSvg.SEP_SPACE_X;
        if (input.align == Blockly.ALIGN_RIGHT) fieldX += fieldRightX;
        else if (input.align == Blockly.ALIGN_CENTRE) fieldX += fieldRightX / 2
    }
    this.renderFields_(input.fieldRow,
        fieldX, fieldY);
    steps.push(Blockly.BlockSvg.TAB_PATH_DOWN);
    var v = row.height - Blockly.BlockSvg.TAB_HEIGHT;
    steps.push("v", v);
    if (this.RTL) {
        highlightSteps.push(Blockly.BlockSvg.TAB_PATH_DOWN_HIGHLIGHT_RTL);
        highlightSteps.push("v", v + .5)
    } else {
        highlightSteps.push("M", rightEdge - 5 + "," + (cursor.y + Blockly.BlockSvg.TAB_HEIGHT - .7));
        highlightSteps.push("l", Blockly.BlockSvg.TAB_WIDTH * .46 + ",-2.1")
    }
    connectionPos.x = this.RTL ? -rightEdge - 1 : rightEdge + 1;
    input.connection.setOffsetInBlock(connectionPos.x, cursor.y);
    if (input.connection.isConnected()) this.width =
        Math.max(this.width, rightEdge + input.connection.targetBlock().getHeightWidth().width - Blockly.BlockSvg.TAB_WIDTH + 1)
};
Blockly.BlockSvg.prototype.renderDummyInput_ = function(pathObject, row, cursor, rightEdge, hasValue) {
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    var input = row[0];
    var fieldX = cursor.x;
    var fieldY = cursor.y;
    if (input.align != Blockly.ALIGN_LEFT) {
        var fieldRightX = rightEdge - input.fieldWidth - 2 * Blockly.BlockSvg.SEP_SPACE_X;
        if (hasValue) fieldRightX -= Blockly.BlockSvg.TAB_WIDTH;
        if (input.align == Blockly.ALIGN_RIGHT) fieldX += fieldRightX;
        else if (input.align == Blockly.ALIGN_CENTRE) fieldX += fieldRightX /
            2
    }
    this.renderFields_(input.fieldRow, fieldX, fieldY);
    steps.push("v", row.height);
    if (this.RTL) highlightSteps.push("v", row.height - 1)
};
Blockly.BlockSvg.prototype.renderStatementInput_ = function(pathObject, row, cursor, connectionPos, inputRows, index) {
    var steps = pathObject.steps;
    var highlightSteps = pathObject.highlightSteps;
    var input = row[0];
    if (index == 0) {
        steps.push("v", Blockly.BlockSvg.SEP_SPACE_Y);
        if (this.RTL) highlightSteps.push("v", Blockly.BlockSvg.SEP_SPACE_Y - 1);
        cursor.y += Blockly.BlockSvg.SEP_SPACE_Y
    }
    var fieldX = cursor.x;
    var fieldY = cursor.y;
    if (input.align != Blockly.ALIGN_LEFT) {
        var fieldRightX = inputRows.statementEdge - input.fieldWidth - 2 * Blockly.BlockSvg.SEP_SPACE_X;
        if (input.align == Blockly.ALIGN_RIGHT) fieldX += fieldRightX;
        else if (input.align == Blockly.ALIGN_CENTRE) fieldX += fieldRightX / 2
    }
    this.renderFields_(input.fieldRow, fieldX, fieldY);
    cursor.x = inputRows.statementEdge + Blockly.BlockSvg.NOTCH_WIDTH;
    steps.push("H", cursor.x);
    steps.push(Blockly.BlockSvg.INNER_TOP_LEFT_CORNER);
    steps.push("v", row.height - 2 * Blockly.BlockSvg.CORNER_RADIUS);
    steps.push(Blockly.BlockSvg.INNER_BOTTOM_LEFT_CORNER);
    steps.push("H", inputRows.rightEdge);
    if (this.RTL) {
        highlightSteps.push("M", cursor.x -
            Blockly.BlockSvg.NOTCH_WIDTH + Blockly.BlockSvg.DISTANCE_45_OUTSIDE + "," + (cursor.y + Blockly.BlockSvg.DISTANCE_45_OUTSIDE));
        highlightSteps.push(Blockly.BlockSvg.INNER_TOP_LEFT_CORNER_HIGHLIGHT_RTL);
        highlightSteps.push("v", row.height - 2 * Blockly.BlockSvg.CORNER_RADIUS);
        highlightSteps.push(Blockly.BlockSvg.INNER_BOTTOM_LEFT_CORNER_HIGHLIGHT_RTL);
        highlightSteps.push("H", inputRows.rightEdge - .5)
    } else {
        highlightSteps.push("M", cursor.x - Blockly.BlockSvg.NOTCH_WIDTH + Blockly.BlockSvg.DISTANCE_45_OUTSIDE + "," + (cursor.y +
            row.height - Blockly.BlockSvg.DISTANCE_45_OUTSIDE));
        highlightSteps.push(Blockly.BlockSvg.INNER_BOTTOM_LEFT_CORNER_HIGHLIGHT_LTR);
        highlightSteps.push("H", inputRows.rightEdge - .5)
    }
    connectionPos.x = this.RTL ? -cursor.x : cursor.x + 1;
    input.connection.setOffsetInBlock(connectionPos.x, cursor.y + 1);
    if (input.connection.isConnected()) this.width = Math.max(this.width, inputRows.statementEdge + input.connection.targetBlock().getHeightWidth().width);
    if (index == inputRows.length - 1 || inputRows[index + 1].type == Blockly.NEXT_STATEMENT) {
        steps.push("v",
            Blockly.BlockSvg.SEP_SPACE_Y);
        if (this.RTL) highlightSteps.push("v", Blockly.BlockSvg.SEP_SPACE_Y - 1);
        cursor.y += Blockly.BlockSvg.SEP_SPACE_Y
    }
};
goog.provide("Blockly.BlockSvg");
goog.require("Blockly.Block");
goog.require("Blockly.BlockAnimations");
goog.require("Blockly.ContextMenu");
goog.require("Blockly.Events.Ui");
goog.require("Blockly.Events.BlockMove");
goog.require("Blockly.Grid");
goog.require("Blockly.RenderedConnection");
goog.require("Blockly.Tooltip");
goog.require("Blockly.Touch");
goog.require("Blockly.utils");
goog.require("goog.color");
goog.require("goog.math.Coordinate");
Blockly.BlockSvg = function(workspace, prototypeName, opt_id) {
    this.svgGroup_ = Blockly.utils.createSvgElement("g", {}, null);
    this.svgGroup_.translate_ = "";
    this.svgPathDark_ = Blockly.utils.createSvgElement("path", {
        "class": "blocklyPathDark",
        "transform": "translate(1,1)"
    }, this.svgGroup_);
    this.svgPath_ = Blockly.utils.createSvgElement("path", {
        "class": "blocklyPath"
    }, this.svgGroup_);
    this.svgPathLight_ = Blockly.utils.createSvgElement("path", {
        "class": "blocklyPathLight"
    }, this.svgGroup_);
    this.svgPath_.tooltip = this;
    this.rendered =
        false;
    this.useDragSurface_ = Blockly.utils.is3dSupported() && !!workspace.blockDragSurface_;
    Blockly.Tooltip.bindMouseEvents(this.svgPath_);
    Blockly.BlockSvg.superClass_.constructor.call(this, workspace, prototypeName, opt_id);
    if (this.svgGroup_.dataset) this.svgGroup_.dataset.id = this.id
};
goog.inherits(Blockly.BlockSvg, Blockly.Block);
Blockly.BlockSvg.prototype.height = 0;
Blockly.BlockSvg.prototype.width = 0;
Blockly.BlockSvg.prototype.dragStartXY_ = null;
Blockly.BlockSvg.prototype.warningTextDb_ = null;
Blockly.BlockSvg.INLINE = -1;
Blockly.BlockSvg.prototype.initSvg = function() {
    if (!this.workspace.rendered) throw TypeError("Workspace is headless.");
    for (var i = 0, input; input = this.inputList[i]; i++) input.init();
    var icons = this.getIcons();
    for (var i = 0; i < icons.length; i++) icons[i].createIcon();
    this.updateColour();
    this.updateMovable();
    if (!this.workspace.options.readOnly && !this.eventsInit_) Blockly.bindEventWithChecks_(this.getSvgRoot(), "mousedown", this, this.onMouseDown_);
    this.eventsInit_ = true;
    if (!this.getSvgRoot().parentNode) this.workspace.getCanvas().appendChild(this.getSvgRoot())
};
Blockly.BlockSvg.prototype.select = function() {
    if (this.isShadow() && this.getParent()) {
        this.getParent().select();
        return
    }
    if (Blockly.selected == this) return;
    var oldId = null;
    if (Blockly.selected) {
        oldId = Blockly.selected.id;
        Blockly.Events.disable();
        try {
            Blockly.selected.unselect()
        } finally {
            Blockly.Events.enable()
        }
    }
    var event = new Blockly.Events.Ui(null, "selected", oldId, this.id);
    event.workspaceId = this.workspace.id;
    Blockly.Events.fire(event);
    Blockly.selected = this;
    this.addSelect()
};
Blockly.BlockSvg.prototype.unselect = function() {
    if (Blockly.selected != this) return;
    var event = new Blockly.Events.Ui(null, "selected", this.id, null);
    event.workspaceId = this.workspace.id;
    Blockly.Events.fire(event);
    Blockly.selected = null;
    this.removeSelect()
};
Blockly.BlockSvg.prototype.mutator = null;
Blockly.BlockSvg.prototype.comment = null;
Blockly.BlockSvg.prototype.warning = null;
Blockly.BlockSvg.prototype.getIcons = function() {
    var icons = [];
    if (this.mutator) icons.push(this.mutator);
    if (this.comment) icons.push(this.comment);
    if (this.warning) icons.push(this.warning);
    return icons
};
Blockly.BlockSvg.prototype.setParent = function(newParent) {
    var oldParent = this.parentBlock_;
    if (newParent == oldParent) return;
    Blockly.Field.startCache();
    Blockly.BlockSvg.superClass_.setParent.call(this, newParent);
    Blockly.Field.stopCache();
    var svgRoot = this.getSvgRoot();
    if (this.workspace.isClearing || !svgRoot) return;
    var oldXY = this.getRelativeToSurfaceXY();
    if (newParent) {
        newParent.getSvgRoot().appendChild(svgRoot);
        var newXY = this.getRelativeToSurfaceXY();
        this.moveConnections_(newXY.x - oldXY.x, newXY.y - oldXY.y)
    } else if (oldParent) {
        this.workspace.getCanvas().appendChild(svgRoot);
        this.translate(oldXY.x, oldXY.y)
    }
};
Blockly.BlockSvg.prototype.getRelativeToSurfaceXY = function() {
    var x = 0;
    var y = 0;
    var dragSurfaceGroup = this.useDragSurface_ ? this.workspace.blockDragSurface_.getGroup() : null;
    var element = this.getSvgRoot();
    if (element) {
        do {
            var xy = Blockly.utils.getRelativeXY(element);
            x += xy.x;
            y += xy.y;
            if (this.useDragSurface_ && this.workspace.blockDragSurface_.getCurrentBlock() == element) {
                var surfaceTranslation = this.workspace.blockDragSurface_.getSurfaceTranslation();
                x += surfaceTranslation.x;
                y += surfaceTranslation.y
            }
            element = element.parentNode
        } while (element &&
            element != this.workspace.getCanvas() && element != dragSurfaceGroup)
    }
    return new goog.math.Coordinate(x, y)
};
Blockly.BlockSvg.prototype.moveBy = function(dx, dy) {
    if (this.parentBlock_) throw Error("Block has parent.");
    var eventsEnabled = Blockly.Events.isEnabled();
    if (eventsEnabled) var event = new Blockly.Events.BlockMove(this);
    var xy = this.getRelativeToSurfaceXY();
    this.translate(xy.x + dx, xy.y + dy);
    this.moveConnections_(dx, dy);
    if (eventsEnabled) {
        event.recordNew();
        Blockly.Events.fire(event)
    }
    this.workspace.resizeContents()
};
Blockly.BlockSvg.prototype.translate = function(x, y) {
    this.getSvgRoot().setAttribute("transform", "translate(" + x + "," + y + ")")
};
Blockly.BlockSvg.prototype.moveToDragSurface_ = function() {
    if (!this.useDragSurface_) return;
    var xy = this.getRelativeToSurfaceXY();
    this.clearTransformAttributes_();
    this.workspace.blockDragSurface_.translateSurface(xy.x, xy.y);
    this.workspace.blockDragSurface_.setBlocksAndShow(this.getSvgRoot())
};
Blockly.BlockSvg.prototype.moveOffDragSurface_ = function(newXY) {
    if (!this.useDragSurface_) return;
    this.translate(newXY.x, newXY.y);
    this.workspace.blockDragSurface_.clearAndHide(this.workspace.getCanvas())
};
Blockly.BlockSvg.prototype.moveDuringDrag = function(newLoc) {
    if (this.useDragSurface_) this.workspace.blockDragSurface_.translateSurface(newLoc.x, newLoc.y);
    else {
        this.svgGroup_.translate_ = "translate(" + newLoc.x + "," + newLoc.y + ")";
        this.svgGroup_.setAttribute("transform", this.svgGroup_.translate_ + this.svgGroup_.skew_)
    }
};
Blockly.BlockSvg.prototype.clearTransformAttributes_ = function() {
    Blockly.utils.removeAttribute(this.getSvgRoot(), "transform")
};
Blockly.BlockSvg.prototype.snapToGrid = function() {
    if (!this.workspace) return;
    if (this.workspace.isDragging()) return;
    if (this.getParent()) return;
    if (this.isInFlyout) return;
    var grid = this.workspace.getGrid();
    if (!grid || !grid.shouldSnap()) return;
    var spacing = grid.getSpacing();
    var half = spacing / 2;
    var xy = this.getRelativeToSurfaceXY();
    var dx = Math.round((xy.x - half) / spacing) * spacing + half - xy.x;
    var dy = Math.round((xy.y - half) / spacing) * spacing + half - xy.y;
    dx = Math.round(dx);
    dy = Math.round(dy);
    if (dx != 0 || dy != 0) this.moveBy(dx,
        dy)
};
Blockly.BlockSvg.prototype.getBoundingRectangle = function() {
    var blockXY = this.getRelativeToSurfaceXY(this);
    var tab = this.outputConnection ? Blockly.BlockSvg.TAB_WIDTH : 0;
    var blockBounds = this.getHeightWidth();
    var topLeft;
    var bottomRight;
    if (this.RTL) {
        topLeft = new goog.math.Coordinate(blockXY.x - (blockBounds.width - tab), blockXY.y);
        bottomRight = new goog.math.Coordinate(blockXY.x + tab, blockXY.y + blockBounds.height)
    } else {
        topLeft = new goog.math.Coordinate(blockXY.x - tab, blockXY.y);
        bottomRight = new goog.math.Coordinate(blockXY.x + blockBounds.width -
            tab, blockXY.y + blockBounds.height)
    }
    return {
        topLeft: topLeft,
        bottomRight: bottomRight
    }
};
Blockly.BlockSvg.prototype.setCollapsed = function(collapsed) {
    if (this.collapsed_ == collapsed) return;
    var renderList = [];
    for (var i = 0, input; input = this.inputList[i]; i++) renderList.push.apply(renderList, input.setVisible(!collapsed));
    var COLLAPSED_INPUT_NAME = "_TEMP_COLLAPSED_INPUT";
    if (collapsed) {
        var icons = this.getIcons();
        for (var i = 0; i < icons.length; i++) icons[i].setVisible(false);
        var text = this.toString(Blockly.COLLAPSE_CHARS);
        this.appendDummyInput(COLLAPSED_INPUT_NAME).appendField(text).init()
    } else {
        this.removeInput(COLLAPSED_INPUT_NAME);
        this.setWarningText(null)
    }
    Blockly.BlockSvg.superClass_.setCollapsed.call(this, collapsed);
    if (!renderList.length) renderList[0] = this;
    if (this.rendered)
        for (var i = 0, block; block = renderList[i]; i++) block.render()
};
Blockly.BlockSvg.prototype.tab = function(start, forward) {
    var list = this.createTabList_();
    var i = list.indexOf(start);
    if (i == -1) i = forward ? -1 : list.length;
    var target = list[forward ? i + 1 : i - 1];
    if (!target) {
        var parent = this.getParent();
        if (parent) parent.tab(this, forward)
    } else if (target instanceof Blockly.Field) target.showEditor_();
    else target.tab(null, forward)
};
Blockly.BlockSvg.prototype.createTabList_ = function() {
    var list = [];
    for (var i = 0, input; input = this.inputList[i]; i++) {
        for (var j = 0, field; field = input.fieldRow[j]; j++)
            if (field instanceof Blockly.FieldTextInput) list.push(field);
        if (input.connection) {
            var block = input.connection.targetBlock();
            if (block) list.push(block)
        }
    }
    return list
};
Blockly.BlockSvg.prototype.onMouseDown_ = function(e) {
    var gesture = this.workspace && this.workspace.getGesture(e);
    if (gesture) gesture.handleBlockStart(e, this)
};
Blockly.BlockSvg.prototype.showHelp_ = function() {
    var url = typeof this.helpUrl == "function" ? this.helpUrl() : this.helpUrl;
    if (url) window.open(url)
};
Blockly.BlockSvg.prototype.showContextMenu_ = function(e) {
    if (this.workspace.options.readOnly || !this.contextMenu) return;
    var block = this;
    var menuOptions = [];
    if (this.isDeletable() && this.isMovable() && !block.isInFlyout) {
        menuOptions.push(Blockly.ContextMenu.blockDuplicateOption(block));
        if (this.isEditable() && !this.collapsed_ && this.workspace.options.comments) menuOptions.push(Blockly.ContextMenu.blockCommentOption(block));
        if (!this.collapsed_)
            for (var i = 1; i < this.inputList.length; i++)
                if (this.inputList[i - 1].type !=
                    Blockly.NEXT_STATEMENT && this.inputList[i].type != Blockly.NEXT_STATEMENT) {
                    var inlineOption = {
                        enabled: true
                    };
                    var isInline = this.getInputsInline();
                    inlineOption.text = isInline ? Blockly.Msg["EXTERNAL_INPUTS"] : Blockly.Msg["INLINE_INPUTS"];
                    inlineOption.callback = function() {
                        block.setInputsInline(!isInline)
                    };
                    menuOptions.push(inlineOption);
                    break
                } if (this.workspace.options.collapse)
            if (this.collapsed_) {
                var expandOption = {
                    enabled: true
                };
                expandOption.text = Blockly.Msg["EXPAND_BLOCK"];
                expandOption.callback = function() {
                    block.setCollapsed(false)
                };
                menuOptions.push(expandOption)
            } else {
                var collapseOption = {
                    enabled: true
                };
                collapseOption.text = Blockly.Msg["COLLAPSE_BLOCK"];
                collapseOption.callback = function() {
                    block.setCollapsed(true)
                };
                menuOptions.push(collapseOption)
            } if (this.workspace.options.disable) {
            var disableOption = {
                text: this.disabled ? Blockly.Msg["ENABLE_BLOCK"] : Blockly.Msg["DISABLE_BLOCK"],
                enabled: !this.getInheritedDisabled(),
                callback: function() {
                    var group = Blockly.Events.getGroup();
                    if (!group) Blockly.Events.setGroup(true);
                    block.setDisabled(!block.disabled);
                    if (!group) Blockly.Events.setGroup(false)
                }
            };
            menuOptions.push(disableOption)
        }
        menuOptions.push(Blockly.ContextMenu.blockDeleteOption(block))
    }
    menuOptions.push(Blockly.ContextMenu.blockHelpOption(block));
    if (this.customContextMenu) this.customContextMenu(menuOptions);
    Blockly.ContextMenu.show(e, menuOptions, this.RTL);
    Blockly.ContextMenu.currentBlock = this
};
Blockly.BlockSvg.prototype.moveConnections_ = function(dx, dy) {
    if (!this.rendered) return;
    var myConnections = this.getConnections_(false);
    for (var i = 0; i < myConnections.length; i++) myConnections[i].moveBy(dx, dy);
    var icons = this.getIcons();
    for (var i = 0; i < icons.length; i++) icons[i].computeIconLocation();
    for (var i = 0; i < this.childBlocks_.length; i++) this.childBlocks_[i].moveConnections_(dx, dy)
};
Blockly.BlockSvg.prototype.setDragging = function(adding) {
    if (adding) {
        var group = this.getSvgRoot();
        group.translate_ = "";
        group.skew_ = "";
        Blockly.draggingConnections_ = Blockly.draggingConnections_.concat(this.getConnections_(true));
        Blockly.utils.addClass(this.svgGroup_, "blocklyDragging")
    } else {
        Blockly.draggingConnections_ = [];
        Blockly.utils.removeClass(this.svgGroup_, "blocklyDragging")
    }
    for (var i = 0; i < this.childBlocks_.length; i++) this.childBlocks_[i].setDragging(adding)
};
Blockly.BlockSvg.prototype.updateMovable = function() {
    if (this.isMovable()) Blockly.utils.addClass(this.svgGroup_, "blocklyDraggable");
    else Blockly.utils.removeClass(this.svgGroup_, "blocklyDraggable")
};
Blockly.BlockSvg.prototype.setMovable = function(movable) {
    Blockly.BlockSvg.superClass_.setMovable.call(this, movable);
    this.updateMovable()
};
Blockly.BlockSvg.prototype.setEditable = function(editable) {
    Blockly.BlockSvg.superClass_.setEditable.call(this, editable);
    var icons = this.getIcons();
    for (var i = 0; i < icons.length; i++) icons[i].updateEditable()
};
Blockly.BlockSvg.prototype.setShadow = function(shadow) {
    Blockly.BlockSvg.superClass_.setShadow.call(this, shadow);
    this.updateColour()
};
Blockly.BlockSvg.prototype.setInsertionMarker = function(insertionMarker) {
    if (this.isInsertionMarker_ == insertionMarker) return;
    this.isInsertionMarker_ = insertionMarker;
    if (this.isInsertionMarker_) {
        this.setColour(Blockly.INSERTION_MARKER_COLOUR);
        Blockly.utils.addClass(this.svgGroup_, "blocklyInsertionMarker")
    }
};
Blockly.BlockSvg.prototype.getSvgRoot = function() {
    return this.svgGroup_
};
Blockly.BlockSvg.prototype.dispose = function(healStack, animate) {
    if (!this.workspace) return;
    Blockly.Tooltip.hide();
    Blockly.Field.startCache();
    var blockWorkspace = this.workspace;
    if (Blockly.selected == this) {
        this.unselect();
        this.workspace.cancelCurrentGesture()
    }
    if (Blockly.ContextMenu.currentBlock == this) Blockly.ContextMenu.hide();
    if (animate && this.rendered) {
        this.unplug(healStack);
        Blockly.BlockAnimations.disposeUiEffect(this)
    }
    this.rendered = false;
    if (this.warningTextDb_) {
        for (var n in this.warningTextDb_) clearTimeout(this.warningTextDb_[n]);
        this.warningTextDb_ = null
    }
    Blockly.Events.disable();
    try {
        var icons = this.getIcons();
        for (var i = 0; i < icons.length; i++) icons[i].dispose()
    } finally {
        Blockly.Events.enable()
    }
    Blockly.BlockSvg.superClass_.dispose.call(this, healStack);
    Blockly.utils.removeNode(this.svgGroup_);
    blockWorkspace.resizeContents();
    this.svgGroup_ = null;
    this.svgPath_ = null;
    this.svgPathLight_ = null;
    this.svgPathDark_ = null;
    Blockly.Field.stopCache()
};
Blockly.BlockSvg.prototype.updateColour = function() {
    if (this.disabled) return;
    var hexColour = this.getColour();
    var rgb = goog.color.hexToRgb(hexColour);
    if (this.isShadow()) {
        rgb = goog.color.lighten(rgb, .6);
        hexColour = goog.color.rgbArrayToHex(rgb);
        this.svgPathLight_.style.display = "none";
        this.svgPathDark_.setAttribute("fill", hexColour)
    } else {
        this.svgPathLight_.style.display = "";
        var hexLight = goog.color.rgbArrayToHex(goog.color.lighten(rgb, .3));
        var hexDark = goog.color.rgbArrayToHex(goog.color.darken(rgb, .2));
        this.svgPathLight_.setAttribute("stroke",
            hexLight);
        this.svgPathDark_.setAttribute("fill", hexDark)
    }
    this.svgPath_.setAttribute("fill", hexColour);
    var icons = this.getIcons();
    for (var i = 0; i < icons.length; i++) icons[i].updateColour();
    for (var x = 0, input; input = this.inputList[x]; x++)
        for (var y = 0, field; field = input.fieldRow[y]; y++) field.forceRerender()
};
Blockly.BlockSvg.prototype.updateDisabled = function() {
    if (this.disabled || this.getInheritedDisabled()) {
        var added = Blockly.utils.addClass(this.svgGroup_, "blocklyDisabled");
        if (added) this.svgPath_.setAttribute("fill", "url(#" + this.workspace.options.disabledPatternId + ")")
    } else {
        var removed = Blockly.utils.removeClass(this.svgGroup_, "blocklyDisabled");
        if (removed) this.updateColour()
    }
    var children = this.getChildren(false);
    for (var i = 0, child; child = children[i]; i++) child.updateDisabled()
};
Blockly.BlockSvg.prototype.getCommentText = function() {
    if (this.comment) {
        var comment = this.comment.getText();
        return comment.replace(/\s+$/, "").replace(/ +\n/g, "\n")
    }
    return ""
};
Blockly.BlockSvg.prototype.setCommentText = function(text) {
    var changedState = false;
    if (typeof text == "string") {
        if (!this.comment) {
            this.comment = new Blockly.Comment(this);
            changedState = true
        }
        this.comment.setText(text)
    } else if (this.comment) {
        this.comment.dispose();
        changedState = true
    }
    if (changedState && this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.setWarningText = function(text, opt_id) {
    if (!this.warningTextDb_) this.warningTextDb_ = Object.create(null);
    var id = opt_id || "";
    if (!id)
        for (var n in this.warningTextDb_) {
            clearTimeout(this.warningTextDb_[n]);
            delete this.warningTextDb_[n]
        } else if (this.warningTextDb_[id]) {
            clearTimeout(this.warningTextDb_[id]);
            delete this.warningTextDb_[id]
        } if (this.workspace.isDragging()) {
        var thisBlock = this;
        this.warningTextDb_[id] = setTimeout(function() {
            if (thisBlock.workspace) {
                delete thisBlock.warningTextDb_[id];
                thisBlock.setWarningText(text, id)
            }
        }, 100);
        return
    }
    if (this.isInFlyout) text = null;
    var parent = this.getSurroundParent();
    var collapsedParent = null;
    while (parent) {
        if (parent.isCollapsed()) collapsedParent = parent;
        parent = parent.getSurroundParent()
    }
    if (collapsedParent) collapsedParent.setWarningText(text, "collapsed " + this.id + " " + id);
    var changedState = false;
    if (typeof text == "string") {
        if (!this.warning) {
            this.warning = new Blockly.Warning(this);
            changedState = true
        }
        this.warning.setText(text, id)
    } else if (this.warning && !id) {
        this.warning.dispose();
        changedState = true
    } else if (this.warning) {
        var oldText = this.warning.getText();
        this.warning.setText("", id);
        var newText = this.warning.getText();
        if (!newText) this.warning.dispose();
        changedState = oldText != newText
    }
    if (changedState && this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.setMutator = function(mutator) {
    if (this.mutator && this.mutator !== mutator) this.mutator.dispose();
    if (mutator) {
        mutator.block_ = this;
        this.mutator = mutator;
        mutator.createIcon()
    }
};
Blockly.BlockSvg.prototype.setDisabled = function(disabled) {
    if (this.disabled != disabled) {
        Blockly.BlockSvg.superClass_.setDisabled.call(this, disabled);
        if (this.rendered) this.updateDisabled()
    }
};
Blockly.BlockSvg.prototype.setHighlighted = function(highlighted) {
    if (!this.rendered) return;
    if (highlighted) {
        this.svgPath_.setAttribute("filter", "url(#" + this.workspace.options.embossFilterId + ")");
        this.svgPathLight_.style.display = "none"
    } else {
        Blockly.utils.removeAttribute(this.svgPath_, "filter");
        delete this.svgPathLight_.style.display
    }
};
Blockly.BlockSvg.prototype.addSelect = function() {
    Blockly.utils.addClass(this.svgGroup_, "blocklySelected")
};
Blockly.BlockSvg.prototype.removeSelect = function() {
    Blockly.utils.removeClass(this.svgGroup_, "blocklySelected")
};
Blockly.BlockSvg.prototype.setDeleteStyle = function(enable) {
    if (enable) Blockly.utils.addClass(this.svgGroup_, "blocklyDraggingDelete");
    else Blockly.utils.removeClass(this.svgGroup_, "blocklyDraggingDelete")
};
Blockly.BlockSvg.prototype.setColour = function(colour) {
    Blockly.BlockSvg.superClass_.setColour.call(this, colour);
    if (this.rendered) this.updateColour()
};
Blockly.BlockSvg.prototype.bringToFront = function() {
    var block = this;
    do {
        var root = block.getSvgRoot();
        root.parentNode.appendChild(root);
        block = block.getParent()
    } while (block)
};
Blockly.BlockSvg.prototype.setPreviousStatement = function(newBoolean, opt_check) {
    Blockly.BlockSvg.superClass_.setPreviousStatement.call(this, newBoolean, opt_check);
    if (this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.setNextStatement = function(newBoolean, opt_check) {
    Blockly.BlockSvg.superClass_.setNextStatement.call(this, newBoolean, opt_check);
    if (this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.setOutput = function(newBoolean, opt_check) {
    Blockly.BlockSvg.superClass_.setOutput.call(this, newBoolean, opt_check);
    if (this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.setInputsInline = function(newBoolean) {
    Blockly.BlockSvg.superClass_.setInputsInline.call(this, newBoolean);
    if (this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.removeInput = function(name, opt_quiet) {
    Blockly.BlockSvg.superClass_.removeInput.call(this, name, opt_quiet);
    if (this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.moveNumberedInputBefore = function(inputIndex, refIndex) {
    Blockly.BlockSvg.superClass_.moveNumberedInputBefore.call(this, inputIndex, refIndex);
    if (this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
};
Blockly.BlockSvg.prototype.appendInput_ = function(type, name) {
    var input = Blockly.BlockSvg.superClass_.appendInput_.call(this, type, name);
    if (this.rendered) {
        this.render();
        this.bumpNeighbours_()
    }
    return input
};
Blockly.BlockSvg.prototype.getConnections_ = function(all) {
    var myConnections = [];
    if (all || this.rendered) {
        if (this.outputConnection) myConnections.push(this.outputConnection);
        if (this.previousConnection) myConnections.push(this.previousConnection);
        if (this.nextConnection) myConnections.push(this.nextConnection);
        if (all || !this.collapsed_)
            for (var i = 0, input; input = this.inputList[i]; i++)
                if (input.connection) myConnections.push(input.connection)
    }
    return myConnections
};
Blockly.BlockSvg.prototype.makeConnection_ = function(type) {
    return new Blockly.RenderedConnection(this, type)
};
Blockly.BlockSvg.prototype.bumpNeighbours_ = function() {
    if (!this.workspace) return;
    if (this.workspace.isDragging()) return;
    var rootBlock = this.getRootBlock();
    if (rootBlock.isInFlyout) return;
    var myConnections = this.getConnections_(false);
    for (var i = 0, connection; connection = myConnections[i]; i++) {
        if (connection.isConnected() && connection.isSuperior()) connection.targetBlock().bumpNeighbours_();
        var neighbours = connection.neighbours_(Blockly.SNAP_RADIUS);
        for (var j = 0, otherConnection; otherConnection = neighbours[j]; j++)
            if (!connection.isConnected() ||
                !otherConnection.isConnected())
                if (otherConnection.getSourceBlock().getRootBlock() != rootBlock)
                    if (connection.isSuperior()) otherConnection.bumpAwayFrom_(connection);
                    else connection.bumpAwayFrom_(otherConnection)
    }
};
Blockly.BlockSvg.prototype.scheduleSnapAndBump = function() {
    var block = this;
    var group = Blockly.Events.getGroup();
    setTimeout(function() {
        Blockly.Events.setGroup(group);
        block.snapToGrid();
        Blockly.Events.setGroup(false)
    }, Blockly.BUMP_DELAY / 2);
    setTimeout(function() {
        Blockly.Events.setGroup(group);
        block.bumpNeighbours_();
        Blockly.Events.setGroup(false)
    }, Blockly.BUMP_DELAY)
};
goog.provide("Blockly");
goog.require("Blockly.BlockSvg.render");
goog.require("Blockly.Events");
goog.require("Blockly.FieldAngle");
goog.require("Blockly.FieldCheckbox");
goog.require("Blockly.FieldColour");
goog.require("Blockly.FieldDropdown");
goog.require("Blockly.FieldImage");
goog.require("Blockly.FieldTextInput");
goog.require("Blockly.FieldNumber");
goog.require("Blockly.FieldVariable");
goog.require("Blockly.Generator");
goog.require("Blockly.Msg");
goog.require("Blockly.Procedures");
goog.require("Blockly.Toolbox");
goog.require("Blockly.Touch");
goog.require("Blockly.WidgetDiv");
goog.require("Blockly.WorkspaceSvg");
goog.require("Blockly.constants");
goog.require("Blockly.inject");
goog.require("Blockly.utils");
goog.require("Blockly.Xml");
goog.require("goog.color");
var CLOSURE_DEFINES = {
    "goog.DEBUG": false
};
Blockly.mainWorkspace = null;
Blockly.selected = null;
Blockly.draggingConnections_ = [];
Blockly.clipboardXml_ = null;
Blockly.clipboardSource_ = null;
Blockly.cache3dSupported_ = null;
Blockly.hueToRgb = function(hue) {
    return goog.color.hsvToHex(hue, Blockly.HSV_SATURATION, Blockly.HSV_VALUE * 255)
};
Blockly.svgSize = function(svg) {
    return {
        width: svg.cachedWidth_,
        height: svg.cachedHeight_
    }
};
Blockly.resizeSvgContents = function(workspace) {
    workspace.resizeContents()
};
Blockly.svgResize = function(workspace) {
    var mainWorkspace = workspace;
    while (mainWorkspace.options.parentWorkspace) mainWorkspace = mainWorkspace.options.parentWorkspace;
    var svg = mainWorkspace.getParentSvg();
    var div = svg.parentNode;
    if (!div) return;
    var width = div.offsetWidth;
    var height = div.offsetHeight;
    if (svg.cachedWidth_ != width) {
        svg.setAttribute("width", width + "px");
        svg.cachedWidth_ = width
    }
    if (svg.cachedHeight_ != height) {
        svg.setAttribute("height", height + "px");
        svg.cachedHeight_ = height
    }
    mainWorkspace.resize()
};
Blockly.onKeyDown_ = function(e) {
    var workspace = Blockly.mainWorkspace;
    if (workspace.options.readOnly || Blockly.utils.isTargetInput(e) || workspace.rendered && !workspace.isVisible()) return;
    var deleteBlock = false;
    if (e.keyCode == 27) Blockly.hideChaff();
    else if (e.keyCode == 8 || e.keyCode == 46) {
        e.preventDefault();
        if (workspace.isDragging()) return;
        if (Blockly.selected && Blockly.selected.isDeletable()) deleteBlock = true
    } else if (e.altKey || e.ctrlKey || e.metaKey) {
        if (workspace.isDragging()) return;
        if (Blockly.selected && Blockly.selected.isDeletable() &&
            Blockly.selected.isMovable())
            if (e.keyCode == 67) {
                Blockly.hideChaff();
                Blockly.copy_(Blockly.selected)
            } else if (e.keyCode == 88 && !Blockly.selected.workspace.isFlyout) {
            Blockly.copy_(Blockly.selected);
            deleteBlock = true
        }
        if (e.keyCode == 86) {
            if (Blockly.clipboardXml_) {
                Blockly.Events.setGroup(true);
                var workspace = Blockly.clipboardSource_;
                if (workspace.isFlyout) workspace = workspace.targetWorkspace;
                workspace.paste(Blockly.clipboardXml_);
                Blockly.Events.setGroup(false)
            }
        } else if (e.keyCode == 90) {
            Blockly.hideChaff();
            workspace.undo(e.shiftKey)
        }
    }
    if (deleteBlock &&
        !Blockly.selected.workspace.isFlyout) {
        Blockly.Events.setGroup(true);
        Blockly.hideChaff();
        Blockly.selected.dispose(true, true);
        Blockly.Events.setGroup(false)
    }
};
Blockly.copy_ = function(toCopy) {
    if (toCopy.isComment) var xml = toCopy.toXmlWithXY();
    else {
        var xml = Blockly.Xml.blockToDom(toCopy);
        Blockly.Xml.deleteNext(xml);
        var xy = toCopy.getRelativeToSurfaceXY();
        xml.setAttribute("x", toCopy.RTL ? -xy.x : xy.x);
        xml.setAttribute("y", xy.y)
    }
    Blockly.clipboardXml_ = xml;
    Blockly.clipboardSource_ = toCopy.workspace
};
Blockly.duplicate_ = function(toDuplicate) {
    var clipboardXml = Blockly.clipboardXml_;
    var clipboardSource = Blockly.clipboardSource_;
    Blockly.copy_(toDuplicate);
    toDuplicate.workspace.paste(Blockly.clipboardXml_);
    Blockly.clipboardXml_ = clipboardXml;
    Blockly.clipboardSource_ = clipboardSource
};
Blockly.onContextMenu_ = function(e) {
    if (!Blockly.utils.isTargetInput(e)) e.preventDefault()
};
Blockly.hideChaff = function(opt_allowToolbox) {
    Blockly.Tooltip.hide();
    Blockly.WidgetDiv.hide();
    if (!opt_allowToolbox) {
        var workspace = Blockly.getMainWorkspace();
        if (workspace.toolbox_ && workspace.toolbox_.flyout_ && workspace.toolbox_.flyout_.autoClose) workspace.toolbox_.clearSelection()
    }
};
Blockly.addChangeListener = function(func) {
    console.warn("Deprecated call to Blockly.addChangeListener, " + "use workspace.addChangeListener instead.");
    return Blockly.getMainWorkspace().addChangeListener(func)
};
Blockly.getMainWorkspace = function() {
    return Blockly.mainWorkspace
};
Blockly.alert = function(message, opt_callback) {
    window.alert(message);
    if (opt_callback) opt_callback()
};
Blockly.confirm = function(message, callback) {
    callback(window.confirm(message))
};
Blockly.prompt = function(message, defaultValue, callback) {
    callback(window.prompt(message, defaultValue))
};
Blockly.jsonInitFactory_ = function(jsonDef) {
    return function() {
        this.jsonInit(jsonDef)
    }
};
Blockly.defineBlocksWithJsonArray = function(jsonArray) {
    for (var i = 0; i < jsonArray.length; i++) {
        var elem = jsonArray[i];
        if (!elem) console.warn("Block definition #" + i + " in JSON array is " + elem + ". " + "Skipping.");
        else {
            var typename = elem.type;
            if (typename == null || typename === "") console.warn("Block definition #" + i + " in JSON array is missing a type attribute. Skipping.");
            else {
                if (Blockly.Blocks[typename]) console.warn("Block definition #" + i + " in JSON array" + ' overwrites prior definition of "' + typename + '".');
                Blockly.Blocks[typename] = {
                    init: Blockly.jsonInitFactory_(elem)
                }
            }
        }
    }
};
Blockly.bindEventWithChecks_ = function(node, name, thisObject, func, opt_noCaptureIdentifier, opt_noPreventDefault) {
    var handled = false;
    var wrapFunc = function(e) {
        var captureIdentifier = !opt_noCaptureIdentifier;
        var events = Blockly.Touch.splitEventByTouches(e);
        for (var i = 0, event; event = events[i]; i++) {
            if (captureIdentifier && !Blockly.Touch.shouldHandleEvent(event)) continue;
            Blockly.Touch.setClientFromTouch(event);
            if (thisObject) func.call(thisObject, event);
            else func(event);
            handled = true
        }
    };
    var bindData = [];
    if (goog.global.PointerEvent &&
        name in Blockly.Touch.TOUCH_MAP)
        for (var i = 0, type; type = Blockly.Touch.TOUCH_MAP[name][i]; i++) {
            node.addEventListener(type, wrapFunc, false);
            bindData.push([node, type, wrapFunc])
        } else {
            node.addEventListener(name, wrapFunc, false);
            bindData.push([node, name, wrapFunc]);
            if (name in Blockly.Touch.TOUCH_MAP) {
                var touchWrapFunc = function(e) {
                    wrapFunc(e);
                    var preventDef = !opt_noPreventDefault;
                    if (handled && preventDef) e.preventDefault()
                };
                for (var i = 0, type; type = Blockly.Touch.TOUCH_MAP[name][i]; i++) {
                    node.addEventListener(type, touchWrapFunc,
                        false);
                    bindData.push([node, type, touchWrapFunc])
                }
            }
        }
    return bindData
};
Blockly.bindEvent_ = function(node, name, thisObject, func) {
    var wrapFunc = function(e) {
        if (thisObject) func.call(thisObject, e);
        else func(e)
    };
    var bindData = [];
    var window = goog.global["window"];
    if (window && window.PointerEvent && name in Blockly.Touch.TOUCH_MAP)
        for (var i = 0, type; type = Blockly.Touch.TOUCH_MAP[name][i]; i++) {
            node.addEventListener(type, wrapFunc, false);
            bindData.push([node, type, wrapFunc])
        } else {
            node.addEventListener(name, wrapFunc, false);
            bindData.push([node, name, wrapFunc]);
            if (name in Blockly.Touch.TOUCH_MAP) {
                var touchWrapFunc =
                    function(e) {
                        if (e.changedTouches && e.changedTouches.length == 1) {
                            var touchPoint = e.changedTouches[0];
                            e.clientX = touchPoint.clientX;
                            e.clientY = touchPoint.clientY
                        }
                        wrapFunc(e);
                        e.preventDefault()
                    };
                for (var i = 0, type; type = Blockly.Touch.TOUCH_MAP[name][i]; i++) {
                    node.addEventListener(type, touchWrapFunc, false);
                    bindData.push([node, type, touchWrapFunc])
                }
            }
        }
    return bindData
};
Blockly.unbindEvent_ = function(bindData) {
    while (bindData.length) {
        var bindDatum = bindData.pop();
        var node = bindDatum[0];
        var name = bindDatum[1];
        var func = bindDatum[2];
        node.removeEventListener(name, func, false)
    }
    return func
};
Blockly.isNumber = function(str) {
    return /^\s*-?\d+(\.\d+)?\s*$/.test(str)
};
Blockly.checkBlockColourConstants = function() {
    Blockly.checkBlockColourConstant_("LOGIC_HUE", ["Blocks", "logic", "HUE"], undefined);
    Blockly.checkBlockColourConstant_("LOGIC_HUE", ["Constants", "Logic", "HUE"], 210);
    Blockly.checkBlockColourConstant_("LOOPS_HUE", ["Blocks", "loops", "HUE"], undefined);
    Blockly.checkBlockColourConstant_("LOOPS_HUE", ["Constants", "Loops", "HUE"], 120);
    Blockly.checkBlockColourConstant_("MATH_HUE", ["Blocks", "math", "HUE"], undefined);
    Blockly.checkBlockColourConstant_("MATH_HUE", ["Constants",
        "Math", "HUE"
    ], 230);
    Blockly.checkBlockColourConstant_("TEXTS_HUE", ["Blocks", "texts", "HUE"], undefined);
    Blockly.checkBlockColourConstant_("TEXTS_HUE", ["Constants", "Text", "HUE"], 160);
    Blockly.checkBlockColourConstant_("LISTS_HUE", ["Blocks", "lists", "HUE"], undefined);
    Blockly.checkBlockColourConstant_("LISTS_HUE", ["Constants", "Lists", "HUE"], 260);
    Blockly.checkBlockColourConstant_("COLOUR_HUE", ["Blocks", "colour", "HUE"], undefined);
    Blockly.checkBlockColourConstant_("COLOUR_HUE", ["Constants", "Colour", "HUE"], 20);
    Blockly.checkBlockColourConstant_("VARIABLES_HUE", ["Blocks", "variables", "HUE"], undefined);
    Blockly.checkBlockColourConstant_("VARIABLES_HUE", ["Constants", "Variables", "HUE"], 330);
    Blockly.checkBlockColourConstant_("VARIABLES_DYNAMIC_HUE", ["Constants", "VariablesDynamic", "HUE"], 310);
    Blockly.checkBlockColourConstant_("PROCEDURES_HUE", ["Blocks", "procedures", "HUE"], undefined)
};
Blockly.checkBlockColourConstant_ = function(msgName, blocklyNamePath, expectedValue) {
    var namePath = "Blockly";
    var value = Blockly;
    for (var i = 0; i < blocklyNamePath.length; ++i) {
        namePath += "." + blocklyNamePath[i];
        if (value) value = value[blocklyNamePath[i]]
    }
    if (value && value !== expectedValue) {
        var warningPattern = expectedValue === undefined ? '%1 has been removed. Use Blockly.Msg["%2"].' : '%1 is deprecated and unused. Override Blockly.Msg["%2"].';
        var warning = warningPattern.replace("%1", namePath).replace("%2", msgName);
        console.warn(warning)
    }
};
if (!goog.global["console"]) goog.global["console"] = {
    "log": function() {},
    "warn": function() {}
};
if (!goog.global["Blockly"]) goog.global["Blockly"] = {};
goog.global["Blockly"]["getMainWorkspace"] = Blockly.getMainWorkspace;
goog.global["Blockly"]["addChangeListener"] = Blockly.addChangeListener;
goog.provide("Blockly.Blocks");
Blockly.Blocks = new Object(null);
goog.provide("Blockly.Bubble");
goog.require("Blockly.Touch");
goog.require("Blockly.Workspace");
goog.require("goog.math.Coordinate");
goog.require("goog.userAgent");
Blockly.Bubble = function(workspace, content, shape, anchorXY, bubbleWidth, bubbleHeight) {
    this.workspace_ = workspace;
    this.content_ = content;
    this.shape_ = shape;
    var angle = Blockly.Bubble.ARROW_ANGLE;
    if (this.workspace_.RTL) angle = -angle;
    this.arrow_radians_ = Blockly.utils.toRadians(angle);
    var canvas = workspace.getBubbleCanvas();
    canvas.appendChild(this.createDom_(content, !!(bubbleWidth && bubbleHeight)));
    this.setAnchorLocation(anchorXY);
    if (!bubbleWidth || !bubbleHeight) {
        var bBox = this.content_.getBBox();
        bubbleWidth = bBox.width +
            2 * Blockly.Bubble.BORDER_WIDTH;
        bubbleHeight = bBox.height + 2 * Blockly.Bubble.BORDER_WIDTH
    }
    this.setBubbleSize(bubbleWidth, bubbleHeight);
    this.positionBubble_();
    this.renderArrow_();
    this.rendered_ = true;
    if (!workspace.options.readOnly) {
        Blockly.bindEventWithChecks_(this.bubbleBack_, "mousedown", this, this.bubbleMouseDown_);
        if (this.resizeGroup_) Blockly.bindEventWithChecks_(this.resizeGroup_, "mousedown", this, this.resizeMouseDown_)
    }
};
Blockly.Bubble.BORDER_WIDTH = 6;
Blockly.Bubble.ARROW_THICKNESS = 5;
Blockly.Bubble.ARROW_ANGLE = 20;
Blockly.Bubble.ARROW_BEND = 4;
Blockly.Bubble.ANCHOR_RADIUS = 8;
Blockly.Bubble.onMouseUpWrapper_ = null;
Blockly.Bubble.onMouseMoveWrapper_ = null;
Blockly.Bubble.prototype.resizeCallback_ = null;
Blockly.Bubble.unbindDragEvents_ = function() {
    if (Blockly.Bubble.onMouseUpWrapper_) {
        Blockly.unbindEvent_(Blockly.Bubble.onMouseUpWrapper_);
        Blockly.Bubble.onMouseUpWrapper_ = null
    }
    if (Blockly.Bubble.onMouseMoveWrapper_) {
        Blockly.unbindEvent_(Blockly.Bubble.onMouseMoveWrapper_);
        Blockly.Bubble.onMouseMoveWrapper_ = null
    }
};
Blockly.Bubble.bubbleMouseUp_ = function() {
    Blockly.Touch.clearTouchIdentifier();
    Blockly.Bubble.unbindDragEvents_()
};
Blockly.Bubble.prototype.rendered_ = false;
Blockly.Bubble.prototype.anchorXY_ = null;
Blockly.Bubble.prototype.relativeLeft_ = 0;
Blockly.Bubble.prototype.relativeTop_ = 0;
Blockly.Bubble.prototype.width_ = 0;
Blockly.Bubble.prototype.height_ = 0;
Blockly.Bubble.prototype.autoLayout_ = true;
Blockly.Bubble.prototype.createDom_ = function(content, hasResize) {
    this.bubbleGroup_ = Blockly.utils.createSvgElement("g", {}, null);
    var filter = {
        "filter": "url(#" + this.workspace_.options.embossFilterId + ")"
    };
    if (goog.userAgent.getUserAgentString().indexOf("JavaFX") != -1) filter = {};
    var bubbleEmboss = Blockly.utils.createSvgElement("g", filter, this.bubbleGroup_);
    this.bubbleArrow_ = Blockly.utils.createSvgElement("path", {}, bubbleEmboss);
    this.bubbleBack_ = Blockly.utils.createSvgElement("rect", {
        "class": "blocklyDraggable",
        "x": 0,
        "y": 0,
        "rx": Blockly.Bubble.BORDER_WIDTH,
        "ry": Blockly.Bubble.BORDER_WIDTH
    }, bubbleEmboss);
    if (hasResize) {
        this.resizeGroup_ = Blockly.utils.createSvgElement("g", {
            "class": this.workspace_.RTL ? "blocklyResizeSW" : "blocklyResizeSE"
        }, this.bubbleGroup_);
        var resizeSize = 2 * Blockly.Bubble.BORDER_WIDTH;
        Blockly.utils.createSvgElement("polygon", {
            "points": "0,x x,x x,0".replace(/x/g, resizeSize.toString())
        }, this.resizeGroup_);
        Blockly.utils.createSvgElement("line", {
            "class": "blocklyResizeLine",
            "x1": resizeSize / 3,
            "y1": resizeSize -
                1,
            "x2": resizeSize - 1,
            "y2": resizeSize / 3
        }, this.resizeGroup_);
        Blockly.utils.createSvgElement("line", {
            "class": "blocklyResizeLine",
            "x1": resizeSize * 2 / 3,
            "y1": resizeSize - 1,
            "x2": resizeSize - 1,
            "y2": resizeSize * 2 / 3
        }, this.resizeGroup_)
    } else this.resizeGroup_ = null;
    this.bubbleGroup_.appendChild(content);
    return this.bubbleGroup_
};
Blockly.Bubble.prototype.getSvgRoot = function() {
    return this.bubbleGroup_
};
Blockly.Bubble.prototype.setSvgId = function(id) {
    if (this.bubbleGroup_.dataset) this.bubbleGroup_.dataset.blockId = id
};
Blockly.Bubble.prototype.bubbleMouseDown_ = function(e) {
    var gesture = this.workspace_.getGesture(e);
    if (gesture) gesture.handleBubbleStart(e, this)
};
Blockly.Bubble.prototype.showContextMenu_ = function(_e) {};
Blockly.Bubble.prototype.isDeletable = function() {
    return false
};
Blockly.Bubble.prototype.resizeMouseDown_ = function(e) {
    this.promote_();
    Blockly.Bubble.unbindDragEvents_();
    if (Blockly.utils.isRightButton(e)) {
        e.stopPropagation();
        return
    }
    this.workspace_.startDrag(e, new goog.math.Coordinate(this.workspace_.RTL ? -this.width_ : this.width_, this.height_));
    Blockly.Bubble.onMouseUpWrapper_ = Blockly.bindEventWithChecks_(document, "mouseup", this, Blockly.Bubble.bubbleMouseUp_);
    Blockly.Bubble.onMouseMoveWrapper_ = Blockly.bindEventWithChecks_(document, "mousemove", this, this.resizeMouseMove_);
    Blockly.hideChaff();
    e.stopPropagation()
};
Blockly.Bubble.prototype.resizeMouseMove_ = function(e) {
    this.autoLayout_ = false;
    var newXY = this.workspace_.moveDrag(e);
    this.setBubbleSize(this.workspace_.RTL ? -newXY.x : newXY.x, newXY.y);
    if (this.workspace_.RTL) this.positionBubble_()
};
Blockly.Bubble.prototype.registerResizeEvent = function(callback) {
    this.resizeCallback_ = callback
};
Blockly.Bubble.prototype.promote_ = function() {
    var svgGroup = this.bubbleGroup_.parentNode;
    if (svgGroup.lastChild !== this.bubbleGroup_) {
        svgGroup.appendChild(this.bubbleGroup_);
        return true
    }
    return false
};
Blockly.Bubble.prototype.setAnchorLocation = function(xy) {
    this.anchorXY_ = xy;
    if (this.rendered_) this.positionBubble_()
};
Blockly.Bubble.prototype.layoutBubble_ = function() {
    var relativeLeft = -this.width_ / 4;
    var relativeTop = -this.height_ - Blockly.BlockSvg.MIN_BLOCK_Y;
    var metrics = this.workspace_.getMetrics();
    metrics.viewWidth /= this.workspace_.scale;
    metrics.viewLeft /= this.workspace_.scale;
    var anchorX = this.anchorXY_.x;
    if (this.workspace_.RTL)
        if (anchorX - metrics.viewLeft - relativeLeft - this.width_ < Blockly.Scrollbar.scrollbarThickness) relativeLeft = anchorX - metrics.viewLeft - this.width_ - Blockly.Scrollbar.scrollbarThickness;
        else {
            if (anchorX -
                metrics.viewLeft - relativeLeft > metrics.viewWidth) relativeLeft = anchorX - metrics.viewLeft - metrics.viewWidth
        }
    else if (anchorX + relativeLeft < metrics.viewLeft) relativeLeft = metrics.viewLeft - anchorX;
    else if (metrics.viewLeft + metrics.viewWidth < anchorX + relativeLeft + this.width_ + Blockly.BlockSvg.SEP_SPACE_X + Blockly.Scrollbar.scrollbarThickness) relativeLeft = metrics.viewLeft + metrics.viewWidth - anchorX - this.width_ - Blockly.Scrollbar.scrollbarThickness;
    if (this.anchorXY_.y + relativeTop < metrics.viewTop) {
        var bBox = this.shape_.getBBox();
        relativeTop = bBox.height
    }
    this.relativeLeft_ = relativeLeft;
    this.relativeTop_ = relativeTop
};
Blockly.Bubble.prototype.positionBubble_ = function() {
    var left = this.anchorXY_.x;
    if (this.workspace_.RTL) left -= this.relativeLeft_ + this.width_;
    else left += this.relativeLeft_;
    var top = this.relativeTop_ + this.anchorXY_.y;
    this.moveTo(left, top)
};
Blockly.Bubble.prototype.moveTo = function(x, y) {
    this.bubbleGroup_.setAttribute("transform", "translate(" + x + "," + y + ")")
};
Blockly.Bubble.prototype.getBubbleSize = function() {
    return {
        width: this.width_,
        height: this.height_
    }
};
Blockly.Bubble.prototype.setBubbleSize = function(width, height) {
    var doubleBorderWidth = 2 * Blockly.Bubble.BORDER_WIDTH;
    width = Math.max(width, doubleBorderWidth + 45);
    height = Math.max(height, doubleBorderWidth + 20);
    this.width_ = width;
    this.height_ = height;
    this.bubbleBack_.setAttribute("width", width);
    this.bubbleBack_.setAttribute("height", height);
    if (this.resizeGroup_)
        if (this.workspace_.RTL) {
            var resizeSize = 2 * Blockly.Bubble.BORDER_WIDTH;
            this.resizeGroup_.setAttribute("transform", "translate(" + resizeSize + "," + (height -
                doubleBorderWidth) + ") scale(-1 1)")
        } else this.resizeGroup_.setAttribute("transform", "translate(" + (width - doubleBorderWidth) + "," + (height - doubleBorderWidth) + ")");
    if (this.rendered_) {
        if (this.autoLayout_) this.layoutBubble_();
        this.positionBubble_();
        this.renderArrow_()
    }
    if (this.resizeCallback_) this.resizeCallback_()
};
Blockly.Bubble.prototype.renderArrow_ = function() {
    var steps = [];
    var relBubbleX = this.width_ / 2;
    var relBubbleY = this.height_ / 2;
    var relAnchorX = -this.relativeLeft_;
    var relAnchorY = -this.relativeTop_;
    if (relBubbleX == relAnchorX && relBubbleY == relAnchorY) steps.push("M " + relBubbleX + "," + relBubbleY);
    else {
        var rise = relAnchorY - relBubbleY;
        var run = relAnchorX - relBubbleX;
        if (this.workspace_.RTL) run *= -1;
        var hypotenuse = Math.sqrt(rise * rise + run * run);
        var angle = Math.acos(run / hypotenuse);
        if (rise < 0) angle = 2 * Math.PI - angle;
        var rightAngle =
            angle + Math.PI / 2;
        if (rightAngle > Math.PI * 2) rightAngle -= Math.PI * 2;
        var rightRise = Math.sin(rightAngle);
        var rightRun = Math.cos(rightAngle);
        var bubbleSize = this.getBubbleSize();
        var thickness = (bubbleSize.width + bubbleSize.height) / Blockly.Bubble.ARROW_THICKNESS;
        thickness = Math.min(thickness, bubbleSize.width, bubbleSize.height) / 4;
        var backoffRatio = 1 - Blockly.Bubble.ANCHOR_RADIUS / hypotenuse;
        relAnchorX = relBubbleX + backoffRatio * run;
        relAnchorY = relBubbleY + backoffRatio * rise;
        var baseX1 = relBubbleX + thickness * rightRun;
        var baseY1 =
            relBubbleY + thickness * rightRise;
        var baseX2 = relBubbleX - thickness * rightRun;
        var baseY2 = relBubbleY - thickness * rightRise;
        var swirlAngle = angle + this.arrow_radians_;
        if (swirlAngle > Math.PI * 2) swirlAngle -= Math.PI * 2;
        var swirlRise = Math.sin(swirlAngle) * hypotenuse / Blockly.Bubble.ARROW_BEND;
        var swirlRun = Math.cos(swirlAngle) * hypotenuse / Blockly.Bubble.ARROW_BEND;
        steps.push("M" + baseX1 + "," + baseY1);
        steps.push("C" + (baseX1 + swirlRun) + "," + (baseY1 + swirlRise) + " " + relAnchorX + "," + relAnchorY + " " + relAnchorX + "," + relAnchorY);
        steps.push("C" +
            relAnchorX + "," + relAnchorY + " " + (baseX2 + swirlRun) + "," + (baseY2 + swirlRise) + " " + baseX2 + "," + baseY2)
    }
    steps.push("z");
    this.bubbleArrow_.setAttribute("d", steps.join(" "))
};
Blockly.Bubble.prototype.setColour = function(hexColour) {
    this.bubbleBack_.setAttribute("fill", hexColour);
    this.bubbleArrow_.setAttribute("fill", hexColour)
};
Blockly.Bubble.prototype.dispose = function() {
    Blockly.Bubble.unbindDragEvents_();
    Blockly.utils.removeNode(this.bubbleGroup_);
    this.bubbleGroup_ = null;
    this.bubbleArrow_ = null;
    this.bubbleBack_ = null;
    this.resizeGroup_ = null;
    this.workspace_ = null;
    this.content_ = null;
    this.shape_ = null
};
Blockly.Bubble.prototype.moveDuringDrag = function(dragSurface, newLoc) {
    if (dragSurface) dragSurface.translateSurface(newLoc.x, newLoc.y);
    else this.moveTo(newLoc.x, newLoc.y);
    if (this.workspace_.RTL) this.relativeLeft_ = this.anchorXY_.x - newLoc.x - this.width_;
    else this.relativeLeft_ = newLoc.x - this.anchorXY_.x;
    this.relativeTop_ = newLoc.y - this.anchorXY_.y;
    this.renderArrow_()
};
Blockly.Bubble.prototype.getRelativeToSurfaceXY = function() {
    return new goog.math.Coordinate(this.anchorXY_.x + this.relativeLeft_, this.anchorXY_.y + this.relativeTop_)
};
Blockly.Bubble.prototype.setAutoLayout = function(enable) {
    this.autoLayout_ = enable
};
goog.provide("Blockly.BubbleDragger");
goog.require("Blockly.Bubble");
goog.require("Blockly.Events.CommentMove");
goog.require("Blockly.utils");
goog.require("Blockly.WorkspaceCommentSvg");
goog.require("goog.math.Coordinate");
Blockly.BubbleDragger = function(bubble, workspace) {
    this.draggingBubble_ = bubble;
    this.workspace_ = workspace;
    this.deleteArea_ = null;
    this.wouldDeleteBubble_ = false;
    this.startXY_ = this.draggingBubble_.getRelativeToSurfaceXY();
    this.dragSurface_ = Blockly.utils.is3dSupported() && !!workspace.getBlockDragSurface() ? workspace.getBlockDragSurface() : null
};
Blockly.BubbleDragger.prototype.dispose = function() {
    this.draggingBubble_ = null;
    this.workspace_ = null;
    this.dragSurface_ = null
};
Blockly.BubbleDragger.prototype.startBubbleDrag = function() {
    if (!Blockly.Events.getGroup()) Blockly.Events.setGroup(true);
    this.workspace_.setResizesEnabled(false);
    this.draggingBubble_.setAutoLayout(false);
    if (this.dragSurface_) this.moveToDragSurface_();
    this.draggingBubble_.setDragging && this.draggingBubble_.setDragging(true);
    var toolbox = this.workspace_.getToolbox();
    if (toolbox) {
        var style = this.draggingBubble_.isDeletable() ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
        toolbox.addStyle(style)
    }
};
Blockly.BubbleDragger.prototype.dragBubble = function(e, currentDragDeltaXY) {
    var delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);
    var newLoc = goog.math.Coordinate.sum(this.startXY_, delta);
    this.draggingBubble_.moveDuringDrag(this.dragSurface_, newLoc);
    if (this.draggingBubble_.isDeletable()) {
        this.deleteArea_ = this.workspace_.isDeleteArea(e);
        this.updateCursorDuringBubbleDrag_()
    }
};
Blockly.BubbleDragger.prototype.maybeDeleteBubble_ = function() {
    var trashcan = this.workspace_.trashcan;
    if (this.wouldDeleteBubble_) {
        if (trashcan) setTimeout(trashcan.close.bind(trashcan), 100);
        this.fireMoveEvent_();
        this.draggingBubble_.dispose(false, true)
    } else if (trashcan) trashcan.close();
    return this.wouldDeleteBubble_
};
Blockly.BubbleDragger.prototype.updateCursorDuringBubbleDrag_ = function() {
    this.wouldDeleteBubble_ = this.deleteArea_ != Blockly.DELETE_AREA_NONE;
    var trashcan = this.workspace_.trashcan;
    if (this.wouldDeleteBubble_) {
        this.draggingBubble_.setDeleteStyle(true);
        if (this.deleteArea_ == Blockly.DELETE_AREA_TRASH && trashcan) trashcan.setOpen_(true)
    } else {
        this.draggingBubble_.setDeleteStyle(false);
        if (trashcan) trashcan.setOpen_(false)
    }
};
Blockly.BubbleDragger.prototype.endBubbleDrag = function(e, currentDragDeltaXY) {
    this.dragBubble(e, currentDragDeltaXY);
    var delta = this.pixelsToWorkspaceUnits_(currentDragDeltaXY);
    var newLoc = goog.math.Coordinate.sum(this.startXY_, delta);
    this.draggingBubble_.moveTo(newLoc.x, newLoc.y);
    var deleted = this.maybeDeleteBubble_();
    if (!deleted) {
        if (this.dragSurface_) this.dragSurface_.clearAndHide(this.workspace_.getBubbleCanvas());
        this.draggingBubble_.setDragging && this.draggingBubble_.setDragging(false);
        this.fireMoveEvent_()
    }
    this.workspace_.setResizesEnabled(true);
    if (this.workspace_.toolbox_) {
        var style = this.draggingBubble_.isDeletable() ? "blocklyToolboxDelete" : "blocklyToolboxGrab";
        this.workspace_.toolbox_.removeStyle(style)
    }
    Blockly.Events.setGroup(false)
};
Blockly.BubbleDragger.prototype.fireMoveEvent_ = function() {
    if (this.draggingBubble_.isComment) {
        var event = new Blockly.Events.CommentMove(this.draggingBubble_);
        event.setOldCoordinate(this.startXY_);
        event.recordNew();
        Blockly.Events.fire(event)
    }
    return
};
Blockly.BubbleDragger.prototype.pixelsToWorkspaceUnits_ = function(pixelCoord) {
    var result = new goog.math.Coordinate(pixelCoord.x / this.workspace_.scale, pixelCoord.y / this.workspace_.scale);
    if (this.workspace_.isMutator) {
        var mainScale = this.workspace_.options.parentWorkspace.scale;
        result = result.scale(1 / mainScale)
    }
    return result
};
Blockly.BubbleDragger.prototype.moveToDragSurface_ = function() {
    this.draggingBubble_.moveTo(0, 0);
    this.dragSurface_.translateSurface(this.startXY_.x, this.startXY_.y);
    this.dragSurface_.setBlocksAndShow(this.draggingBubble_.getSvgRoot())
};
goog.provide("Blockly.Comment");
goog.require("Blockly.Bubble");
goog.require("Blockly.Events.BlockChange");
goog.require("Blockly.Events.Ui");
goog.require("Blockly.Icon");
goog.require("Blockly.utils");
goog.require("goog.userAgent");
Blockly.Comment = function(block) {
    Blockly.Comment.superClass_.constructor.call(this, block);
    this.createIcon()
};
goog.inherits(Blockly.Comment, Blockly.Icon);
Blockly.Comment.prototype.text_ = "";
Blockly.Comment.prototype.width_ = 160;
Blockly.Comment.prototype.height_ = 80;
Blockly.Comment.prototype.drawIcon_ = function(group) {
    Blockly.utils.createSvgElement("circle", {
        "class": "blocklyIconShape",
        "r": "8",
        "cx": "8",
        "cy": "8"
    }, group);
    Blockly.utils.createSvgElement("path", {
        "class": "blocklyIconSymbol",
        "d": "m6.8,10h2c0.003,-0.617 0.271,-0.962 0.633,-1.266 2.875,-2.405" + "0.607,-5.534 -3.765,-3.874v1.7c3.12,-1.657 3.698,0.118 2.336,1.25" + "-1.201,0.998 -1.201,1.528 -1.204,2.19z"
    }, group);
    Blockly.utils.createSvgElement("rect", {
        "class": "blocklyIconSymbol",
        "x": "6.8",
        "y": "10.78",
        "height": "2",
        "width": "2"
    }, group)
};
Blockly.Comment.prototype.createEditor_ = function() {
    this.foreignObject_ = Blockly.utils.createSvgElement("foreignObject", {
        "x": Blockly.Bubble.BORDER_WIDTH,
        "y": Blockly.Bubble.BORDER_WIDTH
    }, null);
    var body = document.createElementNS(Blockly.HTML_NS, "body");
    body.setAttribute("xmlns", Blockly.HTML_NS);
    body.className = "blocklyMinimalBody";
    var textarea = document.createElementNS(Blockly.HTML_NS, "textarea");
    textarea.className = "blocklyCommentTextarea";
    textarea.setAttribute("dir", this.block_.RTL ? "RTL" : "LTR");
    body.appendChild(textarea);
    this.textarea_ = textarea;
    this.foreignObject_.appendChild(body);
    Blockly.bindEventWithChecks_(textarea, "mouseup", this, this.textareaFocus_, true, true);
    Blockly.bindEventWithChecks_(textarea, "wheel", this, function(e) {
        e.stopPropagation()
    });
    Blockly.bindEventWithChecks_(textarea, "change", this, function(_e) {
        if (this.text_ != textarea.value) {
            Blockly.Events.fire(new Blockly.Events.BlockChange(this.block_, "comment", null, this.text_, textarea.value));
            this.text_ = textarea.value
        }
    });
    setTimeout(function() {
            textarea.focus()
        },
        0);
    return this.foreignObject_
};
Blockly.Comment.prototype.updateEditable = function() {
    if (this.isVisible()) {
        this.setVisible(false);
        this.setVisible(true)
    }
    Blockly.Icon.prototype.updateEditable.call(this)
};
Blockly.Comment.prototype.resizeBubble_ = function() {
    if (this.isVisible()) {
        var size = this.bubble_.getBubbleSize();
        var doubleBorderWidth = 2 * Blockly.Bubble.BORDER_WIDTH;
        this.foreignObject_.setAttribute("width", size.width - doubleBorderWidth);
        this.foreignObject_.setAttribute("height", size.height - doubleBorderWidth);
        this.textarea_.style.width = size.width - doubleBorderWidth - 4 + "px";
        this.textarea_.style.height = size.height - doubleBorderWidth - 4 + "px"
    }
};
Blockly.Comment.prototype.setVisible = function(visible) {
    if (visible == this.isVisible()) return;
    Blockly.Events.fire(new Blockly.Events.Ui(this.block_, "commentOpen", !visible, visible));
    if (!this.block_.isEditable() && !this.textarea_ || goog.userAgent.IE) {
        Blockly.Warning.prototype.setVisible.call(this, visible);
        return
    }
    var text = this.getText();
    var size = this.getBubbleSize();
    if (visible) {
        this.bubble_ = new Blockly.Bubble(this.block_.workspace, this.createEditor_(), this.block_.svgPath_, this.iconXY_, this.width_, this.height_);
        this.bubble_.setSvgId(this.block_.id);
        this.bubble_.registerResizeEvent(this.resizeBubble_.bind(this));
        this.updateColour()
    } else {
        this.bubble_.dispose();
        this.bubble_ = null;
        this.textarea_ = null;
        this.foreignObject_ = null
    }
    this.setText(text);
    this.setBubbleSize(size.width, size.height)
};
Blockly.Comment.prototype.textareaFocus_ = function(_e) {
    if (this.bubble_.promote_()) this.textarea_.focus()
};
Blockly.Comment.prototype.getBubbleSize = function() {
    if (this.isVisible()) return this.bubble_.getBubbleSize();
    else return {
        width: this.width_,
        height: this.height_
    }
};
Blockly.Comment.prototype.setBubbleSize = function(width, height) {
    if (this.textarea_) this.bubble_.setBubbleSize(width, height);
    else {
        this.width_ = width;
        this.height_ = height
    }
};
Blockly.Comment.prototype.getText = function() {
    return this.textarea_ ? this.textarea_.value : this.text_
};
Blockly.Comment.prototype.setText = function(text) {
    if (this.text_ != text) {
        Blockly.Events.fire(new Blockly.Events.BlockChange(this.block_, "comment", null, this.text_, text));
        this.text_ = text
    }
    if (this.textarea_) this.textarea_.value = text
};
Blockly.Comment.prototype.dispose = function() {
    if (Blockly.Events.isEnabled()) this.setText("");
    this.block_.comment = null;
    Blockly.Icon.prototype.dispose.call(this)
};
goog.provide("Blockly.Connection");
goog.require("Blockly.Events.BlockMove");
goog.require("Blockly.Xml");
Blockly.Connection = function(source, type) {
    this.sourceBlock_ = source;
    this.type = type;
    if (source.workspace.connectionDBList) {
        this.db_ = source.workspace.connectionDBList[type];
        this.dbOpposite_ = source.workspace.connectionDBList[Blockly.OPPOSITE_TYPE[type]];
        this.hidden_ = !this.db_
    }
};
Blockly.Connection.CAN_CONNECT = 0;
Blockly.Connection.REASON_SELF_CONNECTION = 1;
Blockly.Connection.REASON_WRONG_TYPE = 2;
Blockly.Connection.REASON_TARGET_NULL = 3;
Blockly.Connection.REASON_CHECKS_FAILED = 4;
Blockly.Connection.REASON_DIFFERENT_WORKSPACES = 5;
Blockly.Connection.REASON_SHADOW_PARENT = 6;
Blockly.Connection.prototype.targetConnection = null;
Blockly.Connection.prototype.check_ = null;
Blockly.Connection.prototype.shadowDom_ = null;
Blockly.Connection.prototype.x_ = 0;
Blockly.Connection.prototype.y_ = 0;
Blockly.Connection.prototype.inDB_ = false;
Blockly.Connection.prototype.db_ = null;
Blockly.Connection.prototype.dbOpposite_ = null;
Blockly.Connection.prototype.hidden_ = null;
Blockly.Connection.prototype.connect_ = function(childConnection) {
    var parentConnection = this;
    var parentBlock = parentConnection.getSourceBlock();
    var childBlock = childConnection.getSourceBlock();
    if (childConnection.isConnected()) childConnection.disconnect();
    if (parentConnection.isConnected()) {
        var orphanBlock = parentConnection.targetBlock();
        var shadowDom = parentConnection.getShadowDom();
        parentConnection.setShadowDom(null);
        if (orphanBlock.isShadow()) {
            shadowDom = Blockly.Xml.blockToDom(orphanBlock);
            orphanBlock.dispose();
            orphanBlock = null
        } else if (parentConnection.type == Blockly.INPUT_VALUE) {
            if (!orphanBlock.outputConnection) throw Error("Orphan block does not have an output connection.");
            var connection = Blockly.Connection.lastConnectionInRow_(childBlock, orphanBlock);
            if (connection) {
                orphanBlock.outputConnection.connect(connection);
                orphanBlock = null
            }
        } else if (parentConnection.type == Blockly.NEXT_STATEMENT) {
            if (!orphanBlock.previousConnection) throw Error("Orphan block does not have a previous connection.");
            var newBlock = childBlock;
            while (newBlock.nextConnection) {
                var nextBlock = newBlock.getNextBlock();
                if (nextBlock && !nextBlock.isShadow()) newBlock = nextBlock;
                else {
                    if (orphanBlock.previousConnection.checkType_(newBlock.nextConnection)) {
                        newBlock.nextConnection.connect(orphanBlock.previousConnection);
                        orphanBlock = null
                    }
                    break
                }
            }
        }
        if (orphanBlock) {
            parentConnection.disconnect();
            if (Blockly.Events.recordUndo) {
                var group = Blockly.Events.getGroup();
                setTimeout(function() {
                    if (orphanBlock.workspace && !orphanBlock.getParent()) {
                        Blockly.Events.setGroup(group);
                        if (orphanBlock.outputConnection) orphanBlock.outputConnection.bumpAwayFrom_(parentConnection);
                        else if (orphanBlock.previousConnection) orphanBlock.previousConnection.bumpAwayFrom_(parentConnection);
                        Blockly.Events.setGroup(false)
                    }
                }, Blockly.BUMP_DELAY)
            }
        }
        parentConnection.setShadowDom(shadowDom)
    }
    var event;
    if (Blockly.Events.isEnabled()) event = new Blockly.Events.BlockMove(childBlock);
    Blockly.Connection.connectReciprocally_(parentConnection, childConnection);
    childBlock.setParent(parentBlock);
    if (event) {
        event.recordNew();
        Blockly.Events.fire(event)
    }
};
Blockly.Connection.prototype.dispose = function() {
    if (this.isConnected()) throw Error("Disconnect connection before disposing of it.");
    if (this.inDB_) this.db_.removeConnection_(this);
    this.db_ = null;
    this.dbOpposite_ = null
};
Blockly.Connection.prototype.getSourceBlock = function() {
    return this.sourceBlock_
};
Blockly.Connection.prototype.isSuperior = function() {
    return this.type == Blockly.INPUT_VALUE || this.type == Blockly.NEXT_STATEMENT
};
Blockly.Connection.prototype.isConnected = function() {
    return !!this.targetConnection
};
Blockly.Connection.prototype.canConnectWithReason_ = function(target) {
    if (!target) return Blockly.Connection.REASON_TARGET_NULL;
    if (this.isSuperior()) {
        var blockA = this.sourceBlock_;
        var blockB = target.getSourceBlock()
    } else {
        var blockB = this.sourceBlock_;
        var blockA = target.getSourceBlock()
    }
    if (blockA && blockA == blockB) return Blockly.Connection.REASON_SELF_CONNECTION;
    else if (target.type != Blockly.OPPOSITE_TYPE[this.type]) return Blockly.Connection.REASON_WRONG_TYPE;
    else if (blockA && blockB && blockA.workspace !== blockB.workspace) return Blockly.Connection.REASON_DIFFERENT_WORKSPACES;
    else if (!this.checkType_(target)) return Blockly.Connection.REASON_CHECKS_FAILED;
    else if (blockA.isShadow() && !blockB.isShadow()) return Blockly.Connection.REASON_SHADOW_PARENT;
    return Blockly.Connection.CAN_CONNECT
};
Blockly.Connection.prototype.checkConnection_ = function(target) {
    switch (this.canConnectWithReason_(target)) {
        case Blockly.Connection.CAN_CONNECT:
            break;
        case Blockly.Connection.REASON_SELF_CONNECTION:
            throw Error("Attempted to connect a block to itself.");
        case Blockly.Connection.REASON_DIFFERENT_WORKSPACES:
            throw Error("Blocks not on same workspace.");
        case Blockly.Connection.REASON_WRONG_TYPE:
            throw Error("Attempt to connect incompatible types.");
        case Blockly.Connection.REASON_TARGET_NULL:
            throw Error("Target connection is null.");
        case Blockly.Connection.REASON_CHECKS_FAILED:
            var msg = "Connection checks failed. ";
            msg += this + " expected " + this.check_ + ", found " + target.check_;
            throw Error(msg);
        case Blockly.Connection.REASON_SHADOW_PARENT:
            throw Error("Connecting non-shadow to shadow block.");
        default:
            throw Error("Unknown connection failure: this should never happen!");
    }
};
Blockly.Connection.prototype.isConnectionAllowed = function(candidate) {
    var canConnect = this.canConnectWithReason_(candidate);
    if (canConnect != Blockly.Connection.CAN_CONNECT) return false;
    switch (candidate.type) {
        case Blockly.PREVIOUS_STATEMENT:
            if (candidate.isConnected() || this.isConnected()) return false;
            break;
        case Blockly.OUTPUT_VALUE:
            if (candidate.isConnected() || this.isConnected()) return false;
            break;
        case Blockly.INPUT_VALUE:
            if (candidate.targetConnection && !candidate.targetBlock().isMovable() && !candidate.targetBlock().isShadow()) return false;
            break;
        case Blockly.NEXT_STATEMENT:
            if (candidate.isConnected() && !this.sourceBlock_.nextConnection && !candidate.targetBlock().isShadow() && candidate.targetBlock().nextConnection) return false;
            break;
        default:
            throw Error("Unknown connection type in isConnectionAllowed");
    }
    if (Blockly.draggingConnections_.indexOf(candidate) != -1) return false;
    return true
};
Blockly.Connection.prototype.connect = function(otherConnection) {
    if (this.targetConnection == otherConnection) return;
    this.checkConnection_(otherConnection);
    if (this.isSuperior()) this.connect_(otherConnection);
    else otherConnection.connect_(this)
};
Blockly.Connection.connectReciprocally_ = function(first, second) {
    if (!first || !second) throw Error("Cannot connect null connections.");
    first.targetConnection = second;
    second.targetConnection = first
};
Blockly.Connection.singleConnection_ = function(block, orphanBlock) {
    var connection = false;
    for (var i = 0; i < block.inputList.length; i++) {
        var thisConnection = block.inputList[i].connection;
        if (thisConnection && thisConnection.type == Blockly.INPUT_VALUE && orphanBlock.outputConnection.checkType_(thisConnection)) {
            if (connection) return null;
            connection = thisConnection
        }
    }
    return connection
};
Blockly.Connection.lastConnectionInRow_ = function(startBlock, orphanBlock) {
    var newBlock = startBlock;
    var connection;
    while (connection = Blockly.Connection.singleConnection_(newBlock, orphanBlock)) {
        newBlock = connection.targetBlock();
        if (!newBlock || newBlock.isShadow()) return connection
    }
    return null
};
Blockly.Connection.prototype.disconnect = function() {
    var otherConnection = this.targetConnection;
    if (!otherConnection) throw Error("Source connection not connected.");
    if (otherConnection.targetConnection != this) throw Error("Target connection not connected to source connection.");
    var parentBlock, childBlock, parentConnection;
    if (this.isSuperior()) {
        parentBlock = this.sourceBlock_;
        childBlock = otherConnection.getSourceBlock();
        parentConnection = this
    } else {
        parentBlock = otherConnection.getSourceBlock();
        childBlock = this.sourceBlock_;
        parentConnection = otherConnection
    }
    this.disconnectInternal_(parentBlock, childBlock);
    parentConnection.respawnShadow_()
};
Blockly.Connection.prototype.disconnectInternal_ = function(parentBlock, childBlock) {
    var event;
    if (Blockly.Events.isEnabled()) event = new Blockly.Events.BlockMove(childBlock);
    var otherConnection = this.targetConnection;
    otherConnection.targetConnection = null;
    this.targetConnection = null;
    childBlock.setParent(null);
    if (event) {
        event.recordNew();
        Blockly.Events.fire(event)
    }
};
Blockly.Connection.prototype.respawnShadow_ = function() {
    var parentBlock = this.getSourceBlock();
    var shadow = this.getShadowDom();
    if (parentBlock.workspace && shadow && Blockly.Events.recordUndo) {
        var blockShadow = Blockly.Xml.domToBlock(shadow, parentBlock.workspace);
        if (blockShadow.outputConnection) this.connect(blockShadow.outputConnection);
        else if (blockShadow.previousConnection) this.connect(blockShadow.previousConnection);
        else throw Error("Child block does not have output or previous statement.");
    }
};
Blockly.Connection.prototype.targetBlock = function() {
    if (this.isConnected()) return this.targetConnection.getSourceBlock();
    return null
};
Blockly.Connection.prototype.checkType_ = function(otherConnection) {
    if (!this.check_ || !otherConnection.check_) return true;
    for (var i = 0; i < this.check_.length; i++)
        if (otherConnection.check_.indexOf(this.check_[i]) != -1) return true;
    return false
};
Blockly.Connection.prototype.onCheckChanged_ = function() {
    if (this.isConnected() && !this.checkType_(this.targetConnection)) {
        var child = this.isSuperior() ? this.targetBlock() : this.sourceBlock_;
        child.unplug()
    }
};
Blockly.Connection.prototype.setCheck = function(check) {
    if (check) {
        if (!Array.isArray(check)) check = [check];
        this.check_ = check;
        this.onCheckChanged_()
    } else this.check_ = null;
    return this
};
Blockly.Connection.prototype.getCheck = function() {
    return this.check_
};
Blockly.Connection.prototype.setShadowDom = function(shadow) {
    this.shadowDom_ = shadow
};
Blockly.Connection.prototype.getShadowDom = function() {
    return this.shadowDom_
};
Blockly.Connection.prototype.neighbours_ = function() {
    return []
};
Blockly.Connection.prototype.toString = function() {
    var msg;
    var block = this.sourceBlock_;
    if (!block) return "Orphan Connection";
    else if (block.outputConnection == this) msg = "Output Connection of ";
    else if (block.previousConnection == this) msg = "Previous Connection of ";
    else if (block.nextConnection == this) msg = "Next Connection of ";
    else {
        var parentInput = null;
        for (var i = 0, input; input = block.inputList[i]; i++)
            if (input.connection == this) {
                parentInput = input;
                break
            } if (parentInput) msg = 'Input "' + parentInput.name + '" connection on ';
        else {
            console.warn("Connection not actually connected to sourceBlock_");
            return "Orphan Connection"
        }
    }
    return msg + block.toDevString()
};
goog.provide("Blockly.ConnectionDB");
goog.require("Blockly.Connection");
Blockly.ConnectionDB = function() {};
Blockly.ConnectionDB.prototype = new Array;
Blockly.ConnectionDB.constructor = Blockly.ConnectionDB;
Blockly.ConnectionDB.prototype.addConnection = function(connection) {
    if (connection.inDB_) throw Error("Connection already in database.");
    if (connection.getSourceBlock().isInFlyout) return;
    var position = this.findPositionForConnection_(connection);
    this.splice(position, 0, connection);
    connection.inDB_ = true
};
Blockly.ConnectionDB.prototype.findConnection = function(conn) {
    if (!this.length) return -1;
    var bestGuess = this.findPositionForConnection_(conn);
    if (bestGuess >= this.length) return -1;
    var yPos = conn.y_;
    var pointerMin = bestGuess;
    var pointerMax = bestGuess;
    while (pointerMin >= 0 && this[pointerMin].y_ == yPos) {
        if (this[pointerMin] == conn) return pointerMin;
        pointerMin--
    }
    while (pointerMax < this.length && this[pointerMax].y_ == yPos) {
        if (this[pointerMax] == conn) return pointerMax;
        pointerMax++
    }
    return -1
};
Blockly.ConnectionDB.prototype.findPositionForConnection_ = function(connection) {
    if (!this.length) return 0;
    var pointerMin = 0;
    var pointerMax = this.length;
    while (pointerMin < pointerMax) {
        var pointerMid = Math.floor((pointerMin + pointerMax) / 2);
        if (this[pointerMid].y_ < connection.y_) pointerMin = pointerMid + 1;
        else if (this[pointerMid].y_ > connection.y_) pointerMax = pointerMid;
        else {
            pointerMin = pointerMid;
            break
        }
    }
    return pointerMin
};
Blockly.ConnectionDB.prototype.removeConnection_ = function(connection) {
    if (!connection.inDB_) throw Error("Connection not in database.");
    var removalIndex = this.findConnection(connection);
    if (removalIndex == -1) throw Error("Unable to find connection in connectionDB.");
    connection.inDB_ = false;
    this.splice(removalIndex, 1)
};
Blockly.ConnectionDB.prototype.getNeighbours = function(connection, maxRadius) {
    var db = this;
    var currentX = connection.x_;
    var currentY = connection.y_;
    var pointerMin = 0;
    var pointerMax = db.length - 2;
    var pointerMid = pointerMax;
    while (pointerMin < pointerMid) {
        if (db[pointerMid].y_ < currentY) pointerMin = pointerMid;
        else pointerMax = pointerMid;
        pointerMid = Math.floor((pointerMin + pointerMax) / 2)
    }
    var neighbours = [];

    function checkConnection_(yIndex) {
        var dx = currentX - db[yIndex].x_;
        var dy = currentY - db[yIndex].y_;
        var r = Math.sqrt(dx * dx +
            dy * dy);
        if (r <= maxRadius) neighbours.push(db[yIndex]);
        return dy < maxRadius
    }
    pointerMin = pointerMid;
    pointerMax = pointerMid;
    if (db.length) {
        while (pointerMin >= 0 && checkConnection_(pointerMin)) pointerMin--;
        do pointerMax++; while (pointerMax < db.length && checkConnection_(pointerMax))
    }
    return neighbours
};
Blockly.ConnectionDB.prototype.isInYRange_ = function(index, baseY, maxRadius) {
    return Math.abs(this[index].y_ - baseY) <= maxRadius
};
Blockly.ConnectionDB.prototype.searchForClosest = function(conn, maxRadius, dxy) {
    if (!this.length) return {
        connection: null,
        radius: maxRadius
    };
    var baseY = conn.y_;
    var baseX = conn.x_;
    conn.x_ = baseX + dxy.x;
    conn.y_ = baseY + dxy.y;
    var closestIndex = this.findPositionForConnection_(conn);
    var bestConnection = null;
    var bestRadius = maxRadius;
    var temp;
    var pointerMin = closestIndex - 1;
    while (pointerMin >= 0 && this.isInYRange_(pointerMin, conn.y_, maxRadius)) {
        temp = this[pointerMin];
        if (conn.isConnectionAllowed(temp, bestRadius)) {
            bestConnection =
                temp;
            bestRadius = temp.distanceFrom(conn)
        }
        pointerMin--
    }
    var pointerMax = closestIndex;
    while (pointerMax < this.length && this.isInYRange_(pointerMax, conn.y_, maxRadius)) {
        temp = this[pointerMax];
        if (conn.isConnectionAllowed(temp, bestRadius)) {
            bestConnection = temp;
            bestRadius = temp.distanceFrom(conn)
        }
        pointerMax++
    }
    conn.x_ = baseX;
    conn.y_ = baseY;
    return {
        connection: bestConnection,
        radius: bestRadius
    }
};
Blockly.ConnectionDB.init = function(workspace) {
    var dbList = [];
    dbList[Blockly.INPUT_VALUE] = new Blockly.ConnectionDB;
    dbList[Blockly.OUTPUT_VALUE] = new Blockly.ConnectionDB;
    dbList[Blockly.NEXT_STATEMENT] = new Blockly.ConnectionDB;
    dbList[Blockly.PREVIOUS_STATEMENT] = new Blockly.ConnectionDB;
    workspace.connectionDBList = dbList
};
goog.provide("Blockly.constants");
Blockly.DRAG_RADIUS = 5;
Blockly.FLYOUT_DRAG_RADIUS = 10;
Blockly.SNAP_RADIUS = 20;
Blockly.BUMP_DELAY = 250;
Blockly.COLLAPSE_CHARS = 30;
Blockly.LONGPRESS = 750;
Blockly.SOUND_LIMIT = 100;
Blockly.DRAG_STACK = true;
Blockly.HSV_SATURATION = .45;
Blockly.HSV_VALUE = .65;
Blockly.SPRITE = {
    width: 96,
    height: 124,
    url: "sprites.png"
};
Blockly.SVG_NS = "http://www.w3.org/2000/svg";
Blockly.HTML_NS = "http://www.w3.org/1999/xhtml";
Blockly.INPUT_VALUE = 1;
Blockly.OUTPUT_VALUE = 2;
Blockly.NEXT_STATEMENT = 3;
Blockly.PREVIOUS_STATEMENT = 4;
Blockly.DUMMY_INPUT = 5;
Blockly.ALIGN_LEFT = -1;
Blockly.ALIGN_CENTRE = 0;
Blockly.ALIGN_RIGHT = 1;
Blockly.DRAG_NONE = 0;
Blockly.DRAG_STICKY = 1;
Blockly.DRAG_BEGIN = 1;
Blockly.DRAG_FREE = 2;
Blockly.OPPOSITE_TYPE = [];
Blockly.OPPOSITE_TYPE[Blockly.INPUT_VALUE] = Blockly.OUTPUT_VALUE;
Blockly.OPPOSITE_TYPE[Blockly.OUTPUT_VALUE] = Blockly.INPUT_VALUE;
Blockly.OPPOSITE_TYPE[Blockly.NEXT_STATEMENT] = Blockly.PREVIOUS_STATEMENT;
Blockly.OPPOSITE_TYPE[Blockly.PREVIOUS_STATEMENT] = Blockly.NEXT_STATEMENT;
Blockly.TOOLBOX_AT_TOP = 0;
Blockly.TOOLBOX_AT_BOTTOM = 1;
Blockly.TOOLBOX_AT_LEFT = 2;
Blockly.TOOLBOX_AT_RIGHT = 3;
Blockly.DELETE_AREA_NONE = null;
Blockly.DELETE_AREA_TRASH = 1;
Blockly.DELETE_AREA_TOOLBOX = 2;
Blockly.VARIABLE_CATEGORY_NAME = "VARIABLE";
Blockly.VARIABLE_DYNAMIC_CATEGORY_NAME = "VARIABLE_DYNAMIC";
Blockly.PROCEDURE_CATEGORY_NAME = "PROCEDURE";
Blockly.RENAME_VARIABLE_ID = "RENAME_VARIABLE_ID";
Blockly.DELETE_VARIABLE_ID = "DELETE_VARIABLE_ID";
goog.provide("Blockly.ContextMenu");
goog.require("Blockly.Events.BlockCreate");
goog.require("Blockly.utils");
goog.require("Blockly.utils.uiMenu");
goog.require("Blockly.Xml");
goog.require("goog.events");
goog.require("goog.math.Coordinate");
goog.require("goog.ui.Menu");
goog.require("goog.ui.MenuItem");
goog.require("goog.userAgent");
Blockly.ContextMenu.currentBlock = null;
Blockly.ContextMenu.eventWrapper_ = null;
Blockly.ContextMenu.show = function(e, options, rtl) {
    Blockly.WidgetDiv.show(Blockly.ContextMenu, rtl, null);
    if (!options.length) {
        Blockly.ContextMenu.hide();
        return
    }
    var menu = Blockly.ContextMenu.populate_(options, rtl);
    goog.events.listen(menu, goog.ui.Component.EventType.ACTION, Blockly.ContextMenu.hide);
    Blockly.ContextMenu.position_(menu, e, rtl);
    setTimeout(function() {
        menu.getElement().focus()
    }, 1);
    Blockly.ContextMenu.currentBlock = null
};
Blockly.ContextMenu.populate_ = function(options, rtl) {
    var menu = new goog.ui.Menu;
    menu.setRightToLeft(rtl);
    for (var i = 0, option; option = options[i]; i++) {
        var menuItem = new goog.ui.MenuItem(option.text);
        menuItem.setRightToLeft(rtl);
        menu.addChild(menuItem, true);
        menuItem.setEnabled(option.enabled);
        if (option.enabled) {
            goog.events.listen(menuItem, goog.ui.Component.EventType.ACTION, option.callback);
            menuItem.handleContextMenu = function() {
                goog.events.dispatchEvent(this, goog.ui.Component.EventType.ACTION)
            }
        }
    }
    return menu
};
Blockly.ContextMenu.position_ = function(menu, e, rtl) {
    var viewportBBox = Blockly.utils.getViewportBBox();
    var anchorBBox = {
        top: e.clientY + viewportBBox.top,
        bottom: e.clientY + viewportBBox.top,
        left: e.clientX + viewportBBox.left,
        right: e.clientX + viewportBBox.left
    };
    Blockly.ContextMenu.createWidget_(menu);
    var menuSize = Blockly.utils.uiMenu.getSize(menu);
    if (rtl) Blockly.utils.uiMenu.adjustBBoxesForRTL(viewportBBox, anchorBBox, menuSize);
    Blockly.WidgetDiv.positionWithAnchor(viewportBBox, anchorBBox, menuSize, rtl);
    menu.getElement().focus()
};
Blockly.ContextMenu.createWidget_ = function(menu) {
    var div = Blockly.WidgetDiv.DIV;
    menu.render(div);
    var menuDom = menu.getElement();
    Blockly.utils.addClass(menuDom, "blocklyContextMenu");
    Blockly.bindEventWithChecks_(menuDom, "contextmenu", null, Blockly.utils.noEvent);
    menu.setAllowAutoFocus(true)
};
Blockly.ContextMenu.hide = function() {
    Blockly.WidgetDiv.hideIfOwner(Blockly.ContextMenu);
    Blockly.ContextMenu.currentBlock = null;
    if (Blockly.ContextMenu.eventWrapper_) Blockly.unbindEvent_(Blockly.ContextMenu.eventWrapper_)
};
Blockly.ContextMenu.callbackFactory = function(block, xml) {
    return function() {
        Blockly.Events.disable();
        try {
            var newBlock = Blockly.Xml.domToBlock(xml, block.workspace);
            var xy = block.getRelativeToSurfaceXY();
            if (block.RTL) xy.x -= Blockly.SNAP_RADIUS;
            else xy.x += Blockly.SNAP_RADIUS;
            xy.y += Blockly.SNAP_RADIUS * 2;
            newBlock.moveBy(xy.x, xy.y)
        } finally {
            Blockly.Events.enable()
        }
        if (Blockly.Events.isEnabled() && !newBlock.isShadow()) Blockly.Events.fire(new Blockly.Events.BlockCreate(newBlock));
        newBlock.select()
    }
};
Blockly.ContextMenu.blockDeleteOption = function(block) {
    var descendantCount = block.getDescendants(false).length;
    var nextBlock = block.getNextBlock();
    if (nextBlock) descendantCount -= nextBlock.getDescendants(false).length;
    var deleteOption = {
        text: descendantCount == 1 ? Blockly.Msg["DELETE_BLOCK"] : Blockly.Msg["DELETE_X_BLOCKS"].replace("%1", String(descendantCount)),
        enabled: true,
        callback: function() {
            Blockly.Events.setGroup(true);
            block.dispose(true, true);
            Blockly.Events.setGroup(false)
        }
    };
    return deleteOption
};
Blockly.ContextMenu.blockHelpOption = function(block) {
    var url = typeof block.helpUrl == "function" ? block.helpUrl() : block.helpUrl;
    var helpOption = {
        enabled: !!url,
        text: Blockly.Msg["HELP"],
        callback: function() {
            block.showHelp_()
        }
    };
    return helpOption
};
Blockly.ContextMenu.blockDuplicateOption = function(block) {
    var enabled = true;
    if (block.getDescendants(false).length > block.workspace.remainingCapacity()) enabled = false;
    var duplicateOption = {
        text: Blockly.Msg["DUPLICATE_BLOCK"],
        enabled: enabled,
        callback: function() {
            Blockly.duplicate_(block)
        }
    };
    return duplicateOption
};
Blockly.ContextMenu.blockCommentOption = function(block) {
    var commentOption = {
        enabled: !goog.userAgent.IE
    };
    if (block.comment) {
        commentOption.text = Blockly.Msg["REMOVE_COMMENT"];
        commentOption.callback = function() {
            block.setCommentText(null)
        }
    } else {
        commentOption.text = Blockly.Msg["ADD_COMMENT"];
        commentOption.callback = function() {
            block.setCommentText("")
        }
    }
    return commentOption
};
Blockly.ContextMenu.commentDeleteOption = function(comment) {
    var deleteOption = {
        text: Blockly.Msg.REMOVE_COMMENT,
        enabled: true,
        callback: function() {
            Blockly.Events.setGroup(true);
            comment.dispose(true, true);
            Blockly.Events.setGroup(false)
        }
    };
    return deleteOption
};
Blockly.ContextMenu.commentDuplicateOption = function(comment) {
    var duplicateOption = {
        text: Blockly.Msg.DUPLICATE_COMMENT,
        enabled: true,
        callback: function() {
            Blockly.duplicate_(comment)
        }
    };
    return duplicateOption
};
Blockly.ContextMenu.workspaceCommentOption = function(ws, e) {
    var addWsComment = function() {
        var comment = new Blockly.WorkspaceCommentSvg(ws, Blockly.Msg.WORKSPACE_COMMENT_DEFAULT_TEXT, Blockly.WorkspaceCommentSvg.DEFAULT_SIZE, Blockly.WorkspaceCommentSvg.DEFAULT_SIZE);
        var injectionDiv = ws.getInjectionDiv();
        var boundingRect = injectionDiv.getBoundingClientRect();
        var clientOffsetPixels = new goog.math.Coordinate(e.clientX - boundingRect.left, e.clientY - boundingRect.top);
        var mainOffsetPixels = ws.getOriginOffsetInPixels();
        var finalOffsetPixels = goog.math.Coordinate.difference(clientOffsetPixels, mainOffsetPixels);
        var finalOffsetMainWs = finalOffsetPixels.scale(1 / ws.scale);
        var commentX = finalOffsetMainWs.x;
        var commentY = finalOffsetMainWs.y;
        comment.moveBy(commentX, commentY);
        if (ws.rendered) {
            comment.initSvg();
            comment.render(false);
            comment.select()
        }
    };
    var wsCommentOption = {
        enabled: !goog.userAgent.IE
    };
    wsCommentOption.text = Blockly.Msg.ADD_COMMENT;
    wsCommentOption.callback = function() {
        addWsComment()
    };
    return wsCommentOption
};
goog.provide("Blockly.Css");
Blockly.Css.Cursor = {
    OPEN: "handopen",
    CLOSED: "handclosed",
    DELETE: "handdelete"
};
Blockly.Css.currentCursor_ = "";
Blockly.Css.styleSheet_ = null;
Blockly.Css.mediaPath_ = "";
Blockly.Css.inject = function(hasCss, pathToMedia) {
    if (Blockly.Css.styleSheet_) return;
    var text = ".blocklyDraggable {}\n";
    if (hasCss) {
        text += Blockly.Css.CONTENT.join("\n");
        if (Blockly.FieldDate) text += Blockly.FieldDate.CSS.join("\n")
    }
    Blockly.Css.mediaPath_ = pathToMedia.replace(/[\\\/]$/, "");
    text = text.replace(/<<<PATH>>>/g, Blockly.Css.mediaPath_);
    var cssNode = document.createElement("style");
    document.head.insertBefore(cssNode, document.head.firstChild);
    var cssTextNode = document.createTextNode(text);
    cssNode.appendChild(cssTextNode);
    Blockly.Css.styleSheet_ = cssNode.sheet
};
Blockly.Css.setCursor = function(cursor) {
    console.warn("Deprecated call to Blockly.Css.setCursor." + "See https://github.com/google/blockly/issues/981 for context")
};
Blockly.Css.CONTENT = [".blocklySvg {", "background-color: #fff;", "outline: none;", "overflow: hidden;", "position: absolute;", "display: block;", "}", ".blocklyWidgetDiv {", "display: none;", "position: absolute;", "z-index: 99999;", "}", ".injectionDiv {", "height: 100%;", "position: relative;", "overflow: hidden;", "touch-action: none", "}", ".blocklyNonSelectable {", "user-select: none;", "-moz-user-select: none;", "-ms-user-select: none;", "-webkit-user-select: none;", "}", ".blocklyWsDragSurface {", "display: none;",
    "position: absolute;", "top: 0;", "left: 0;", "}", ".blocklyWsDragSurface.blocklyOverflowVisible {", "overflow: visible;", "}", ".blocklyBlockDragSurface {", "display: none;", "position: absolute;", "top: 0;", "left: 0;", "right: 0;", "bottom: 0;", "overflow: visible !important;", "z-index: 50;", "}", ".blocklyBlockCanvas.blocklyCanvasTransitioning,", ".blocklyBubbleCanvas.blocklyCanvasTransitioning {", "transition: transform .5s;", "}", ".blocklyTooltipDiv {", "background-color: #ffffc7;", "border: 1px solid #ddc;", "box-shadow: 4px 4px 20px 1px rgba(0,0,0,.15);",
    "color: #000;", "display: none;", "font-family: sans-serif;", "font-size: 9pt;", "opacity: .9;", "padding: 2px;", "position: absolute;", "z-index: 100000;", "}", ".blocklyResizeSE {", "cursor: se-resize;", "fill: #aaa;", "}", ".blocklyResizeSW {", "cursor: sw-resize;", "fill: #aaa;", "}", ".blocklyResizeLine {", "stroke: #515A5A;", "stroke-width: 1;", "}", ".blocklyHighlightedConnectionPath {", "fill: none;", "stroke: #fc3;", "stroke-width: 4px;", "}", ".blocklyPathLight {", "fill: none;", "stroke-linecap: round;", "stroke-width: 1;",
    "}", ".blocklySelected>.blocklyPath {", "stroke: #fc3;", "stroke-width: 3px;", "}", ".blocklySelected>.blocklyPathLight {", "display: none;", "}", ".blocklyDraggable {", 'cursor: url("<<<PATH>>>/handopen.cur"), auto;', "cursor: grab;", "cursor: -webkit-grab;", "}", ".blocklyDragging {", 'cursor: url("<<<PATH>>>/handclosed.cur"), auto;', "cursor: grabbing;", "cursor: -webkit-grabbing;", "}", ".blocklyDraggable:active {", 'cursor: url("<<<PATH>>>/handclosed.cur"), auto;', "cursor: grabbing;", "cursor: -webkit-grabbing;",
    "}", ".blocklyBlockDragSurface .blocklyDraggable {", 'cursor: url("<<<PATH>>>/handclosed.cur"), auto;', "cursor: grabbing;", "cursor: -webkit-grabbing;", "}", ".blocklyDragging.blocklyDraggingDelete {", 'cursor: url("<<<PATH>>>/handdelete.cur"), auto;', "}", ".blocklyToolboxDelete {", 'cursor: url("<<<PATH>>>/handdelete.cur"), auto;', "}", ".blocklyToolboxGrab {", 'cursor: url("<<<PATH>>>/handclosed.cur"), auto;', "cursor: grabbing;", "cursor: -webkit-grabbing;", "}", ".blocklyDragging>.blocklyPath,", ".blocklyDragging>.blocklyPathLight {",
    "fill-opacity: .8;", "stroke-opacity: .8;", "}", ".blocklyDragging>.blocklyPathDark {", "display: none;", "}", ".blocklyDisabled>.blocklyPath {", "fill-opacity: .5;", "stroke-opacity: .5;", "}", ".blocklyDisabled>.blocklyPathLight,", ".blocklyDisabled>.blocklyPathDark {", "display: none;", "}", ".blocklyText {", "cursor: default;", "fill: #fff;", "font-family: sans-serif;", "font-size: 11pt;", "}", ".blocklyNonEditableText>text {", "pointer-events: none;", "}", ".blocklyNonEditableText>rect,", ".blocklyEditableText>rect {",
    "fill: #fff;", "fill-opacity: .6;", "}", ".blocklyNonEditableText>text,", ".blocklyEditableText>text {", "fill: #000;", "}", ".blocklyEditableText:hover>rect {", "stroke: #fff;", "stroke-width: 2;", "}", ".blocklyBubbleText {", "fill: #000;", "}", ".blocklyFlyout {", "position: absolute;", "z-index: 20;", "}", ".blocklyFlyoutButton {", "fill: #888;", "cursor: default;", "}", ".blocklyFlyoutButtonShadow {", "fill: #666;", "}", ".blocklyFlyoutButton:hover {", "fill: #aaa;", "}", ".blocklyFlyoutLabel {", "cursor: default;", "}",
    ".blocklyFlyoutLabelBackground {", "opacity: 0;", "}", ".blocklyFlyoutLabelText {", "fill: #000;", "}", ".blocklySvg text, .blocklyBlockDragSurface text {", "user-select: none;", "-moz-user-select: none;", "-ms-user-select: none;", "-webkit-user-select: none;", "cursor: inherit;", "}", ".blocklyHidden {", "display: none;", "}", ".blocklyFieldDropdown:not(.blocklyHidden) {", "display: block;", "}", ".blocklyIconGroup {", "cursor: default;", "}", ".blocklyIconGroup:not(:hover),", ".blocklyIconGroupReadonly {", "opacity: .6;",
    "}", ".blocklyIconShape {", "fill: #00f;", "stroke: #fff;", "stroke-width: 1px;", "}", ".blocklyIconSymbol {", "fill: #fff;", "}", ".blocklyMinimalBody {", "margin: 0;", "padding: 0;", "}", ".blocklyCommentForeignObject {", "position: relative;", "z-index: 0;", "}", ".blocklyCommentRect {", "fill: #E7DE8E;", "stroke: #bcA903;", "stroke-width: 1px", "}", ".blocklyCommentTarget {", "fill: transparent;", "stroke: #bcA903;", "}", ".blocklyCommentTargetFocused {", "fill: none;", "}", ".blocklyCommentHandleTarget {", "fill: none;",
    "}", ".blocklyCommentHandleTargetFocused {", "fill: transparent;", "}", ".blocklyFocused>.blocklyCommentRect {", "fill: #B9B272;", "stroke: #B9B272;", "}", ".blocklySelected>.blocklyCommentTarget {", "stroke: #fc3;", "stroke-width: 3px;", "}", ".blocklyCommentTextarea {", "background-color: #fef49c;", "border: 0;", "outline: 0;", "margin: 0;", "padding: 3px;", "resize: none;", "display: block;", "overflow: hidden;", "}", ".blocklyCommentDeleteIcon {", "cursor: pointer;", "fill: #000;", "display: none", "}", ".blocklySelected > .blocklyCommentDeleteIcon {",
    "display: block", "}", ".blocklyDeleteIconShape {", "fill: #000;", "stroke: #000;", "stroke-width: 1px;", "}", ".blocklyDeleteIconShape.blocklyDeleteIconHighlighted {", "stroke: #fc3;", "}", ".blocklyHtmlInput {", "border: none;", "border-radius: 4px;", "font-family: sans-serif;", "height: 100%;", "margin: 0;", "outline: none;", "padding: 0 1px;", "width: 100%", "}", ".blocklyMainBackground {", "stroke-width: 1;", "stroke: #c6c6c6;", "}", ".blocklyMutatorBackground {", "fill: #fff;", "stroke: #ddd;", "stroke-width: 1;", "}",
    ".blocklyFlyoutBackground {", "fill: #ddd;", "fill-opacity: .8;", "}", ".blocklyTransparentBackground {", "opacity: 0;", "}", ".blocklyMainWorkspaceScrollbar {", "z-index: 20;", "}", ".blocklyFlyoutScrollbar {", "z-index: 30;", "}", ".blocklyScrollbarHorizontal, .blocklyScrollbarVertical {", "position: absolute;", "outline: none;", "}", ".blocklyScrollbarBackground {", "opacity: 0;", "}", ".blocklyScrollbarHandle {", "fill: #ccc;", "}", ".blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,", ".blocklyScrollbarHandle:hover {",
    "fill: #bbb;", "}", ".blocklyZoom>image {", "opacity: .4;", "}", ".blocklyZoom>image:hover {", "opacity: .6;", "}", ".blocklyZoom>image:active {", "opacity: .8;", "}", ".blocklyFlyout .blocklyScrollbarHandle {", "fill: #bbb;", "}", ".blocklyFlyout .blocklyScrollbarBackground:hover+.blocklyScrollbarHandle,", ".blocklyFlyout .blocklyScrollbarHandle:hover {", "fill: #aaa;", "}", ".blocklyInvalidInput {", "background: #faa;", "}", ".blocklyAngleCircle {", "stroke: #444;", "stroke-width: 1;", "fill: #ddd;", "fill-opacity: .8;",
    "}", ".blocklyAngleMarks {", "stroke: #444;", "stroke-width: 1;", "}", ".blocklyAngleGauge {", "fill: #f88;", "fill-opacity: .8;", "}", ".blocklyAngleLine {", "stroke: #f00;", "stroke-width: 2;", "stroke-linecap: round;", "pointer-events: none;", "}", ".blocklyContextMenu {", "border-radius: 4px;", "}", ".blocklyDropdownMenu {", "padding: 0 !important;", "}", ".blocklyWidgetDiv .goog-option-selected .goog-menuitem-checkbox,", ".blocklyWidgetDiv .goog-option-selected .goog-menuitem-icon {", "background: url(<<<PATH>>>/sprites.png) no-repeat -48px -16px !important;",
    "}", ".blocklyToolboxDiv {", "background-color: #ddd;", "overflow-x: visible;", "overflow-y: auto;", "position: absolute;", "user-select: none;", "-moz-user-select: none;", "-ms-user-select: none;", "-webkit-user-select: none;", "z-index: 70;", "-webkit-tap-highlight-color: transparent;", "}", ".blocklyTreeRoot {", "padding: 4px 0;", "}", ".blocklyTreeRoot:focus {", "outline: none;", "}", ".blocklyTreeRow {", "height: 22px;", "line-height: 22px;", "margin-bottom: 3px;", "padding-right: 8px;", "white-space: nowrap;", "}",
    ".blocklyHorizontalTree {", "float: left;", "margin: 1px 5px 8px 0;", "}", ".blocklyHorizontalTreeRtl {", "float: right;", "margin: 1px 0 8px 5px;", "}", '.blocklyToolboxDiv[dir="RTL"] .blocklyTreeRow {', "margin-left: 8px;", "}", ".blocklyTreeRow:not(.blocklyTreeSelected):hover {", "background-color: #e4e4e4;", "}", ".blocklyTreeSeparator {", "border-bottom: solid #e5e5e5 1px;", "height: 0;", "margin: 5px 0;", "}", ".blocklyTreeSeparatorHorizontal {", "border-right: solid #e5e5e5 1px;", "width: 0;", "padding: 5px 0;",
    "margin: 0 5px;", "}", ".blocklyTreeIcon {", "background-image: url(<<<PATH>>>/sprites.png);", "height: 16px;", "vertical-align: middle;", "width: 16px;", "}", ".blocklyTreeIconClosedLtr {", "background-position: -32px -1px;", "}", ".blocklyTreeIconClosedRtl {", "background-position: 0 -1px;", "}", ".blocklyTreeIconOpen {", "background-position: -16px -1px;", "}", ".blocklyTreeSelected>.blocklyTreeIconClosedLtr {", "background-position: -32px -17px;", "}", ".blocklyTreeSelected>.blocklyTreeIconClosedRtl {", "background-position: 0 -17px;",
    "}", ".blocklyTreeSelected>.blocklyTreeIconOpen {", "background-position: -16px -17px;", "}", ".blocklyTreeIconNone,", ".blocklyTreeSelected>.blocklyTreeIconNone {", "background-position: -48px -1px;", "}", ".blocklyTreeLabel {", "cursor: default;", "font-family: sans-serif;", "font-size: 16px;", "padding: 0 3px;", "vertical-align: middle;", "}", ".blocklyToolboxDelete .blocklyTreeLabel {", 'cursor: url("<<<PATH>>>/handdelete.cur"), auto;', "}", ".blocklyTreeSelected .blocklyTreeLabel {", "color: #fff;", "}", ".blocklyColourTable {",
    "border-collapse: collapse;", "}", ".blocklyColourTable>tr>td {", "border: 1px solid #666;", "padding: 0;", "}", ".blocklyColourTable>tr>td>div {", "border: 1px solid #666;", "height: 13px;", "width: 15px;", "}", ".blocklyColourTable>tr>td>div:hover {", "border: 1px solid #fff;", "}", ".blocklyColourSelected, .blocklyColourSelected:hover {", "border: 1px solid #000 !important;", "}", ".blocklyWidgetDiv .goog-menu {", "background: #fff;", "border-color: #ccc #666 #666 #ccc;", "border-style: solid;", "border-width: 1px;",
    "cursor: default;", "font: normal 13px Arial, sans-serif;", "margin: 0;", "outline: none;", "padding: 4px 0;", "position: absolute;", "overflow-y: auto;", "overflow-x: hidden;", "max-height: 100%;", "z-index: 20000;", "}", ".blocklyWidgetDiv .goog-menuitem {", "color: #000;", "font: normal 13px Arial, sans-serif;", "list-style: none;", "margin: 0;", "padding: 4px 7em 4px 28px;", "white-space: nowrap;", "}", ".blocklyWidgetDiv .goog-menuitem.goog-menuitem-rtl {", "padding-left: 7em;", "padding-right: 28px;", "}", ".blocklyWidgetDiv .goog-menu-nocheckbox .goog-menuitem,",
    ".blocklyWidgetDiv .goog-menu-noicon .goog-menuitem {", "padding-left: 12px;", "}", ".blocklyWidgetDiv .goog-menu-noaccel .goog-menuitem {", "padding-right: 20px;", "}", ".blocklyWidgetDiv .goog-menuitem-content {", "color: #000;", "font: normal 13px Arial, sans-serif;", "}", ".blocklyWidgetDiv .goog-menuitem-disabled .goog-menuitem-accel,", ".blocklyWidgetDiv .goog-menuitem-disabled .goog-menuitem-content {", "color: #ccc !important;", "}", ".blocklyWidgetDiv .goog-menuitem-disabled .goog-menuitem-icon {", "opacity: 0.3;",
    "filter: alpha(opacity=30);", "}", ".blocklyWidgetDiv .goog-menuitem-highlight,", ".blocklyWidgetDiv .goog-menuitem-hover {", "background-color: #d6e9f8;", "border-color: #d6e9f8;", "border-style: dotted;", "border-width: 1px 0;", "padding-bottom: 3px;", "padding-top: 3px;", "}", ".blocklyWidgetDiv .goog-menuitem-checkbox,", ".blocklyWidgetDiv .goog-menuitem-icon {", "background-repeat: no-repeat;", "height: 16px;", "left: 6px;", "position: absolute;", "right: auto;", "vertical-align: middle;", "width: 16px;", "}", ".blocklyWidgetDiv .goog-menuitem-rtl .goog-menuitem-checkbox,",
    ".blocklyWidgetDiv .goog-menuitem-rtl .goog-menuitem-icon {", "left: auto;", "right: 6px;", "}", ".blocklyWidgetDiv .goog-option-selected .goog-menuitem-checkbox,", ".blocklyWidgetDiv .goog-option-selected .goog-menuitem-icon {", "background: url(//ssl.gstatic.com/editor/editortoolbar.png) no-repeat -512px 0;", "}", ".blocklyWidgetDiv .goog-menuitem-accel {", "color: #999;", "direction: ltr;", "left: auto;", "padding: 0 6px;", "position: absolute;", "right: 0;", "text-align: right;", "}", ".blocklyWidgetDiv .goog-menuitem-rtl .goog-menuitem-accel {",
    "left: 0;", "right: auto;", "text-align: left;", "}", ".blocklyWidgetDiv .goog-menuitem-mnemonic-hint {", "text-decoration: underline;", "}", ".blocklyWidgetDiv .goog-menuitem-mnemonic-separator {", "color: #999;", "font-size: 12px;", "padding-left: 4px;", "}", ".blocklyWidgetDiv .goog-menuseparator {", "border-top: 1px solid #ccc;", "margin: 4px 0;", "padding: 0;", "}", ""
];
goog.provide("Blockly.DraggedConnectionManager");
goog.require("Blockly.BlockAnimations");
goog.require("Blockly.RenderedConnection");
goog.require("goog.math.Coordinate");
Blockly.DraggedConnectionManager = function(block) {
    Blockly.selected = block;
    this.topBlock_ = block;
    this.workspace_ = block.workspace;
    this.availableConnections_ = this.initAvailableConnections_();
    this.closestConnection_ = null;
    this.localConnection_ = null;
    this.radiusConnection_ = 0;
    this.wouldDeleteBlock_ = false
};
Blockly.DraggedConnectionManager.prototype.dispose = function() {
    this.topBlock_ = null;
    this.workspace_ = null;
    this.availableConnections_.length = 0;
    this.closestConnection_ = null;
    this.localConnection_ = null
};
Blockly.DraggedConnectionManager.prototype.wouldDeleteBlock = function() {
    return this.wouldDeleteBlock_
};
Blockly.DraggedConnectionManager.prototype.wouldConnectBlock = function() {
    return !!this.closestConnection_
};
Blockly.DraggedConnectionManager.prototype.applyConnections = function() {
    if (this.closestConnection_) {
        this.localConnection_.connect(this.closestConnection_);
        if (this.topBlock_.rendered) {
            var inferiorConnection = this.localConnection_.isSuperior() ? this.closestConnection_ : this.localConnection_;
            Blockly.BlockAnimations.connectionUiEffect(inferiorConnection.getSourceBlock());
            var rootBlock = this.topBlock_.getRootBlock();
            rootBlock.bringToFront()
        }
        this.removeHighlighting_()
    }
};
Blockly.DraggedConnectionManager.prototype.update = function(dxy, deleteArea) {
    var oldClosestConnection = this.closestConnection_;
    var closestConnectionChanged = this.updateClosest_(dxy);
    if (closestConnectionChanged && oldClosestConnection) oldClosestConnection.unhighlight();
    var wouldConnect = !!this.closestConnection_ && deleteArea != Blockly.DELETE_AREA_TOOLBOX;
    var wouldDelete = !!deleteArea && !this.topBlock_.getParent() && this.topBlock_.isDeletable();
    this.wouldDeleteBlock_ = wouldDelete && !wouldConnect;
    if (wouldDelete &&
        this.closestConnection_) {
        this.closestConnection_.unhighlight();
        this.closestConnection_ = null
    }
    if (!this.wouldDeleteBlock_ && closestConnectionChanged && this.closestConnection_) this.addHighlighting_()
};
Blockly.DraggedConnectionManager.prototype.removeHighlighting_ = function() {
    if (this.closestConnection_) this.closestConnection_.unhighlight()
};
Blockly.DraggedConnectionManager.prototype.addHighlighting_ = function() {
    if (this.closestConnection_) this.closestConnection_.highlight()
};
Blockly.DraggedConnectionManager.prototype.initAvailableConnections_ = function() {
    var available = this.topBlock_.getConnections_(false);
    var lastOnStack = this.topBlock_.lastConnectionInStack();
    if (lastOnStack && lastOnStack != this.topBlock_.nextConnection) available.push(lastOnStack);
    return available
};
Blockly.DraggedConnectionManager.prototype.updateClosest_ = function(dxy) {
    var oldClosestConnection = this.closestConnection_;
    this.closestConnection_ = null;
    this.localConnection_ = null;
    this.radiusConnection_ = Blockly.SNAP_RADIUS;
    for (var i = 0; i < this.availableConnections_.length; i++) {
        var myConnection = this.availableConnections_[i];
        var neighbour = myConnection.closest(this.radiusConnection_, dxy);
        if (neighbour.connection) {
            this.closestConnection_ = neighbour.connection;
            this.localConnection_ = myConnection;
            this.radiusConnection_ =
                neighbour.radius
        }
    }
    return oldClosestConnection != this.closestConnection_
};
goog.provide("Blockly.Events");
goog.require("Blockly.utils");
Blockly.Events.group_ = "";
Blockly.Events.recordUndo = true;
Blockly.Events.disabled_ = 0;
Blockly.Events.CREATE = "create";
Blockly.Events.BLOCK_CREATE = Blockly.Events.CREATE;
Blockly.Events.DELETE = "delete";
Blockly.Events.BLOCK_DELETE = Blockly.Events.DELETE;
Blockly.Events.CHANGE = "change";
Blockly.Events.BLOCK_CHANGE = Blockly.Events.CHANGE;
Blockly.Events.MOVE = "move";
Blockly.Events.BLOCK_MOVE = Blockly.Events.MOVE;
Blockly.Events.VAR_CREATE = "var_create";
Blockly.Events.VAR_DELETE = "var_delete";
Blockly.Events.VAR_RENAME = "var_rename";
Blockly.Events.UI = "ui";
Blockly.Events.COMMENT_CREATE = "comment_create";
Blockly.Events.COMMENT_DELETE = "comment_delete";
Blockly.Events.COMMENT_CHANGE = "comment_change";
Blockly.Events.COMMENT_MOVE = "comment_move";
Blockly.Events.FIRE_QUEUE_ = [];
Blockly.Events.fire = function(event) {
    if (!Blockly.Events.isEnabled()) return;
    if (!Blockly.Events.FIRE_QUEUE_.length) setTimeout(Blockly.Events.fireNow_, 0);
    Blockly.Events.FIRE_QUEUE_.push(event)
};
Blockly.Events.fireNow_ = function() {
    var queue = Blockly.Events.filter(Blockly.Events.FIRE_QUEUE_, true);
    Blockly.Events.FIRE_QUEUE_.length = 0;
    for (var i = 0, event; event = queue[i]; i++) {
        var workspace = Blockly.Workspace.getById(event.workspaceId);
        if (workspace) workspace.fireChangeListener(event)
    }
};
Blockly.Events.filter = function(queueIn, forward) {
    var queue = queueIn.slice();
    if (!forward) queue.reverse();
    var mergedQueue = [];
    var hash = Object.create(null);
    for (var i = 0, event; event = queue[i]; i++)
        if (!event.isNull()) {
            var key = [event.type, event.blockId, event.workspaceId].join(" ");
            var lastEntry = hash[key];
            var lastEvent = lastEntry ? lastEntry.event : null;
            if (!lastEntry) {
                hash[key] = {
                    event: event,
                    index: i
                };
                mergedQueue.push(event)
            } else if (event.type == Blockly.Events.MOVE && lastEntry.index == i - 1) {
                lastEvent.newParentId = event.newParentId;
                lastEvent.newInputName = event.newInputName;
                lastEvent.newCoordinate = event.newCoordinate;
                lastEntry.index = i
            } else if (event.type == Blockly.Events.CHANGE && event.element == lastEvent.element && event.name == lastEvent.name) lastEvent.newValue = event.newValue;
            else if (event.type == Blockly.Events.UI && event.element == "click" && (lastEvent.element == "commentOpen" || lastEvent.element == "mutatorOpen" || lastEvent.element == "warningOpen")) lastEvent.newValue = event.newValue;
            else {
                hash[key] = {
                    event: event,
                    index: 1
                };
                mergedQueue.push(event)
            }
        } queue =
        mergedQueue.filter(function(e) {
            return !e.isNull()
        });
    if (!forward) queue.reverse();
    for (var i = 1, event; event = queue[i]; i++)
        if (event.type == Blockly.Events.CHANGE && event.element == "mutation") queue.unshift(queue.splice(i, 1)[0]);
    return queue
};
Blockly.Events.clearPendingUndo = function() {
    for (var i = 0, event; event = Blockly.Events.FIRE_QUEUE_[i]; i++) event.recordUndo = false
};
Blockly.Events.disable = function() {
    Blockly.Events.disabled_++
};
Blockly.Events.enable = function() {
    Blockly.Events.disabled_--
};
Blockly.Events.isEnabled = function() {
    return Blockly.Events.disabled_ == 0
};
Blockly.Events.getGroup = function() {
    return Blockly.Events.group_
};
Blockly.Events.setGroup = function(state) {
    if (typeof state == "boolean") Blockly.Events.group_ = state ? Blockly.utils.genUid() : "";
    else Blockly.Events.group_ = state
};
Blockly.Events.getDescendantIds_ = function(block) {
    var ids = [];
    var descendants = block.getDescendants(false);
    for (var i = 0, descendant; descendant = descendants[i]; i++) ids[i] = descendant.id;
    return ids
};
Blockly.Events.fromJson = function(json, workspace) {
    var event;
    switch (json.type) {
        case Blockly.Events.CREATE:
            event = new Blockly.Events.Create(null);
            break;
        case Blockly.Events.DELETE:
            event = new Blockly.Events.Delete(null);
            break;
        case Blockly.Events.CHANGE:
            event = new Blockly.Events.Change(null, "", "", "", "");
            break;
        case Blockly.Events.MOVE:
            event = new Blockly.Events.Move(null);
            break;
        case Blockly.Events.VAR_CREATE:
            event = new Blockly.Events.VarCreate(null);
            break;
        case Blockly.Events.VAR_DELETE:
            event = new Blockly.Events.VarDelete(null);
            break;
        case Blockly.Events.VAR_RENAME:
            event = new Blockly.Events.VarRename(null, "");
            break;
        case Blockly.Events.UI:
            event = new Blockly.Events.Ui(null);
            break;
        case Blockly.Events.COMMENT_CREATE:
            event = new Blockly.Events.CommentCreate(null);
            break;
        case Blockly.Events.COMMENT_CHANGE:
            event = new Blockly.Events.CommentChange(null);
            break;
        case Blockly.Events.COMMENT_MOVE:
            event = new Blockly.Events.CommentMove(null);
            break;
        case Blockly.Events.COMMENT_DELETE:
            event = new Blockly.Events.CommentDelete(null);
            break;
        default:
            throw Error("Unknown event type.");
    }
    event.fromJson(json);
    event.workspaceId = workspace.id;
    return event
};
Blockly.Events.disableOrphans = function(event) {
    if (event.type == Blockly.Events.MOVE || event.type == Blockly.Events.CREATE) {
        var workspace = Blockly.Workspace.getById(event.workspaceId);
        var block = workspace.getBlockById(event.blockId);
        if (block)
            if (block.getParent() && !block.getParent().disabled) {
                var children = block.getDescendants(false);
                for (var i = 0, child; child = children[i]; i++) child.setDisabled(false)
            } else if ((block.outputConnection || block.previousConnection) && !workspace.isDragging()) {
            do {
                block.setDisabled(true);
                block = block.getNextBlock()
            } while (block)
        }
    }
};
goog.provide("Blockly.Events.Abstract");
goog.require("Blockly.Events");
Blockly.Events.Abstract = function() {
    this.workspaceId = undefined;
    this.group = Blockly.Events.group_;
    this.recordUndo = Blockly.Events.recordUndo
};
Blockly.Events.Abstract.prototype.toJson = function() {
    var json = {
        "type": this.type
    };
    if (this.group) json["group"] = this.group;
    return json
};
Blockly.Events.Abstract.prototype.fromJson = function(json) {
    this.group = json["group"]
};
Blockly.Events.Abstract.prototype.isNull = function() {
    return false
};
Blockly.Events.Abstract.prototype.run = function(_forward) {};
Blockly.Events.Abstract.prototype.getEventWorkspace_ = function() {
    var workspace = Blockly.Workspace.getById(this.workspaceId);
    if (!workspace) throw Error("Workspace is null. Event must have been generated from real" + " Blockly events.");
    return workspace
};
goog.provide("Blockly.Extensions");
goog.require("Blockly.Mutator");
goog.require("Blockly.utils");
Blockly.Extensions.ALL_ = {};
Blockly.Extensions.register = function(name, initFn) {
    if (typeof name != "string" || name.trim() == "") throw Error('Error: Invalid extension name "' + name + '"');
    if (Blockly.Extensions.ALL_[name]) throw Error('Error: Extension "' + name + '" is already registered.');
    if (typeof initFn != "function") throw Error('Error: Extension "' + name + '" must be a function');
    Blockly.Extensions.ALL_[name] = initFn
};
Blockly.Extensions.registerMixin = function(name, mixinObj) {
    if (!mixinObj || typeof mixinObj != "object") throw Error('Error: Mixin "' + name + '" must be a object');
    Blockly.Extensions.register(name, function() {
        this.mixin(mixinObj)
    })
};
Blockly.Extensions.registerMutator = function(name, mixinObj, opt_helperFn, opt_blockList) {
    var errorPrefix = 'Error when registering mutator "' + name + '": ';
    Blockly.Extensions.checkHasFunction_(errorPrefix, mixinObj.domToMutation, "domToMutation");
    Blockly.Extensions.checkHasFunction_(errorPrefix, mixinObj.mutationToDom, "mutationToDom");
    var hasMutatorDialog = Blockly.Extensions.checkMutatorDialog_(mixinObj, errorPrefix);
    if (opt_helperFn && typeof opt_helperFn != "function") throw Error('Extension "' + name + '" is not a function');
    Blockly.Extensions.register(name, function() {
        if (hasMutatorDialog) this.setMutator(new Blockly.Mutator(opt_blockList));
        this.mixin(mixinObj);
        if (opt_helperFn) opt_helperFn.apply(this)
    })
};
Blockly.Extensions.apply = function(name, block, isMutator) {
    var extensionFn = Blockly.Extensions.ALL_[name];
    if (typeof extensionFn != "function") throw Error('Error: Extension "' + name + '" not found.');
    if (isMutator) Blockly.Extensions.checkNoMutatorProperties_(name, block);
    else var mutatorProperties = Blockly.Extensions.getMutatorProperties_(block);
    extensionFn.apply(block);
    if (isMutator) {
        var errorPrefix = 'Error after applying mutator "' + name + '": ';
        Blockly.Extensions.checkBlockHasMutatorProperties_(errorPrefix, block)
    } else if (!Blockly.Extensions.mutatorPropertiesMatch_(mutatorProperties,
            block)) throw Error('Error when applying extension "' + name + '": ' + "mutation properties changed when applying a non-mutator extension.");
};
Blockly.Extensions.checkHasFunction_ = function(errorPrefix, func, propertyName) {
    if (!func) throw Error(errorPrefix + 'missing required property "' + propertyName + '"');
    else if (typeof func != "function") throw Error(errorPrefix + '" required property "' + propertyName + '" must be a function');
};
Blockly.Extensions.checkNoMutatorProperties_ = function(mutationName, block) {
    var properties = Blockly.Extensions.getMutatorProperties_(block);
    if (properties.length) throw Error('Error: tried to apply mutation "' + mutationName + '" to a block that already has mutator functions.' + "  Block id: " + block.id);
};
Blockly.Extensions.checkMutatorDialog_ = function(object, errorPrefix) {
    var hasCompose = object.compose !== undefined;
    var hasDecompose = object.decompose !== undefined;
    if (hasCompose && hasDecompose) {
        if (typeof object.compose != "function") throw Error(errorPrefix + "compose must be a function.");
        else if (typeof object.decompose != "function") throw Error(errorPrefix + "decompose must be a function.");
        return true
    } else if (!hasCompose && !hasDecompose) return false;
    else throw Error(errorPrefix + 'Must have both or neither of "compose" and "decompose"');
};
Blockly.Extensions.checkBlockHasMutatorProperties_ = function(errorPrefix, block) {
    if (typeof block.domToMutation != "function") throw Error(errorPrefix + 'Applying a mutator didn\'t add "domToMutation"');
    if (typeof block.mutationToDom != "function") throw Error(errorPrefix + 'Applying a mutator didn\'t add "mutationToDom"');
    Blockly.Extensions.checkMutatorDialog_(block, errorPrefix)
};
Blockly.Extensions.getMutatorProperties_ = function(block) {
    var result = [];
    if (block.domToMutation !== undefined) result.push(block.domToMutation);
    if (block.mutationToDom !== undefined) result.push(block.mutationToDom);
    if (block.compose !== undefined) result.push(block.compose);
    if (block.decompose !== undefined) result.push(block.decompose);
    return result
};
Blockly.Extensions.mutatorPropertiesMatch_ = function(oldProperties, block) {
    var newProperties = Blockly.Extensions.getMutatorProperties_(block);
    if (newProperties.length != oldProperties.length) return false;
    for (var i = 0; i < newProperties.length; i++)
        if (oldProperties[i] != newProperties[i]) return false;
    return true
};
Blockly.Extensions.buildTooltipForDropdown = function(dropdownName, lookupTable) {
    var blockTypesChecked = [];
    if (typeof document == "object") Blockly.utils.runAfterPageLoad(function() {
        for (var key in lookupTable) Blockly.utils.checkMessageReferences(lookupTable[key])
    });
    var extensionFn = function() {
        if (this.type && blockTypesChecked.indexOf(this.type) === -1) {
            Blockly.Extensions.checkDropdownOptionsInTable_(this, dropdownName, lookupTable);
            blockTypesChecked.push(this.type)
        }
        this.setTooltip(function() {
            var value = this.getFieldValue(dropdownName);
            var tooltip = lookupTable[value];
            if (tooltip == null) {
                if (blockTypesChecked.indexOf(this.type) === -1) {
                    var warning = "No tooltip mapping for value " + value + " of field " + dropdownName;
                    if (this.type != null) warning += " of block type " + this.type;
                    console.warn(warning + ".")
                }
            } else tooltip = Blockly.utils.replaceMessageReferences(tooltip);
            return tooltip
        }.bind(this))
    };
    return extensionFn
};
Blockly.Extensions.checkDropdownOptionsInTable_ = function(block, dropdownName, lookupTable) {
    var dropdown = block.getField(dropdownName);
    if (!dropdown.isOptionListDynamic()) {
        var options = dropdown.getOptions();
        for (var i = 0; i < options.length; ++i) {
            var optionKey = options[i][1];
            if (lookupTable[optionKey] == null) console.warn("No tooltip mapping for value " + optionKey + " of field " + dropdownName + " of block type " + block.type)
        }
    }
};
Blockly.Extensions.buildTooltipWithFieldText = function(msgTemplate, fieldName) {
    if (typeof document == "object") Blockly.utils.runAfterPageLoad(function() {
        Blockly.utils.checkMessageReferences(msgTemplate)
    });
    var extensionFn = function() {
        this.setTooltip(function() {
            var field = this.getField(fieldName);
            return Blockly.utils.replaceMessageReferences(msgTemplate).replace("%1", field ? field.getText() : "")
        }.bind(this))
    };
    return extensionFn
};
Blockly.Extensions.extensionParentTooltip_ = function() {
    this.tooltipWhenNotConnected_ = this.tooltip;
    this.setTooltip(function() {
        var parent = this.getParent();
        return parent && parent.getInputsInline() && parent.tooltip || this.tooltipWhenNotConnected_
    }.bind(this))
};
Blockly.Extensions.register("parent_tooltip_when_inline", Blockly.Extensions.extensionParentTooltip_);
goog.provide("Blockly.Field");
goog.require("Blockly.Events.BlockChange");
goog.require("Blockly.Gesture");
goog.require("Blockly.utils");
goog.require("goog.math.Size");
goog.require("goog.style");
goog.require("goog.userAgent");
Blockly.Field = function(text, opt_validator) {
    this.size_ = new goog.math.Size(0, Blockly.BlockSvg.MIN_BLOCK_Y);
    this.setValue(text);
    this.setValidator(opt_validator)
};
Blockly.Field.TYPE_MAP_ = {};
Blockly.Field.register = function(type, fieldClass) {
    if (typeof type != "string" || type.trim() == "") throw Error('Invalid field type "' + type + '"');
    if (!fieldClass || typeof fieldClass.fromJson != "function") throw Error('Field "' + fieldClass + '" must have a fromJson function');
    Blockly.Field.TYPE_MAP_[type] = fieldClass
};
Blockly.Field.fromJson = function(options) {
    var fieldClass = Blockly.Field.TYPE_MAP_[options["type"]];
    if (fieldClass) return fieldClass.fromJson(options);
    return null
};
Blockly.Field.cacheWidths_ = null;
Blockly.Field.cacheReference_ = 0;
Blockly.Field.prototype.name = undefined;
Blockly.Field.prototype.maxDisplayLength = 50;
Blockly.Field.prototype.text_ = "";
Blockly.Field.prototype.sourceBlock_ = null;
Blockly.Field.prototype.visible_ = true;
Blockly.Field.prototype.validator_ = null;
Blockly.Field.NBSP = "\u00a0";
Blockly.Field.prototype.EDITABLE = true;
Blockly.Field.prototype.setSourceBlock = function(block) {
    if (this.sourceBlock_) throw Error("Field already bound to a block.");
    this.sourceBlock_ = block
};
Blockly.Field.prototype.init = function() {
    if (this.fieldGroup_) return;
    this.fieldGroup_ = Blockly.utils.createSvgElement("g", {}, null);
    if (!this.visible_) this.fieldGroup_.style.display = "none";
    this.borderRect_ = Blockly.utils.createSvgElement("rect", {
        "rx": 4,
        "ry": 4,
        "x": -Blockly.BlockSvg.SEP_SPACE_X / 2,
        "y": 0,
        "height": 16
    }, this.fieldGroup_);
    this.textElement_ = Blockly.utils.createSvgElement("text", {
        "class": "blocklyText",
        "y": this.size_.height - 12.5
    }, this.fieldGroup_);
    this.updateEditable();
    this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_);
    this.mouseDownWrapper_ = Blockly.bindEventWithChecks_(this.fieldGroup_, "mousedown", this, this.onMouseDown_);
    this.render_()
};
Blockly.Field.prototype.initModel = function() {};
Blockly.Field.prototype.dispose = function() {
    if (this.mouseDownWrapper_) {
        Blockly.unbindEvent_(this.mouseDownWrapper_);
        this.mouseDownWrapper_ = null
    }
    this.sourceBlock_ = null;
    if (this.fieldGroup_) {
        Blockly.utils.removeNode(this.fieldGroup_);
        this.fieldGroup_ = null
    }
    this.textElement_ = null;
    this.borderRect_ = null;
    this.validator_ = null
};
Blockly.Field.prototype.updateEditable = function() {
    var group = this.fieldGroup_;
    if (!this.EDITABLE || !group) return;
    if (this.sourceBlock_.isEditable()) {
        Blockly.utils.addClass(group, "blocklyEditableText");
        Blockly.utils.removeClass(group, "blocklyNonEditableText");
        this.fieldGroup_.style.cursor = this.CURSOR
    } else {
        Blockly.utils.addClass(group, "blocklyNonEditableText");
        Blockly.utils.removeClass(group, "blocklyEditableText");
        this.fieldGroup_.style.cursor = ""
    }
};
Blockly.Field.prototype.isCurrentlyEditable = function() {
    return this.EDITABLE && !!this.sourceBlock_ && this.sourceBlock_.isEditable()
};
Blockly.Field.prototype.isVisible = function() {
    return this.visible_
};
Blockly.Field.prototype.setVisible = function(visible) {
    if (this.visible_ == visible) return;
    this.visible_ = visible;
    var root = this.getSvgRoot();
    if (root) {
        root.style.display = visible ? "block" : "none";
        this.render_()
    }
};
Blockly.Field.prototype.setValidator = function(handler) {
    this.validator_ = handler
};
Blockly.Field.prototype.getValidator = function() {
    return this.validator_
};
Blockly.Field.prototype.classValidator = function(text) {
    return text
};
Blockly.Field.prototype.callValidator = function(text) {
    var classResult = this.classValidator(text);
    if (classResult === null) return null;
    else if (classResult !== undefined) text = classResult;
    var userValidator = this.getValidator();
    if (userValidator) {
        var userResult = userValidator.call(this, text);
        if (userResult === null) return null;
        else if (userResult !== undefined) text = userResult
    }
    return text
};
Blockly.Field.prototype.getSvgRoot = function() {
    return this.fieldGroup_
};
Blockly.Field.prototype.render_ = function() {
    if (!this.visible_) {
        this.size_.width = 0;
        return
    }
    this.textElement_.textContent = this.getDisplayText_();
    this.updateWidth()
};
Blockly.Field.prototype.updateWidth = function() {
    var width = Blockly.Field.getCachedWidth(this.textElement_);
    if (this.borderRect_) this.borderRect_.setAttribute("width", width + Blockly.BlockSvg.SEP_SPACE_X);
    this.size_.width = width
};
Blockly.Field.getCachedWidth = function(textElement) {
    var key = textElement.textContent + "\n" + textElement.className.baseVal;
    var width;
    if (Blockly.Field.cacheWidths_) {
        width = Blockly.Field.cacheWidths_[key];
        if (width) return width
    }
    try {
        if (goog.userAgent.IE || goog.userAgent.EDGE) width = textElement.getBBox().width;
        else width = textElement.getComputedTextLength()
    } catch (e) {
        return textElement.textContent.length * 8
    }
    if (Blockly.Field.cacheWidths_) Blockly.Field.cacheWidths_[key] = width;
    return width
};
Blockly.Field.startCache = function() {
    Blockly.Field.cacheReference_++;
    if (!Blockly.Field.cacheWidths_) Blockly.Field.cacheWidths_ = {}
};
Blockly.Field.stopCache = function() {
    Blockly.Field.cacheReference_--;
    if (!Blockly.Field.cacheReference_) Blockly.Field.cacheWidths_ = null
};
Blockly.Field.prototype.getSize = function() {
    if (!this.size_.width) this.render_();
    return this.size_
};
Blockly.Field.prototype.getScaledBBox_ = function() {
    var bBox = this.borderRect_.getBBox();
    var scaledHeight = bBox.height * this.sourceBlock_.workspace.scale;
    var scaledWidth = bBox.width * this.sourceBlock_.workspace.scale;
    var xy = this.getAbsoluteXY_();
    return {
        top: xy.y,
        bottom: xy.y + scaledHeight,
        left: xy.x,
        right: xy.x + scaledWidth
    }
};
Blockly.Field.prototype.getDisplayText_ = function() {
    var text = this.text_;
    if (!text) return Blockly.Field.NBSP;
    if (text.length > this.maxDisplayLength) text = text.substring(0, this.maxDisplayLength - 2) + "\u2026";
    text = text.replace(/\s/g, Blockly.Field.NBSP);
    if (this.sourceBlock_.RTL) text += "\u200f";
    return text
};
Blockly.Field.prototype.getText = function() {
    return this.text_
};
Blockly.Field.prototype.setText = function(newText) {
    if (newText === null) return;
    newText = String(newText);
    if (newText === this.text_) return;
    this.text_ = newText;
    this.forceRerender()
};
Blockly.Field.prototype.forceRerender = function() {
    this.size_.width = 0;
    if (this.sourceBlock_ && this.sourceBlock_.rendered) {
        this.sourceBlock_.render();
        this.sourceBlock_.bumpNeighbours_()
    }
};
Blockly.Field.prototype.getValue = function() {
    return this.getText()
};
Blockly.Field.prototype.setValue = function(newValue) {
    if (newValue === null) return;
    var oldValue = this.getValue();
    if (oldValue == newValue) return;
    if (this.sourceBlock_ && Blockly.Events.isEnabled()) Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_, "field", this.name, oldValue, newValue));
    this.setText(newValue)
};
Blockly.Field.prototype.onMouseDown_ = function(e) {
    if (!this.sourceBlock_ || !this.sourceBlock_.workspace) return;
    var gesture = this.sourceBlock_.workspace.getGesture(e);
    if (gesture) gesture.setStartField(this)
};
Blockly.Field.prototype.setTooltip = function(_newTip) {};
Blockly.Field.prototype.getAbsoluteXY_ = function() {
    return goog.style.getPageOffset(this.borderRect_)
};
Blockly.Field.prototype.referencesVariables = function() {
    return false
};
goog.provide("Blockly.FieldAngle");
goog.require("Blockly.FieldTextInput");
goog.require("Blockly.utils");
goog.require("goog.userAgent");
Blockly.FieldAngle = function(opt_value, opt_validator) {
    this.symbol_ = Blockly.utils.createSvgElement("tspan", {}, null);
    this.symbol_.appendChild(document.createTextNode("\u00b0"));
    opt_value = opt_value && !isNaN(opt_value) ? String(opt_value) : "0";
    Blockly.FieldAngle.superClass_.constructor.call(this, opt_value, opt_validator)
};
goog.inherits(Blockly.FieldAngle, Blockly.FieldTextInput);
Blockly.FieldAngle.fromJson = function(options) {
    return new Blockly.FieldAngle(options["angle"])
};
Blockly.FieldAngle.ROUND = 15;
Blockly.FieldAngle.HALF = 100 / 2;
Blockly.FieldAngle.CLOCKWISE = false;
Blockly.FieldAngle.OFFSET = 0;
Blockly.FieldAngle.WRAP = 360;
Blockly.FieldAngle.RADIUS = Blockly.FieldAngle.HALF - 1;
Blockly.FieldAngle.prototype.render_ = function() {
    if (!this.visible_) {
        this.size_.width = 0;
        return
    }
    this.textElement_.textContent = this.getDisplayText_();
    if (this.sourceBlock_.RTL) this.textElement_.insertBefore(this.symbol_, this.textElement_.firstChild);
    else this.textElement_.appendChild(this.symbol_);
    this.updateWidth()
};
Blockly.FieldAngle.prototype.dispose_ = function() {
    var thisField = this;
    return function() {
        Blockly.FieldAngle.superClass_.dispose_.call(thisField)();
        thisField.gauge_ = null;
        if (thisField.clickWrapper_) Blockly.unbindEvent_(thisField.clickWrapper_);
        if (thisField.moveWrapper1_) Blockly.unbindEvent_(thisField.moveWrapper1_);
        if (thisField.moveWrapper2_) Blockly.unbindEvent_(thisField.moveWrapper2_)
    }
};
Blockly.FieldAngle.prototype.showEditor_ = function() {
    var noFocus = goog.userAgent.MOBILE || goog.userAgent.ANDROID || goog.userAgent.IPAD;
    Blockly.FieldAngle.superClass_.showEditor_.call(this, noFocus);
    var div = Blockly.WidgetDiv.DIV;
    if (!div.firstChild) return;
    var svg = Blockly.utils.createSvgElement("svg", {
        "xmlns": "http://www.w3.org/2000/svg",
        "xmlns:html": "http://www.w3.org/1999/xhtml",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "version": "1.1",
        "height": Blockly.FieldAngle.HALF * 2 + "px",
        "width": Blockly.FieldAngle.HALF *
            2 + "px"
    }, div);
    var circle = Blockly.utils.createSvgElement("circle", {
        "cx": Blockly.FieldAngle.HALF,
        "cy": Blockly.FieldAngle.HALF,
        "r": Blockly.FieldAngle.RADIUS,
        "class": "blocklyAngleCircle"
    }, svg);
    this.gauge_ = Blockly.utils.createSvgElement("path", {
        "class": "blocklyAngleGauge"
    }, svg);
    this.line_ = Blockly.utils.createSvgElement("line", {
        "x1": Blockly.FieldAngle.HALF,
        "y1": Blockly.FieldAngle.HALF,
        "class": "blocklyAngleLine"
    }, svg);
    for (var angle = 0; angle < 360; angle += 15) Blockly.utils.createSvgElement("line", {
        "x1": Blockly.FieldAngle.HALF +
            Blockly.FieldAngle.RADIUS,
        "y1": Blockly.FieldAngle.HALF,
        "x2": Blockly.FieldAngle.HALF + Blockly.FieldAngle.RADIUS - (angle % 45 == 0 ? 10 : 5),
        "y2": Blockly.FieldAngle.HALF,
        "class": "blocklyAngleMarks",
        "transform": "rotate(" + angle + "," + Blockly.FieldAngle.HALF + "," + Blockly.FieldAngle.HALF + ")"
    }, svg);
    svg.style.marginLeft = 15 - Blockly.FieldAngle.RADIUS + "px";
    this.clickWrapper_ = Blockly.bindEvent_(svg, "click", this, Blockly.WidgetDiv.hide);
    this.moveWrapper1_ = Blockly.bindEvent_(circle, "mousemove", this, this.onMouseMove);
    this.moveWrapper2_ =
        Blockly.bindEvent_(this.gauge_, "mousemove", this, this.onMouseMove);
    this.updateGraph_()
};
Blockly.FieldAngle.prototype.onMouseMove = function(e) {
    var bBox = this.gauge_.ownerSVGElement.getBoundingClientRect();
    var dx = e.clientX - bBox.left - Blockly.FieldAngle.HALF;
    var dy = e.clientY - bBox.top - Blockly.FieldAngle.HALF;
    var angle = Math.atan(-dy / dx);
    if (isNaN(angle)) return;
    angle = Blockly.utils.toDegrees(angle);
    if (dx < 0) angle += 180;
    else if (dy > 0) angle += 360;
    if (Blockly.FieldAngle.CLOCKWISE) angle = Blockly.FieldAngle.OFFSET + 360 - angle;
    else angle -= Blockly.FieldAngle.OFFSET;
    if (Blockly.FieldAngle.ROUND) angle = Math.round(angle /
        Blockly.FieldAngle.ROUND) * Blockly.FieldAngle.ROUND;
    angle = this.callValidator(angle);
    Blockly.FieldTextInput.htmlInput_.value = angle;
    this.setValue(angle);
    this.validate_();
    this.resizeEditor_()
};
Blockly.FieldAngle.prototype.setText = function(text) {
    Blockly.FieldAngle.superClass_.setText.call(this, text);
    if (!this.textElement_) return;
    this.updateGraph_();
    this.size_.width = 0
};
Blockly.FieldAngle.prototype.updateGraph_ = function() {
    if (!this.gauge_) return;
    var angleDegrees = Number(this.getText()) + Blockly.FieldAngle.OFFSET;
    var angleRadians = Blockly.utils.toRadians(angleDegrees);
    var path = ["M ", Blockly.FieldAngle.HALF, ",", Blockly.FieldAngle.HALF];
    var x2 = Blockly.FieldAngle.HALF;
    var y2 = Blockly.FieldAngle.HALF;
    if (!isNaN(angleRadians)) {
        var angle1 = Blockly.utils.toRadians(Blockly.FieldAngle.OFFSET);
        var x1 = Math.cos(angle1) * Blockly.FieldAngle.RADIUS;
        var y1 = Math.sin(angle1) * -Blockly.FieldAngle.RADIUS;
        if (Blockly.FieldAngle.CLOCKWISE) angleRadians = 2 * angle1 - angleRadians;
        x2 += Math.cos(angleRadians) * Blockly.FieldAngle.RADIUS;
        y2 -= Math.sin(angleRadians) * Blockly.FieldAngle.RADIUS;
        var largeFlag = Math.abs(Math.floor((angleRadians - angle1) / Math.PI) % 2);
        if (Blockly.FieldAngle.CLOCKWISE) largeFlag = 1 - largeFlag;
        var sweepFlag = Number(Blockly.FieldAngle.CLOCKWISE);
        path.push(" l ", x1, ",", y1, " A ", Blockly.FieldAngle.RADIUS, ",", Blockly.FieldAngle.RADIUS, " 0 ", largeFlag, " ", sweepFlag, " ", x2, ",", y2, " z")
    }
    this.gauge_.setAttribute("d",
        path.join(""));
    this.line_.setAttribute("x2", x2);
    this.line_.setAttribute("y2", y2)
};
Blockly.FieldAngle.prototype.classValidator = function(text) {
    if (text === null) return null;
    var n = parseFloat(text || 0);
    if (isNaN(n)) return null;
    n = n % 360;
    if (n < 0) n += 360;
    if (n > Blockly.FieldAngle.WRAP) n -= 360;
    return String(n)
};
Blockly.Field.register("field_angle", Blockly.FieldAngle);
goog.provide("Blockly.FieldCheckbox");
goog.require("Blockly.Field");
goog.require("Blockly.utils");
Blockly.FieldCheckbox = function(state, opt_validator) {
    Blockly.FieldCheckbox.superClass_.constructor.call(this, "", opt_validator);
    this.setValue(state)
};
goog.inherits(Blockly.FieldCheckbox, Blockly.Field);
Blockly.FieldCheckbox.fromJson = function(options) {
    return new Blockly.FieldCheckbox(options["checked"] ? "TRUE" : "FALSE")
};
Blockly.FieldCheckbox.CHECK_CHAR = "\u2713";
Blockly.FieldCheckbox.prototype.CURSOR = "default";
Blockly.FieldCheckbox.prototype.init = function() {
    if (this.fieldGroup_) return;
    Blockly.FieldCheckbox.superClass_.init.call(this);
    this.checkElement_ = Blockly.utils.createSvgElement("text", {
        "class": "blocklyText blocklyCheckbox",
        "x": -3,
        "y": 14
    }, this.fieldGroup_);
    var textNode = document.createTextNode(Blockly.FieldCheckbox.CHECK_CHAR);
    this.checkElement_.appendChild(textNode);
    this.checkElement_.style.display = this.state_ ? "block" : "none"
};
Blockly.FieldCheckbox.prototype.getValue = function() {
    return String(this.state_).toUpperCase()
};
Blockly.FieldCheckbox.prototype.setValue = function(newBool) {
    var newState = typeof newBool == "string" ? newBool.toUpperCase() == "TRUE" : !!newBool;
    if (this.state_ !== newState) {
        if (this.sourceBlock_ && Blockly.Events.isEnabled()) Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_, "field", this.name, this.state_, newState));
        this.state_ = newState;
        if (this.checkElement_) this.checkElement_.style.display = newState ? "block" : "none"
    }
};
Blockly.FieldCheckbox.prototype.showEditor_ = function() {
    var newState = !this.state_;
    if (this.sourceBlock_) newState = this.callValidator(newState);
    if (newState !== null) this.setValue(String(newState).toUpperCase())
};
Blockly.Field.register("field_checkbox", Blockly.FieldCheckbox);
goog.provide("Blockly.FieldColour");
goog.require("Blockly.Field");
goog.require("Blockly.utils");
goog.require("goog.style");
Blockly.FieldColour = function(colour, opt_validator) {
    Blockly.FieldColour.superClass_.constructor.call(this, colour, opt_validator);
    this.setText(Blockly.Field.NBSP + Blockly.Field.NBSP + Blockly.Field.NBSP)
};
goog.inherits(Blockly.FieldColour, Blockly.Field);
Blockly.FieldColour.fromJson = function(options) {
    return new Blockly.FieldColour(options["colour"])
};
Blockly.FieldColour.prototype.colours_ = null;
Blockly.FieldColour.prototype.titles_ = null;
Blockly.FieldColour.prototype.columns_ = 0;
Blockly.FieldColour.prototype.init = function() {
    Blockly.FieldColour.superClass_.init.call(this);
    this.borderRect_.style["fillOpacity"] = 1;
    this.setValue(this.getValue())
};
Blockly.FieldColour.prototype.CURSOR = "default";
Blockly.FieldColour.prototype.dispose = function() {
    Blockly.WidgetDiv.hideIfOwner(this);
    Blockly.FieldColour.superClass_.dispose.call(this)
};
Blockly.FieldColour.prototype.getValue = function() {
    return this.colour_
};
Blockly.FieldColour.prototype.setValue = function(colour) {
    if (this.sourceBlock_ && Blockly.Events.isEnabled() && this.colour_ != colour) Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_, "field", this.name, this.colour_, colour));
    this.colour_ = colour;
    if (this.borderRect_) this.borderRect_.style.fill = colour
};
Blockly.FieldColour.prototype.getText = function() {
    var colour = this.colour_;
    var m = colour.match(/^#(.)\1(.)\2(.)\3$/);
    if (m) colour = "#" + m[1] + m[2] + m[3];
    return colour
};
Blockly.FieldColour.COLOURS = ["#ffffff", "#cccccc", "#c0c0c0", "#999999", "#666666", "#333333", "#000000", "#ffcccc", "#ff6666", "#ff0000", "#cc0000", "#990000", "#660000", "#330000", "#ffcc99", "#ff9966", "#ff9900", "#ff6600", "#cc6600", "#993300", "#663300", "#ffff99", "#ffff66", "#ffcc66", "#ffcc33", "#cc9933", "#996633", "#663333", "#ffffcc", "#ffff33", "#ffff00", "#ffcc00", "#999900", "#666600", "#333300", "#99ff99", "#66ff99", "#33ff33", "#33cc00", "#009900", "#006600", "#003300", "#99ffff", "#33ffff", "#66cccc", "#00cccc", "#339999", "#336666",
    "#003333", "#ccffff", "#66ffff", "#33ccff", "#3366ff", "#3333ff", "#000099", "#000066", "#ccccff", "#9999ff", "#6666cc", "#6633ff", "#6600cc", "#333399", "#330099", "#ffccff", "#ff99ff", "#cc66cc", "#cc33cc", "#993399", "#663366", "#330033"
];
Blockly.FieldColour.TITLES = [];
Blockly.FieldColour.COLUMNS = 7;
Blockly.FieldColour.prototype.setColours = function(colours, opt_titles) {
    this.colours_ = colours;
    if (opt_titles !== undefined) this.titles_ = opt_titles;
    return this
};
Blockly.FieldColour.prototype.setColumns = function(columns) {
    this.columns_ = columns;
    return this
};
Blockly.FieldColour.prototype.showEditor_ = function() {
    Blockly.WidgetDiv.show(this, this.sourceBlock_.RTL, Blockly.FieldColour.widgetDispose_);
    var viewportBBox = Blockly.utils.getViewportBBox();
    var anchorBBox = this.getScaledBBox_();
    var picker = this.createWidget_();
    Blockly.WidgetDiv.DIV.appendChild(picker);
    var paletteSize = goog.style.getSize(picker);
    Blockly.WidgetDiv.positionWithAnchor(viewportBBox, anchorBBox, paletteSize, this.sourceBlock_.RTL);
    Blockly.FieldColour.onUpWrapper_ = Blockly.bindEvent_(picker, "mouseup",
        this, this.onClick_)
};
Blockly.FieldColour.prototype.onClick_ = function(e) {
    var cell = e.target;
    if (cell && !cell.label) cell = cell.parentNode;
    var colour = cell && cell.label;
    Blockly.WidgetDiv.hide();
    if (this.sourceBlock_) colour = this.callValidator(colour);
    if (colour !== null) this.setValue(colour)
};
Blockly.FieldColour.prototype.createWidget_ = function() {
    var columns = this.columns_ || Blockly.FieldColour.COLUMNS;
    var colours = this.colours_ || Blockly.FieldColour.COLOURS;
    var titles = this.titles_ || Blockly.FieldColour.TITLES;
    var selectedColour = this.getValue();
    var table = document.createElement("table");
    table.className = "blocklyColourTable";
    var row;
    for (var i = 0; i < colours.length; i++) {
        if (i % columns == 0) {
            row = document.createElement("tr");
            table.appendChild(row)
        }
        var cell = document.createElement("td");
        row.appendChild(cell);
        var div = document.createElement("div");
        cell.appendChild(div);
        cell.label = colours[i];
        cell.title = titles[i] || colours[i];
        div.style.backgroundColor = colours[i];
        if (colours[i] == selectedColour) div.className = "blocklyColourSelected"
    }
    return table
};
Blockly.FieldColour.widgetDispose_ = function() {
    if (Blockly.FieldColour.onUpWrapper_) Blockly.unbindEvent_(Blockly.FieldColour.onUpWrapper_);
    Blockly.Events.setGroup(false)
};
Blockly.Field.register("field_colour", Blockly.FieldColour);
goog.provide("Blockly.FieldDropdown");
goog.require("Blockly.Field");
goog.require("Blockly.utils");
goog.require("Blockly.utils.uiMenu");
goog.require("goog.events");
goog.require("goog.ui.Menu");
goog.require("goog.ui.MenuItem");
goog.require("goog.userAgent");
Blockly.FieldDropdown = function(menuGenerator, opt_validator) {
    if (typeof menuGenerator != "function") Blockly.FieldDropdown.validateOptions_(menuGenerator);
    this.menuGenerator_ = menuGenerator;
    this.trimOptions_();
    var firstTuple = this.getOptions()[0];
    Blockly.FieldDropdown.superClass_.constructor.call(this, firstTuple[1], opt_validator)
};
goog.inherits(Blockly.FieldDropdown, Blockly.Field);
Blockly.FieldDropdown.fromJson = function(options) {
    return new Blockly.FieldDropdown(options["options"])
};
Blockly.FieldDropdown.CHECKMARK_OVERHANG = 0;
Blockly.FieldDropdown.MAX_MENU_HEIGHT_VH = .45;
Blockly.FieldDropdown.ARROW_CHAR = goog.userAgent.ANDROID ? "\u25bc" : "\u25be";
Blockly.FieldDropdown.prototype.CURSOR = "default";
Blockly.FieldDropdown.prototype.value_ = "";
Blockly.FieldDropdown.prototype.imageElement_ = null;
Blockly.FieldDropdown.prototype.imageJson_ = null;
Blockly.FieldDropdown.prototype.init = function() {
    if (this.fieldGroup_) return;
    this.arrow_ = Blockly.utils.createSvgElement("tspan", {}, null);
    this.arrow_.appendChild(document.createTextNode(this.sourceBlock_.RTL ? Blockly.FieldDropdown.ARROW_CHAR + " " : " " + Blockly.FieldDropdown.ARROW_CHAR));
    Blockly.FieldDropdown.superClass_.init.call(this)
};
Blockly.FieldDropdown.prototype.showEditor_ = function() {
    Blockly.WidgetDiv.show(this, this.sourceBlock_.RTL, null);
    var menu = this.createMenu_();
    this.addActionListener_(menu);
    this.positionMenu_(menu)
};
Blockly.FieldDropdown.prototype.addActionListener_ = function(menu) {
    var thisField = this;

    function callback(e) {
        var menu = this;
        var menuItem = e.target;
        if (menuItem) thisField.onItemSelected(menu, menuItem);
        Blockly.WidgetDiv.hideIfOwner(thisField);
        Blockly.Events.setGroup(false)
    }
    goog.events.listen(menu, goog.ui.Component.EventType.ACTION, callback)
};
Blockly.FieldDropdown.prototype.createMenu_ = function() {
    var menu = new goog.ui.Menu;
    menu.setRightToLeft(this.sourceBlock_.RTL);
    var options = this.getOptions();
    for (var i = 0; i < options.length; i++) {
        var content = options[i][0];
        var value = options[i][1];
        if (typeof content == "object") {
            var image = new Image(content["width"], content["height"]);
            image.src = content["src"];
            image.alt = content["alt"] || "";
            content = image
        }
        var menuItem = new goog.ui.MenuItem(content);
        menuItem.setRightToLeft(this.sourceBlock_.RTL);
        menuItem.setValue(value);
        menuItem.setCheckable(true);
        menu.addChild(menuItem, true);
        menuItem.setChecked(value == this.value_)
    }
    return menu
};
Blockly.FieldDropdown.prototype.positionMenu_ = function(menu) {
    var viewportBBox = Blockly.utils.getViewportBBox();
    var anchorBBox = this.getAnchorDimensions_();
    this.createWidget_(menu);
    var menuSize = Blockly.utils.uiMenu.getSize(menu);
    var menuMaxHeightPx = Blockly.FieldDropdown.MAX_MENU_HEIGHT_VH * document.documentElement.clientHeight;
    if (menuSize.height > menuMaxHeightPx) menuSize.height = menuMaxHeightPx;
    if (this.sourceBlock_.RTL) Blockly.utils.uiMenu.adjustBBoxesForRTL(viewportBBox, anchorBBox, menuSize);
    Blockly.WidgetDiv.positionWithAnchor(viewportBBox,
        anchorBBox, menuSize, this.sourceBlock_.RTL);
    menu.getElement().focus()
};
Blockly.FieldDropdown.prototype.createWidget_ = function(menu) {
    var div = Blockly.WidgetDiv.DIV;
    menu.render(div);
    Blockly.utils.addClass(menu.getElement(), "blocklyDropdownMenu");
    menu.setAllowAutoFocus(true)
};
Blockly.FieldDropdown.prototype.getAnchorDimensions_ = function() {
    var boundingBox = this.getScaledBBox_();
    if (this.sourceBlock_.RTL) boundingBox.right += Blockly.FieldDropdown.CHECKMARK_OVERHANG;
    else boundingBox.left -= Blockly.FieldDropdown.CHECKMARK_OVERHANG;
    return boundingBox
};
Blockly.FieldDropdown.prototype.onItemSelected = function(menu, menuItem) {
    var value = menuItem.getValue();
    if (this.sourceBlock_) value = this.callValidator(value);
    if (value !== null) this.setValue(value)
};
Blockly.FieldDropdown.prototype.trimOptions_ = function() {
    this.prefixField = null;
    this.suffixField = null;
    var options = this.menuGenerator_;
    if (!Array.isArray(options)) return;
    var hasImages = false;
    for (var i = 0; i < options.length; i++) {
        var label = options[i][0];
        if (typeof label == "string") options[i][0] = Blockly.utils.replaceMessageReferences(label);
        else {
            if (label.alt != null) options[i][0].alt = Blockly.utils.replaceMessageReferences(label.alt);
            hasImages = true
        }
    }
    if (hasImages || options.length < 2) return;
    var strings = [];
    for (var i =
            0; i < options.length; i++) strings.push(options[i][0]);
    var shortest = Blockly.utils.shortestStringLength(strings);
    var prefixLength = Blockly.utils.commonWordPrefix(strings, shortest);
    var suffixLength = Blockly.utils.commonWordSuffix(strings, shortest);
    if (!prefixLength && !suffixLength) return;
    if (shortest <= prefixLength + suffixLength) return;
    if (prefixLength) this.prefixField = strings[0].substring(0, prefixLength - 1);
    if (suffixLength) this.suffixField = strings[0].substr(1 - suffixLength);
    this.menuGenerator_ = Blockly.FieldDropdown.applyTrim_(options,
        prefixLength, suffixLength)
};
Blockly.FieldDropdown.applyTrim_ = function(options, prefixLength, suffixLength) {
    var newOptions = [];
    for (var i = 0; i < options.length; i++) {
        var text = options[i][0];
        var value = options[i][1];
        text = text.substring(prefixLength, text.length - suffixLength);
        newOptions[i] = [text, value]
    }
    return newOptions
};
Blockly.FieldDropdown.prototype.isOptionListDynamic = function() {
    return typeof this.menuGenerator_ == "function"
};
Blockly.FieldDropdown.prototype.getOptions = function() {
    if (this.isOptionListDynamic()) {
        var generatedOptions = this.menuGenerator_.call(this);
        Blockly.FieldDropdown.validateOptions_(generatedOptions);
        return generatedOptions
    }
    return this.menuGenerator_
};
Blockly.FieldDropdown.prototype.getValue = function() {
    return this.value_
};
Blockly.FieldDropdown.prototype.setValue = function(newValue) {
    if (newValue === null || newValue === this.value_) return;
    if (this.sourceBlock_ && Blockly.Events.isEnabled()) Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_, "field", this.name, this.value_, newValue));
    this.value_ = newValue;
    var options = this.getOptions();
    for (var i = 0; i < options.length; i++)
        if (options[i][1] == newValue) {
            var content = options[i][0];
            if (typeof content == "object") {
                this.imageJson_ = content;
                this.text_ = content.alt
            } else {
                this.imageJson_ =
                    null;
                this.text_ = content
            }
            this.forceRerender();
            return
        } this.text_ = newValue;
    this.forceRerender()
};
Blockly.FieldDropdown.prototype.render_ = function() {
    if (!this.visible_) {
        this.size_.width = 0;
        return
    }
    if (this.sourceBlock_ && this.arrow_) this.arrow_.style.fill = this.sourceBlock_.getColour();
    var child;
    while (child = this.textElement_.firstChild) this.textElement_.removeChild(child);
    if (this.imageElement_) {
        Blockly.utils.removeNode(this.imageElement_);
        this.imageElement_ = null
    }
    if (this.imageJson_) this.renderSelectedImage_();
    else this.renderSelectedText_();
    this.borderRect_.setAttribute("height", this.size_.height - 9);
    this.borderRect_.setAttribute("width", this.size_.width + Blockly.BlockSvg.SEP_SPACE_X)
};
Blockly.FieldDropdown.prototype.renderSelectedImage_ = function() {
    this.imageElement_ = Blockly.utils.createSvgElement("image", {
        "y": 5,
        "height": this.imageJson_.height + "px",
        "width": this.imageJson_.width + "px"
    }, this.fieldGroup_);
    this.imageElement_.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.imageJson_.src);
    this.textElement_.appendChild(this.arrow_);
    var arrowWidth = Blockly.Field.getCachedWidth(this.arrow_);
    this.size_.height = Number(this.imageJson_.height) + 19;
    this.size_.width = Number(this.imageJson_.width) +
        arrowWidth;
    if (this.sourceBlock_.RTL) {
        this.imageElement_.setAttribute("x", arrowWidth);
        this.textElement_.setAttribute("x", -1)
    } else {
        this.textElement_.setAttribute("text-anchor", "end");
        this.textElement_.setAttribute("x", this.size_.width + 1)
    }
};
Blockly.FieldDropdown.prototype.renderSelectedText_ = function() {
    var textNode = document.createTextNode(this.getDisplayText_());
    this.textElement_.appendChild(textNode);
    if (this.sourceBlock_.RTL) this.textElement_.insertBefore(this.arrow_, this.textElement_.firstChild);
    else this.textElement_.appendChild(this.arrow_);
    this.textElement_.setAttribute("text-anchor", "start");
    this.textElement_.setAttribute("x", 0);
    this.size_.height = Blockly.BlockSvg.MIN_BLOCK_Y;
    this.size_.width = Blockly.Field.getCachedWidth(this.textElement_)
};
Blockly.FieldDropdown.prototype.updateWidth = function() {
    if (this.imageJson_ && (goog.userAgent.IE || goog.userAgent.EDGE)) {
        var arrowWidth = Blockly.Field.getCachedWidth(this.arrow_);
        var width = Number(this.imageJson_.width) + arrowWidth + Blockly.BlockSvg.SEP_SPACE_X;
        if (this.borderRect_) this.borderRect_.setAttribute("width", width);
        this.size_.width = width
    } else Blockly.Field.prototype.updateWidth.call(this)
};
Blockly.FieldDropdown.prototype.dispose = function() {
    Blockly.WidgetDiv.hideIfOwner(this);
    Blockly.FieldDropdown.superClass_.dispose.call(this)
};
Blockly.FieldDropdown.validateOptions_ = function(options) {
    if (!Array.isArray(options)) throw TypeError("FieldDropdown options must be an array.");
    var foundError = false;
    for (var i = 0; i < options.length; ++i) {
        var tuple = options[i];
        if (typeof tuple == "string") {
            tuple = [tuple, tuple];
            options[i] = tuple
        }
        if (!Array.isArray(tuple)) {
            foundError = true;
            console.error("Invalid option[" + i + "]: Each FieldDropdown option must be an " + "array. Found: ", tuple)
        } else if (typeof tuple[0] != "string" && typeof tuple[0].src != "string") {
            foundError =
                true;
            console.error("Invalid option[" + i + "]: Each FieldDropdown option must have a " + "string label or image description. Found" + tuple[0] + " in: ", tuple)
        } else if (tuple.length == 1) {
            tuple.push(tuple[0]);
            options[i] = tuple
        }
        if (typeof tuple[1] != "string") {
            foundError = true;
            console.error("Invalid option[" + i + "]: Each FieldDropdown option id must be " + "a string. Found " + tuple[1] + " in: ", tuple)
        }
    }
    if (foundError) throw TypeError("Found invalid FieldDropdown options.");
};
Blockly.Field.register("field_dropdown", Blockly.FieldDropdown);
goog.provide("Blockly.FieldImage");
goog.require("Blockly.Field");
goog.require("Blockly.utils");
goog.require("goog.math.Size");
Blockly.FieldImage = function(src, width, height, opt_alt, opt_onClick) {
    this.sourceBlock_ = null;
    this.height_ = Number(height);
    this.width_ = Number(width);
    this.size_ = new goog.math.Size(this.width_, this.height_ + 2 * Blockly.BlockSvg.INLINE_PADDING_Y);
    this.text_ = opt_alt || "";
    this.tooltip_ = "";
    this.setValue(src);
    if (typeof opt_onClick == "function") this.clickHandler_ = opt_onClick
};
goog.inherits(Blockly.FieldImage, Blockly.Field);
Blockly.FieldImage.fromJson = function(options) {
    var src = Blockly.utils.replaceMessageReferences(options["src"]);
    var width = Number(Blockly.utils.replaceMessageReferences(options["width"]));
    var height = Number(Blockly.utils.replaceMessageReferences(options["height"]));
    var alt = Blockly.utils.replaceMessageReferences(options["alt"]);
    return new Blockly.FieldImage(src, width, height, alt)
};
Blockly.FieldImage.prototype.EDITABLE = false;
Blockly.FieldImage.prototype.init = function() {
    if (this.fieldGroup_) return;
    this.fieldGroup_ = Blockly.utils.createSvgElement("g", {}, null);
    if (!this.visible_) this.fieldGroup_.style.display = "none";
    this.imageElement_ = Blockly.utils.createSvgElement("image", {
        "height": this.height_ + "px",
        "width": this.width_ + "px"
    }, this.fieldGroup_);
    this.setValue(this.src_);
    this.sourceBlock_.getSvgRoot().appendChild(this.fieldGroup_);
    if (this.tooltip_) this.imageElement_.tooltip = this.tooltip_;
    else this.setTooltip(this.sourceBlock_);
    Blockly.Tooltip.bindMouseEvents(this.imageElement_);
    this.maybeAddClickHandler_()
};
Blockly.FieldImage.prototype.dispose = function() {
    if (this.fieldGroup_) {
        Blockly.utils.removeNode(this.fieldGroup_);
        this.fieldGroup_ = null
    }
    this.imageElement_ = null
};
Blockly.FieldImage.prototype.maybeAddClickHandler_ = function() {
    if (this.clickHandler_) this.mouseDownWrapper_ = Blockly.bindEventWithChecks_(this.fieldGroup_, "mousedown", this, this.clickHandler_)
};
Blockly.FieldImage.prototype.setTooltip = function(newTip) {
    this.tooltip_ = newTip;
    if (this.imageElement_) this.imageElement_.tooltip = newTip
};
Blockly.FieldImage.prototype.getValue = function() {
    return this.src_
};
Blockly.FieldImage.prototype.setValue = function(src) {
    if (src === null) return;
    this.src_ = src;
    if (this.imageElement_) this.imageElement_.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", src || "")
};
Blockly.FieldImage.prototype.setText = function(alt) {
    if (alt === null) return;
    this.text_ = alt
};
Blockly.FieldImage.prototype.render_ = function() {};
Blockly.FieldImage.prototype.forceRerender = function() {};
Blockly.FieldImage.prototype.updateWidth = function() {};
Blockly.FieldImage.prototype.showEditor_ = function() {
    if (this.clickHandler_) this.clickHandler_(this)
};
Blockly.Field.register("field_image", Blockly.FieldImage);
goog.provide("Blockly.FieldLabel");
goog.require("Blockly.Field");
goog.require("Blockly.Tooltip");
goog.require("Blockly.utils");
goog.require("goog.math.Size");
Blockly.FieldLabel = function(text, opt_class) {
    this.size_ = new goog.math.Size(0, 17.5);
    this.class_ = opt_class;
    this.setValue(text);
    this.tooltip_ = ""
};
goog.inherits(Blockly.FieldLabel, Blockly.Field);
Blockly.FieldLabel.fromJson = function(options) {
    var text = Blockly.utils.replaceMessageReferences(options["text"]);
    return new Blockly.FieldLabel(text, options["class"])
};
Blockly.FieldLabel.prototype.EDITABLE = false;
Blockly.FieldLabel.prototype.init = function() {
    if (this.textElement_) return;
    this.textElement_ = Blockly.utils.createSvgElement("text", {
        "class": "blocklyText",
        "y": this.size_.height - 5
    }, null);
    if (this.class_) Blockly.utils.addClass(this.textElement_, this.class_);
    if (!this.visible_) this.textElement_.style.display = "none";
    this.sourceBlock_.getSvgRoot().appendChild(this.textElement_);
    if (this.tooltip_) this.textElement_.tooltip = this.tooltip_;
    else this.textElement_.tooltip = this.sourceBlock_;
    Blockly.Tooltip.bindMouseEvents(this.textElement_);
    this.render_()
};
Blockly.FieldLabel.prototype.dispose = function() {
    if (this.textElement_) {
        Blockly.utils.removeNode(this.textElement_);
        this.textElement_ = null
    }
};
Blockly.FieldLabel.prototype.getSvgRoot = function() {
    return this.textElement_
};
Blockly.FieldLabel.prototype.setTooltip = function(newTip) {
    this.tooltip_ = newTip;
    if (this.textElement_) this.textElement_.tooltip = newTip
};
Blockly.Field.register("field_label", Blockly.FieldLabel);
goog.provide("Blockly.FieldNumber");
goog.require("Blockly.FieldTextInput");
Blockly.FieldNumber = function(opt_value, opt_min, opt_max, opt_precision, opt_validator) {
    opt_value = opt_value && !isNaN(opt_value) ? String(opt_value) : "0";
    Blockly.FieldNumber.superClass_.constructor.call(this, opt_value, opt_validator);
    this.setConstraints(opt_min, opt_max, opt_precision)
};
goog.inherits(Blockly.FieldNumber, Blockly.FieldTextInput);
Blockly.FieldNumber.fromJson = function(options) {
    return new Blockly.FieldNumber(options["value"], options["min"], options["max"], options["precision"])
};
Blockly.FieldNumber.prototype.setConstraints = function(min, max, precision) {
    precision = parseFloat(precision);
    this.precision_ = isNaN(precision) ? 0 : precision;
    min = parseFloat(min);
    this.min_ = isNaN(min) ? -Infinity : min;
    max = parseFloat(max);
    this.max_ = isNaN(max) ? Infinity : max;
    this.setValue(this.callValidator(this.getValue()))
};
Blockly.FieldNumber.prototype.classValidator = function(text) {
    if (text === null) return null;
    text = String(text);
    text = text.replace(/O/ig, "0");
    text = text.replace(/,/g, "");
    var n = parseFloat(text || 0);
    if (isNaN(n)) return null;
    if (this.precision_ && isFinite(n)) n = Math.round(n / this.precision_) * this.precision_;
    n = Math.min(Math.max(n, this.min_), this.max_);
    return String(n)
};
Blockly.Field.register("field_number", Blockly.FieldNumber);
goog.provide("Blockly.FieldTextInput");
goog.require("Blockly.Field");
goog.require("Blockly.Msg");
goog.require("Blockly.utils");
goog.require("goog.math.Coordinate");
goog.require("goog.userAgent");
Blockly.FieldTextInput = function(text, opt_validator) {
    Blockly.FieldTextInput.superClass_.constructor.call(this, text, opt_validator)
};
goog.inherits(Blockly.FieldTextInput, Blockly.Field);
Blockly.FieldTextInput.fromJson = function(options) {
    var text = Blockly.utils.replaceMessageReferences(options["text"]);
    var field = new Blockly.FieldTextInput(text, options["class"]);
    if (typeof options["spellcheck"] === "boolean") field.setSpellcheck(options["spellcheck"]);
    return field
};
Blockly.FieldTextInput.FONTSIZE = 11;
Blockly.FieldTextInput.htmlInput_ = null;
Blockly.FieldTextInput.prototype.CURSOR = "text";
Blockly.FieldTextInput.prototype.spellcheck_ = true;
Blockly.FieldTextInput.prototype.dispose = function() {
    Blockly.WidgetDiv.hideIfOwner(this);
    Blockly.FieldTextInput.superClass_.dispose.call(this)
};
Blockly.FieldTextInput.prototype.setValue = function(newValue) {
    if (newValue !== null) {
        if (this.sourceBlock_) {
            var validated = this.callValidator(newValue);
            if (validated !== null) newValue = validated
        }
        Blockly.Field.prototype.setValue.call(this, newValue)
    }
};
Blockly.FieldTextInput.prototype.setText = function(newText) {
    if (newText === null) return;
    newText = String(newText);
    if (newText === this.text_) return;
    if (this.sourceBlock_ && Blockly.Events.isEnabled()) Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_, "field", this.name, this.text_, newText));
    Blockly.Field.prototype.setText.call(this, newText)
};
Blockly.FieldTextInput.prototype.setSpellcheck = function(check) {
    this.spellcheck_ = check
};
Blockly.FieldTextInput.prototype.showEditor_ = function(opt_quietInput) {
    this.workspace_ = this.sourceBlock_.workspace;
    var quietInput = opt_quietInput || false;
    if (!quietInput && (goog.userAgent.MOBILE || goog.userAgent.ANDROID || goog.userAgent.IPAD)) this.showPromptEditor_();
    else this.showInlineEditor_(quietInput)
};
Blockly.FieldTextInput.prototype.showPromptEditor_ = function() {
    var fieldText = this;
    Blockly.prompt(Blockly.Msg["CHANGE_VALUE_TITLE"], this.text_, function(newValue) {
        if (fieldText.sourceBlock_) newValue = fieldText.callValidator(newValue);
        fieldText.setValue(newValue)
    })
};
Blockly.FieldTextInput.prototype.showInlineEditor_ = function(quietInput) {
    Blockly.WidgetDiv.show(this, this.sourceBlock_.RTL, this.widgetDispose_());
    var div = Blockly.WidgetDiv.DIV;
    var htmlInput = document.createElement("input");
    htmlInput.className = "blocklyHtmlInput";
    htmlInput.setAttribute("spellcheck", this.spellcheck_);
    var fontSize = Blockly.FieldTextInput.FONTSIZE * this.workspace_.scale + "pt";
    div.style.fontSize = fontSize;
    htmlInput.style.fontSize = fontSize;
    Blockly.FieldTextInput.htmlInput_ = htmlInput;
    div.appendChild(htmlInput);
    htmlInput.value = htmlInput.defaultValue = this.text_;
    htmlInput.oldValue_ = null;
    this.validate_();
    this.resizeEditor_();
    if (!quietInput) {
        htmlInput.focus();
        htmlInput.select()
    }
    this.bindEvents_(htmlInput)
};
Blockly.FieldTextInput.prototype.bindEvents_ = function(htmlInput) {
    htmlInput.onKeyDownWrapper_ = Blockly.bindEventWithChecks_(htmlInput, "keydown", this, this.onHtmlInputKeyDown_);
    htmlInput.onKeyUpWrapper_ = Blockly.bindEventWithChecks_(htmlInput, "keyup", this, this.onHtmlInputChange_);
    htmlInput.onKeyPressWrapper_ = Blockly.bindEventWithChecks_(htmlInput, "keypress", this, this.onHtmlInputChange_);
    htmlInput.onWorkspaceChangeWrapper_ = this.resizeEditor_.bind(this);
    this.workspace_.addChangeListener(htmlInput.onWorkspaceChangeWrapper_)
};
Blockly.FieldTextInput.prototype.unbindEvents_ = function(htmlInput) {
    Blockly.unbindEvent_(htmlInput.onKeyDownWrapper_);
    Blockly.unbindEvent_(htmlInput.onKeyUpWrapper_);
    Blockly.unbindEvent_(htmlInput.onKeyPressWrapper_);
    this.workspace_.removeChangeListener(htmlInput.onWorkspaceChangeWrapper_)
};
Blockly.FieldTextInput.prototype.onHtmlInputKeyDown_ = function(e) {
    var htmlInput = Blockly.FieldTextInput.htmlInput_;
    var tabKey = 9,
        enterKey = 13,
        escKey = 27;
    if (e.keyCode == enterKey) Blockly.WidgetDiv.hide();
    else if (e.keyCode == escKey) {
        htmlInput.value = htmlInput.defaultValue;
        Blockly.WidgetDiv.hide()
    } else if (e.keyCode == tabKey) {
        Blockly.WidgetDiv.hide();
        this.sourceBlock_.tab(this, !e.shiftKey);
        e.preventDefault()
    }
};
Blockly.FieldTextInput.prototype.onHtmlInputChange_ = function(_e) {
    var htmlInput = Blockly.FieldTextInput.htmlInput_;
    var text = htmlInput.value;
    if (text !== htmlInput.oldValue_) {
        htmlInput.oldValue_ = text;
        this.setValue(text);
        this.validate_()
    } else if (goog.userAgent.WEBKIT) this.sourceBlock_.render();
    this.resizeEditor_();
    Blockly.svgResize(this.sourceBlock_.workspace)
};
Blockly.FieldTextInput.prototype.validate_ = function() {
    var valid = true;
    if (!Blockly.FieldTextInput.htmlInput_) throw Error("htmlInput not defined");
    var htmlInput = Blockly.FieldTextInput.htmlInput_;
    if (this.sourceBlock_) valid = this.callValidator(htmlInput.value);
    if (valid === null) Blockly.utils.addClass(htmlInput, "blocklyInvalidInput");
    else Blockly.utils.removeClass(htmlInput, "blocklyInvalidInput")
};
Blockly.FieldTextInput.prototype.resizeEditor_ = function() {
    var div = Blockly.WidgetDiv.DIV;
    var bBox = this.getScaledBBox_();
    div.style.width = bBox.right - bBox.left + "px";
    div.style.height = bBox.bottom - bBox.top + "px";
    var x = this.sourceBlock_.RTL ? bBox.right - div.offsetWidth : bBox.left;
    var xy = new goog.math.Coordinate(x, bBox.top);
    xy.y += 1;
    if (goog.userAgent.GECKO && Blockly.WidgetDiv.DIV.style.top) {
        xy.x -= 1;
        xy.y -= 1
    }
    if (goog.userAgent.WEBKIT) xy.y -= 3;
    div.style.left = xy.x + "px";
    div.style.top = xy.y + "px"
};
Blockly.FieldTextInput.prototype.widgetDispose_ = function() {
    var thisField = this;
    return function() {
        var htmlInput = Blockly.FieldTextInput.htmlInput_;
        thisField.maybeSaveEdit_();
        thisField.unbindEvents_(htmlInput);
        Blockly.FieldTextInput.htmlInput_ = null;
        Blockly.Events.setGroup(false);
        var style = Blockly.WidgetDiv.DIV.style;
        style.width = "auto";
        style.height = "auto";
        style.fontSize = ""
    }
};
Blockly.FieldTextInput.prototype.maybeSaveEdit_ = function() {
    var htmlInput = Blockly.FieldTextInput.htmlInput_;
    var text = htmlInput.value;
    if (this.sourceBlock_) {
        var text1 = this.callValidator(text);
        if (text1 === null) text = htmlInput.defaultValue;
        else {
            text = text1;
            if (this.onFinishEditing_) this.onFinishEditing_(text)
        }
    }
    this.setText(text);
    this.sourceBlock_.rendered && this.sourceBlock_.render()
};
Blockly.FieldTextInput.numberValidator = function(text) {
    console.warn("Blockly.FieldTextInput.numberValidator is deprecated. " + "Use Blockly.FieldNumber instead.");
    if (text === null) return null;
    text = String(text);
    text = text.replace(/O/ig, "0");
    text = text.replace(/,/g, "");
    var n = parseFloat(text || 0);
    return isNaN(n) ? null : String(n)
};
Blockly.FieldTextInput.nonnegativeIntegerValidator = function(text) {
    var n = Blockly.FieldTextInput.numberValidator(text);
    if (n) n = String(Math.max(0, Math.floor(n)));
    return n
};
Blockly.Field.register("field_input", Blockly.FieldTextInput);
goog.provide("Blockly.FieldVariable");
goog.require("Blockly.FieldDropdown");
goog.require("Blockly.Msg");
goog.require("Blockly.utils");
goog.require("Blockly.VariableModel");
goog.require("Blockly.Variables");
goog.require("goog.math.Size");
Blockly.FieldVariable = function(varname, opt_validator, opt_variableTypes, opt_defaultType) {
    this.menuGenerator_ = Blockly.FieldVariable.dropdownCreate;
    this.size_ = new goog.math.Size(0, Blockly.BlockSvg.MIN_BLOCK_Y);
    this.setValidator(opt_validator);
    this.defaultVariableName = varname || "";
    this.setTypes_(opt_variableTypes, opt_defaultType);
    this.value_ = null
};
goog.inherits(Blockly.FieldVariable, Blockly.FieldDropdown);
Blockly.FieldVariable.fromJson = function(options) {
    var varname = Blockly.utils.replaceMessageReferences(options["variable"]);
    var variableTypes = options["variableTypes"];
    var defaultType = options["defaultType"];
    return new Blockly.FieldVariable(varname, null, variableTypes, defaultType)
};
Blockly.FieldVariable.prototype.init = function() {
    if (this.fieldGroup_) return;
    Blockly.FieldVariable.superClass_.init.call(this);
    this.initModel()
};
Blockly.FieldVariable.prototype.initModel = function() {
    if (this.variable_) return;
    this.workspace_ = this.sourceBlock_.workspace;
    var variable = Blockly.Variables.getOrCreateVariablePackage(this.workspace_, null, this.defaultVariableName, this.defaultType_);
    Blockly.Events.disable();
    try {
        this.setValue(variable.getId())
    } finally {
        Blockly.Events.enable()
    }
};
Blockly.FieldVariable.prototype.dispose = function() {
    Blockly.FieldVariable.superClass_.dispose.call(this);
    this.workspace_ = null;
    this.variableMap_ = null
};
Blockly.FieldVariable.prototype.setSourceBlock = function(block) {
    if (block.isShadow()) throw Error("Variable fields are not allowed to exist on shadow blocks.");
    Blockly.FieldVariable.superClass_.setSourceBlock.call(this, block)
};
Blockly.FieldVariable.prototype.getValue = function() {
    return this.variable_ ? this.variable_.getId() : null
};
Blockly.FieldVariable.prototype.getText = function() {
    return this.variable_ ? this.variable_.name : ""
};
Blockly.FieldVariable.prototype.getVariable = function() {
    return this.variable_
};
Blockly.FieldVariable.prototype.setValue = function(id) {
    var workspace = this.sourceBlock_.workspace;
    var variable = Blockly.Variables.getVariable(workspace, id);
    if (!variable) throw Error("Variable id doesn't point to a real variable!  ID was " + id);
    var type = variable.type;
    if (!this.typeIsAllowed_(type)) throw Error("Variable type doesn't match this field!  Type was " + type);
    if (this.sourceBlock_ && Blockly.Events.isEnabled()) {
        var oldValue = this.variable_ ? this.variable_.getId() : null;
        Blockly.Events.fire(new Blockly.Events.BlockChange(this.sourceBlock_,
            "field", this.name, oldValue, id))
    }
    this.variable_ = variable;
    this.value_ = id;
    this.setText(variable.name)
};
Blockly.FieldVariable.prototype.typeIsAllowed_ = function(type) {
    var typeList = this.getVariableTypes_();
    if (!typeList) return true;
    for (var i = 0; i < typeList.length; i++)
        if (type == typeList[i]) return true;
    return false
};
Blockly.FieldVariable.prototype.getVariableTypes_ = function() {
    var variableTypes = this.variableTypes;
    if (variableTypes === null)
        if (this.sourceBlock_) {
            var workspace = this.sourceBlock_.workspace;
            return workspace.getVariableTypes()
        } variableTypes = variableTypes || [""];
    if (variableTypes.length == 0) {
        var name = this.getText();
        throw Error("'variableTypes' of field variable " + name + " was an empty list");
    }
    return variableTypes
};
Blockly.FieldVariable.prototype.setTypes_ = function(opt_variableTypes, opt_defaultType) {
    var defaultType = opt_defaultType || "";
    if (opt_variableTypes == null || opt_variableTypes == undefined) var variableTypes = null;
    else if (Array.isArray(opt_variableTypes)) {
        var variableTypes = opt_variableTypes;
        var isInArray = false;
        for (var i = 0; i < variableTypes.length; i++)
            if (variableTypes[i] == defaultType) isInArray = true;
        if (!isInArray) throw Error("Invalid default type '" + defaultType + "' in " + "the definition of a FieldVariable");
    } else throw Error("'variableTypes' was not an array in the definition of " +
        "a FieldVariable");
    this.defaultType_ = defaultType;
    this.variableTypes = variableTypes
};
Blockly.FieldVariable.dropdownCreate = function() {
    if (!this.variable_) throw Error("Tried to call dropdownCreate on a variable field with no" + " variable selected.");
    var name = this.getText();
    var workspace = null;
    if (this.sourceBlock_) workspace = this.sourceBlock_.workspace;
    var variableModelList = [];
    if (workspace) {
        var variableTypes = this.getVariableTypes_();
        for (var i = 0; i < variableTypes.length; i++) {
            var variableType = variableTypes[i];
            var variables = workspace.getVariablesOfType(variableType);
            variableModelList = variableModelList.concat(variables)
        }
    }
    variableModelList.sort(Blockly.VariableModel.compareByName);
    var options = [];
    for (var i = 0; i < variableModelList.length; i++) options[i] = [variableModelList[i].name, variableModelList[i].getId()];
    options.push([Blockly.Msg["RENAME_VARIABLE"], Blockly.RENAME_VARIABLE_ID]);
    if (Blockly.Msg["DELETE_VARIABLE"]) options.push([Blockly.Msg["DELETE_VARIABLE"].replace("%1", name), Blockly.DELETE_VARIABLE_ID]);
    return options
};
Blockly.FieldVariable.prototype.onItemSelected = function(menu, menuItem) {
    var id = menuItem.getValue();
    if (this.sourceBlock_ && this.sourceBlock_.workspace) {
        var workspace = this.sourceBlock_.workspace;
        if (id == Blockly.RENAME_VARIABLE_ID) {
            Blockly.Variables.renameVariable(workspace, this.variable_);
            return
        } else if (id == Blockly.DELETE_VARIABLE_ID) {
            workspace.deleteVariableById(this.variable_.getId());
            return
        }
    }
    this.setValue(id)
};
Blockly.FieldVariable.prototype.referencesVariables = function() {
    return true
};
Blockly.Field.register("field_variable", Blockly.FieldVariable);
goog.provide("Blockly.Flyout");
goog.require("Blockly.Block");
goog.require("Blockly.Events");
goog.require("Blockly.Events.BlockCreate");
goog.require("Blockly.Events.VarCreate");
goog.require("Blockly.FlyoutButton");
goog.require("Blockly.Gesture");
goog.require("Blockly.Touch");
goog.require("Blockly.utils");
goog.require("Blockly.WorkspaceSvg");
goog.require("Blockly.Xml");
goog.require("goog.math.Rect");
Blockly.Flyout = function(workspaceOptions) {
    workspaceOptions.getMetrics = this.getMetrics_.bind(this);
    workspaceOptions.setMetrics = this.setMetrics_.bind(this);
    this.workspace_ = new Blockly.WorkspaceSvg(workspaceOptions);
    this.workspace_.isFlyout = true;
    this.RTL = !!workspaceOptions.RTL;
    this.toolboxPosition_ = workspaceOptions.toolboxPosition;
    this.eventWrappers_ = [];
    this.mats_ = [];
    this.buttons_ = [];
    this.listeners_ = [];
    this.permanentlyDisabled_ = []
};
Blockly.Flyout.prototype.autoClose = true;
Blockly.Flyout.prototype.isVisible_ = false;
Blockly.Flyout.prototype.containerVisible_ = true;
Blockly.Flyout.prototype.CORNER_RADIUS = 0;
Blockly.Flyout.prototype.MARGIN = Blockly.Flyout.prototype.CORNER_RADIUS;
Blockly.Flyout.prototype.GAP_X = Blockly.Flyout.prototype.MARGIN * 3;
Blockly.Flyout.prototype.GAP_Y = Blockly.Flyout.prototype.MARGIN * 3;
Blockly.Flyout.prototype.SCROLLBAR_PADDING = 2;
Blockly.Flyout.prototype.width_ = 0;
Blockly.Flyout.prototype.height_ = 0;
Blockly.Flyout.prototype.dragAngleRange_ = 70;
Blockly.Flyout.prototype.createDom = function(tagName) {
    this.svgGroup_ = Blockly.utils.createSvgElement(tagName, {
        "class": "blocklyFlyout",
        "style": "display: none"
    }, null);
    this.svgBackground_ = Blockly.utils.createSvgElement("path", {
        "class": "blocklyFlyoutBackground"
    }, this.svgGroup_);
    this.svgGroup_.appendChild(this.workspace_.createDom());
    return this.svgGroup_
};
Blockly.Flyout.prototype.init = function(targetWorkspace) {
    this.targetWorkspace_ = targetWorkspace;
    this.workspace_.targetWorkspace = targetWorkspace;
    this.scrollbar_ = new Blockly.Scrollbar(this.workspace_, this.horizontalLayout_, false, "blocklyFlyoutScrollbar");
    this.hide();
    Array.prototype.push.apply(this.eventWrappers_, Blockly.bindEventWithChecks_(this.svgGroup_, "wheel", this, this.wheel_));
    if (!this.autoClose) {
        this.filterWrapper_ = this.filterForCapacity_.bind(this);
        this.targetWorkspace_.addChangeListener(this.filterWrapper_)
    }
    Array.prototype.push.apply(this.eventWrappers_,
        Blockly.bindEventWithChecks_(this.svgBackground_, "mousedown", this, this.onMouseDown_));
    this.workspace_.getGesture = this.targetWorkspace_.getGesture.bind(this.targetWorkspace_);
    this.workspace_.variableMap_ = this.targetWorkspace_.getVariableMap();
    this.workspace_.createPotentialVariableMap()
};
Blockly.Flyout.prototype.dispose = function() {
    this.hide();
    Blockly.unbindEvent_(this.eventWrappers_);
    if (this.filterWrapper_) {
        this.targetWorkspace_.removeChangeListener(this.filterWrapper_);
        this.filterWrapper_ = null
    }
    if (this.scrollbar_) {
        this.scrollbar_.dispose();
        this.scrollbar_ = null
    }
    if (this.workspace_) {
        this.workspace_.targetWorkspace = null;
        this.workspace_.dispose();
        this.workspace_ = null
    }
    if (this.svgGroup_) {
        Blockly.utils.removeNode(this.svgGroup_);
        this.svgGroup_ = null
    }
    this.svgBackground_ = null;
    this.targetWorkspace_ =
        null
};
Blockly.Flyout.prototype.getWidth = function() {
    return this.width_
};
Blockly.Flyout.prototype.getHeight = function() {
    return this.height_
};
Blockly.Flyout.prototype.getWorkspace = function() {
    return this.workspace_
};
Blockly.Flyout.prototype.isVisible = function() {
    return this.isVisible_
};
Blockly.Flyout.prototype.setVisible = function(visible) {
    var visibilityChanged = visible != this.isVisible();
    this.isVisible_ = visible;
    if (visibilityChanged) this.updateDisplay_()
};
Blockly.Flyout.prototype.setContainerVisible = function(visible) {
    var visibilityChanged = visible != this.containerVisible_;
    this.containerVisible_ = visible;
    if (visibilityChanged) this.updateDisplay_()
};
Blockly.Flyout.prototype.updateDisplay_ = function() {
    var show = true;
    if (!this.containerVisible_) show = false;
    else show = this.isVisible();
    this.svgGroup_.style.display = show ? "block" : "none";
    this.scrollbar_.setContainerVisible(show)
};
Blockly.Flyout.prototype.positionAt_ = function(width, height, x, y) {
    this.svgGroup_.setAttribute("width", width);
    this.svgGroup_.setAttribute("height", height);
    if (this.svgGroup_.tagName == "svg") {
        var transform = "translate(" + x + "px," + y + "px)";
        Blockly.utils.setCssTransform(this.svgGroup_, transform)
    } else {
        var transform = "translate(" + x + "," + y + ")";
        this.svgGroup_.setAttribute("transform", transform)
    }
    if (this.scrollbar_) {
        this.scrollbar_.setOrigin(x, y);
        this.scrollbar_.resize()
    }
};
Blockly.Flyout.prototype.hide = function() {
    if (!this.isVisible()) return;
    this.setVisible(false);
    for (var x = 0, listen; listen = this.listeners_[x]; x++) Blockly.unbindEvent_(listen);
    this.listeners_.length = 0;
    if (this.reflowWrapper_) {
        this.workspace_.removeChangeListener(this.reflowWrapper_);
        this.reflowWrapper_ = null
    }
};
Blockly.Flyout.prototype.show = function(xmlList) {
    this.workspace_.setResizesEnabled(false);
    this.hide();
    this.clearOldBlocks_();
    if (typeof xmlList == "string") {
        var fnToApply = this.workspace_.targetWorkspace.getToolboxCategoryCallback(xmlList);
        if (typeof fnToApply != "function") throw TypeError("Couldn't find a callback function when opening" + " a toolbox category.");
        xmlList = fnToApply(this.workspace_.targetWorkspace);
        if (!Array.isArray(xmlList)) throw TypeError("Result of toolbox category callback must be an array.");
    }
    this.setVisible(true);
    var contents = [];
    var gaps = [];
    this.permanentlyDisabled_.length = 0;
    for (var i = 0, xml; xml = xmlList[i]; i++)
        if (xml.tagName) {
            var tagName = xml.tagName.toUpperCase();
            var default_gap = this.horizontalLayout_ ? this.GAP_X : this.GAP_Y;
            if (tagName == "BLOCK") {
                var curBlock = Blockly.Xml.domToBlock(xml, this.workspace_);
                if (curBlock.disabled) this.permanentlyDisabled_.push(curBlock);
                contents.push({
                    type: "block",
                    block: curBlock
                });
                var gap = parseInt(xml.getAttribute("gap"), 10);
                gaps.push(isNaN(gap) ? default_gap : gap)
            } else if (xml.tagName.toUpperCase() ==
                "SEP") {
                var newGap = parseInt(xml.getAttribute("gap"), 10);
                if (!isNaN(newGap) && gaps.length > 0) gaps[gaps.length - 1] = newGap;
                else gaps.push(default_gap)
            } else if (tagName == "BUTTON" || tagName == "LABEL") {
                var isLabel = tagName == "LABEL";
                var curButton = new Blockly.FlyoutButton(this.workspace_, this.targetWorkspace_, xml, isLabel);
                contents.push({
                    type: "button",
                    button: curButton
                });
                gaps.push(default_gap)
            }
        } this.layout_(contents, gaps);
    var deselectAll = function() {
        var topBlocks = this.workspace_.getTopBlocks(false);
        for (var i = 0, block; block =
            topBlocks[i]; i++) block.removeSelect()
    };
    this.listeners_.push(Blockly.bindEventWithChecks_(this.svgBackground_, "mouseover", this, deselectAll));
    if (this.horizontalLayout_) this.height_ = 0;
    else this.width_ = 0;
    this.workspace_.setResizesEnabled(true);
    this.reflow();
    this.filterForCapacity_();
    this.position();
    this.reflowWrapper_ = this.reflow.bind(this);
    this.workspace_.addChangeListener(this.reflowWrapper_)
};
Blockly.Flyout.prototype.clearOldBlocks_ = function() {
    var oldBlocks = this.workspace_.getTopBlocks(false);
    for (var i = 0, block; block = oldBlocks[i]; i++)
        if (block.workspace == this.workspace_) block.dispose(false, false);
    for (var j = 0; j < this.mats_.length; j++) {
        var rect = this.mats_[j];
        if (rect) Blockly.utils.removeNode(rect)
    }
    this.mats_.length = 0;
    for (var i = 0, button; button = this.buttons_[i]; i++) button.dispose();
    this.buttons_.length = 0;
    this.workspace_.getPotentialVariableMap().clear()
};
Blockly.Flyout.prototype.addBlockListeners_ = function(root, block, rect) {
    this.listeners_.push(Blockly.bindEventWithChecks_(root, "mousedown", null, this.blockMouseDown_(block)));
    this.listeners_.push(Blockly.bindEventWithChecks_(rect, "mousedown", null, this.blockMouseDown_(block)));
    this.listeners_.push(Blockly.bindEvent_(root, "mouseover", block, block.addSelect));
    this.listeners_.push(Blockly.bindEvent_(root, "mouseout", block, block.removeSelect));
    this.listeners_.push(Blockly.bindEvent_(rect, "mouseover", block,
        block.addSelect));
    this.listeners_.push(Blockly.bindEvent_(rect, "mouseout", block, block.removeSelect))
};
Blockly.Flyout.prototype.blockMouseDown_ = function(block) {
    var flyout = this;
    return function(e) {
        var gesture = flyout.targetWorkspace_.getGesture(e);
        if (gesture) {
            gesture.setStartBlock(block);
            gesture.handleFlyoutStart(e, flyout)
        }
    }
};
Blockly.Flyout.prototype.onMouseDown_ = function(e) {
    var gesture = this.targetWorkspace_.getGesture(e);
    if (gesture) gesture.handleFlyoutStart(e, this)
};
Blockly.Flyout.prototype.createBlock = function(originalBlock) {
    var newBlock = null;
    Blockly.Events.disable();
    var variablesBeforeCreation = this.targetWorkspace_.getAllVariables();
    this.targetWorkspace_.setResizesEnabled(false);
    try {
        newBlock = this.placeNewBlock_(originalBlock);
        Blockly.hideChaff()
    } finally {
        Blockly.Events.enable()
    }
    var newVariables = Blockly.Variables.getAddedVariables(this.targetWorkspace_, variablesBeforeCreation);
    if (Blockly.Events.isEnabled()) {
        Blockly.Events.setGroup(true);
        Blockly.Events.fire(new Blockly.Events.Create(newBlock));
        for (var i = 0; i < newVariables.length; i++) {
            var thisVariable = newVariables[i];
            Blockly.Events.fire(new Blockly.Events.VarCreate(thisVariable))
        }
    }
    if (this.autoClose) this.hide();
    else this.filterForCapacity_();
    return newBlock
};
Blockly.Flyout.prototype.initFlyoutButton_ = function(button, x, y) {
    var buttonSvg = button.createDom();
    button.moveTo(x, y);
    button.show();
    this.listeners_.push(Blockly.bindEventWithChecks_(buttonSvg, "mousedown", this, this.onMouseDown_));
    this.buttons_.push(button)
};
Blockly.Flyout.prototype.createRect_ = function(block, x, y, blockHW, index) {
    var rect = Blockly.utils.createSvgElement("rect", {
        "fill-opacity": 0,
        "x": x,
        "y": y,
        "height": blockHW.height,
        "width": blockHW.width
    }, null);
    rect.tooltip = block;
    Blockly.Tooltip.bindMouseEvents(rect);
    this.workspace_.getCanvas().insertBefore(rect, block.getSvgRoot());
    block.flyoutRect_ = rect;
    this.mats_[index] = rect;
    return rect
};
Blockly.Flyout.prototype.moveRectToBlock_ = function(rect, block) {
    var blockHW = block.getHeightWidth();
    rect.setAttribute("width", blockHW.width);
    rect.setAttribute("height", blockHW.height);
    var hatOffset = block.startHat_ ? Blockly.BlockSvg.START_HAT_HEIGHT : 0;
    if (hatOffset) block.moveBy(0, hatOffset);
    var tab = block.outputConnection ? Blockly.BlockSvg.TAB_WIDTH : 0;
    var blockXY = block.getRelativeToSurfaceXY();
    rect.setAttribute("y", blockXY.y);
    rect.setAttribute("x", this.RTL ? blockXY.x - blockHW.width + tab : blockXY.x - tab)
};
Blockly.Flyout.prototype.filterForCapacity_ = function() {
    var remainingCapacity = this.targetWorkspace_.remainingCapacity();
    var blocks = this.workspace_.getTopBlocks(false);
    for (var i = 0, block; block = blocks[i]; i++)
        if (this.permanentlyDisabled_.indexOf(block) == -1) {
            var allBlocks = block.getDescendants(false);
            block.setDisabled(allBlocks.length > remainingCapacity)
        }
};
Blockly.Flyout.prototype.reflow = function() {
    if (this.reflowWrapper_) this.workspace_.removeChangeListener(this.reflowWrapper_);
    this.reflowInternal_();
    if (this.reflowWrapper_) this.workspace_.addChangeListener(this.reflowWrapper_)
};
Blockly.Flyout.prototype.isScrollable = function() {
    return this.scrollbar_ ? this.scrollbar_.isVisible() : false
};
Blockly.Flyout.prototype.placeNewBlock_ = function(oldBlock) {
    var targetWorkspace = this.targetWorkspace_;
    var svgRootOld = oldBlock.getSvgRoot();
    if (!svgRootOld) throw Error("oldBlock is not rendered.");
    var xml = Blockly.Xml.blockToDom(oldBlock);
    targetWorkspace.setResizesEnabled(false);
    var block = Blockly.Xml.domToBlock(xml, targetWorkspace);
    var svgRootNew = block.getSvgRoot();
    if (!svgRootNew) throw Error("block is not rendered.");
    var mainOffsetPixels = targetWorkspace.getOriginOffsetInPixels();
    var flyoutOffsetPixels =
        this.workspace_.getOriginOffsetInPixels();
    var oldBlockPosWs = oldBlock.getRelativeToSurfaceXY();
    var oldBlockPosPixels = oldBlockPosWs.scale(this.workspace_.scale);
    var oldBlockOffsetPixels = goog.math.Coordinate.sum(flyoutOffsetPixels, oldBlockPosPixels);
    var finalOffsetPixels = goog.math.Coordinate.difference(oldBlockOffsetPixels, mainOffsetPixels);
    var finalOffsetMainWs = finalOffsetPixels.scale(1 / targetWorkspace.scale);
    block.moveBy(finalOffsetMainWs.x, finalOffsetMainWs.y);
    return block
};
goog.provide("Blockly.FlyoutButton");
goog.require("Blockly.utils");
goog.require("goog.math.Coordinate");
Blockly.FlyoutButton = function(workspace, targetWorkspace, xml, isLabel) {
    this.workspace_ = workspace;
    this.targetWorkspace_ = targetWorkspace;
    this.text_ = xml.getAttribute("text");
    this.position_ = new goog.math.Coordinate(0, 0);
    this.isLabel_ = isLabel;
    this.callback_ = null;
    var callbackKey = xml.getAttribute("callbackKey");
    if (this.isLabel_ && callbackKey) console.warn("Labels should not have callbacks. Label text: " + this.text_);
    else if (!this.isLabel_ && !(callbackKey && targetWorkspace.getButtonCallback(callbackKey))) console.warn("Buttons should have callbacks. Button text: " +
        this.text_);
    else this.callback_ = targetWorkspace.getButtonCallback(callbackKey);
    this.cssClass_ = xml.getAttribute("web-class") || null
};
Blockly.FlyoutButton.MARGIN = 5;
Blockly.FlyoutButton.prototype.width = 0;
Blockly.FlyoutButton.prototype.height = 0;
Blockly.FlyoutButton.prototype.onMouseUpWrapper_ = null;
Blockly.FlyoutButton.prototype.createDom = function() {
    var cssClass = this.isLabel_ ? "blocklyFlyoutLabel" : "blocklyFlyoutButton";
    if (this.cssClass_) cssClass += " " + this.cssClass_;
    this.svgGroup_ = Blockly.utils.createSvgElement("g", {
        "class": cssClass
    }, this.workspace_.getCanvas());
    if (!this.isLabel_) var shadow = Blockly.utils.createSvgElement("rect", {
        "class": "blocklyFlyoutButtonShadow",
        "rx": 4,
        "ry": 4,
        "x": 1,
        "y": 1
    }, this.svgGroup_);
    var rect = Blockly.utils.createSvgElement("rect", {
        "class": this.isLabel_ ? "blocklyFlyoutLabelBackground" : "blocklyFlyoutButtonBackground",
        "rx": 4,
        "ry": 4
    }, this.svgGroup_);
    var svgText = Blockly.utils.createSvgElement("text", {
        "class": this.isLabel_ ? "blocklyFlyoutLabelText" : "blocklyText",
        "x": 0,
        "y": 0,
        "text-anchor": "middle"
    }, this.svgGroup_);
    svgText.textContent = Blockly.utils.replaceMessageReferences(this.text_);
    this.width = Blockly.Field.getCachedWidth(svgText);
    this.height = 20;
    if (!this.isLabel_) {
        this.width += 2 * Blockly.FlyoutButton.MARGIN;
        shadow.setAttribute("width", this.width);
        shadow.setAttribute("height", this.height)
    }
    rect.setAttribute("width",
        this.width);
    rect.setAttribute("height", this.height);
    svgText.setAttribute("x", this.width / 2);
    svgText.setAttribute("y", this.height - Blockly.FlyoutButton.MARGIN);
    this.updateTransform_();
    this.onMouseUpWrapper_ = Blockly.bindEventWithChecks_(this.svgGroup_, "mouseup", this, this.onMouseUp_);
    return this.svgGroup_
};
Blockly.FlyoutButton.prototype.show = function() {
    this.updateTransform_();
    this.svgGroup_.setAttribute("display", "block")
};
Blockly.FlyoutButton.prototype.updateTransform_ = function() {
    this.svgGroup_.setAttribute("transform", "translate(" + this.position_.x + "," + this.position_.y + ")")
};
Blockly.FlyoutButton.prototype.moveTo = function(x, y) {
    this.position_.x = x;
    this.position_.y = y;
    this.updateTransform_()
};
Blockly.FlyoutButton.prototype.getPosition = function() {
    return this.position_
};
Blockly.FlyoutButton.prototype.getTargetWorkspace = function() {
    return this.targetWorkspace_
};
Blockly.FlyoutButton.prototype.dispose = function() {
    if (this.onMouseUpWrapper_) Blockly.unbindEvent_(this.onMouseUpWrapper_);
    if (this.svgGroup_) {
        Blockly.utils.removeNode(this.svgGroup_);
        this.svgGroup_ = null
    }
    this.workspace_ = null;
    this.targetWorkspace_ = null
};
Blockly.FlyoutButton.prototype.onMouseUp_ = function(e) {
    var gesture = this.targetWorkspace_.getGesture(e);
    if (gesture) gesture.cancel();
    if (this.callback_) this.callback_(this)
};
goog.provide("Blockly.FlyoutDragger");
goog.require("Blockly.WorkspaceDragger");
Blockly.FlyoutDragger = function(flyout) {
    Blockly.FlyoutDragger.superClass_.constructor.call(this, flyout.getWorkspace());
    this.scrollbar_ = flyout.scrollbar_;
    this.horizontalLayout_ = flyout.horizontalLayout_
};
goog.inherits(Blockly.FlyoutDragger, Blockly.WorkspaceDragger);
Blockly.FlyoutDragger.prototype.updateScroll_ = function(x, y) {
    if (this.horizontalLayout_) this.scrollbar_.set(x);
    else this.scrollbar_.set(y)
};
goog.provide("Blockly.HorizontalFlyout");
goog.require("Blockly.Block");
goog.require("Blockly.Events");
goog.require("Blockly.FlyoutButton");
goog.require("Blockly.Flyout");
goog.require("Blockly.WorkspaceSvg");
goog.require("goog.math.Rect");
goog.require("goog.userAgent");
Blockly.HorizontalFlyout = function(workspaceOptions) {
    workspaceOptions.getMetrics = this.getMetrics_.bind(this);
    workspaceOptions.setMetrics = this.setMetrics_.bind(this);
    Blockly.HorizontalFlyout.superClass_.constructor.call(this, workspaceOptions);
    this.horizontalLayout_ = true
};
goog.inherits(Blockly.HorizontalFlyout, Blockly.Flyout);
Blockly.HorizontalFlyout.prototype.getMetrics_ = function() {
    if (!this.isVisible()) return null;
    try {
        var optionBox = this.workspace_.getCanvas().getBBox()
    } catch (e) {
        var optionBox = {
            height: 0,
            y: 0,
            width: 0,
            x: 0
        }
    }
    var absoluteTop = this.SCROLLBAR_PADDING;
    var absoluteLeft = this.SCROLLBAR_PADDING;
    if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_BOTTOM) absoluteTop = 0;
    var viewHeight = this.height_;
    if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_TOP) viewHeight -= this.SCROLLBAR_PADDING;
    var viewWidth = this.width_ - 2 * this.SCROLLBAR_PADDING;
    var metrics = {
        viewHeight: viewHeight,
        viewWidth: viewWidth,
        contentHeight: (optionBox.height + 2 * this.MARGIN) * this.workspace_.scale,
        contentWidth: (optionBox.width + 2 * this.MARGIN) * this.workspace_.scale,
        viewTop: -this.workspace_.scrollY,
        viewLeft: -this.workspace_.scrollX,
        contentTop: optionBox.y,
        contentLeft: optionBox.x,
        absoluteTop: absoluteTop,
        absoluteLeft: absoluteLeft
    };
    return metrics
};
Blockly.HorizontalFlyout.prototype.setMetrics_ = function(xyRatio) {
    var metrics = this.getMetrics_();
    if (!metrics) return;
    if (typeof xyRatio.x == "number") this.workspace_.scrollX = -metrics.contentWidth * xyRatio.x;
    this.workspace_.translate(this.workspace_.scrollX + metrics.absoluteLeft, this.workspace_.scrollY + metrics.absoluteTop)
};
Blockly.HorizontalFlyout.prototype.position = function() {
    if (!this.isVisible()) return;
    var targetWorkspaceMetrics = this.targetWorkspace_.getMetrics();
    if (!targetWorkspaceMetrics) return;
    this.width_ = targetWorkspaceMetrics.viewWidth;
    var edgeWidth = targetWorkspaceMetrics.viewWidth - 2 * this.CORNER_RADIUS;
    var edgeHeight = this.height_ - this.CORNER_RADIUS;
    this.setBackgroundPath_(edgeWidth, edgeHeight);
    var x = targetWorkspaceMetrics.absoluteLeft;
    var y = targetWorkspaceMetrics.absoluteTop;
    if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_BOTTOM) y +=
        targetWorkspaceMetrics.viewHeight - this.height_;
    this.positionAt_(this.width_, this.height_, x, y)
};
Blockly.HorizontalFlyout.prototype.setBackgroundPath_ = function(width, height) {
    var atTop = this.toolboxPosition_ == Blockly.TOOLBOX_AT_TOP;
    var path = ["M 0," + (atTop ? 0 : this.CORNER_RADIUS)];
    if (atTop) {
        path.push("h", width + 2 * this.CORNER_RADIUS);
        path.push("v", height);
        path.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, this.CORNER_RADIUS);
        path.push("h", -1 * width);
        path.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, -this.CORNER_RADIUS, -this.CORNER_RADIUS);
        path.push("z")
    } else {
        path.push("a",
            this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, -this.CORNER_RADIUS);
        path.push("h", width);
        path.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, 1, this.CORNER_RADIUS, this.CORNER_RADIUS);
        path.push("v", height);
        path.push("h", -width - 2 * this.CORNER_RADIUS);
        path.push("z")
    }
    this.svgBackground_.setAttribute("d", path.join(" "))
};
Blockly.HorizontalFlyout.prototype.scrollToStart = function() {
    this.scrollbar_.set(this.RTL ? Infinity : 0)
};
Blockly.HorizontalFlyout.prototype.wheel_ = function(e) {
    var delta = e.deltaX;
    if (delta) {
        if (goog.userAgent.GECKO && e.deltaMode === 1) delta *= 10;
        var metrics = this.getMetrics_();
        var pos = metrics.viewLeft + delta;
        var limit = metrics.contentWidth - metrics.viewWidth;
        pos = Math.min(pos, limit);
        pos = Math.max(pos, 0);
        this.scrollbar_.set(pos);
        Blockly.WidgetDiv.hide()
    }
    e.preventDefault();
    e.stopPropagation()
};
Blockly.HorizontalFlyout.prototype.layout_ = function(contents, gaps) {
    this.workspace_.scale = this.targetWorkspace_.scale;
    var margin = this.MARGIN;
    var cursorX = this.RTL ? margin : margin + Blockly.BlockSvg.TAB_WIDTH;
    var cursorY = margin;
    if (this.RTL) contents = contents.reverse();
    for (var i = 0, item; item = contents[i]; i++)
        if (item.type == "block") {
            var block = item.block;
            var allBlocks = block.getDescendants(false);
            for (var j = 0, child; child = allBlocks[j]; j++) child.isInFlyout = true;
            block.render();
            var root = block.getSvgRoot();
            var blockHW =
                block.getHeightWidth();
            var tab = block.outputConnection ? Blockly.BlockSvg.TAB_WIDTH : 0;
            if (this.RTL) var moveX = cursorX + blockHW.width;
            else var moveX = cursorX + tab;
            block.moveBy(moveX, cursorY);
            var rect = this.createRect_(block, moveX, cursorY, blockHW, i);
            cursorX += blockHW.width + gaps[i];
            this.addBlockListeners_(root, block, rect)
        } else if (item.type == "button") {
        this.initFlyoutButton_(item.button, cursorX, cursorY);
        cursorX += item.button.width + gaps[i]
    }
};
Blockly.HorizontalFlyout.prototype.isDragTowardWorkspace = function(currentDragDeltaXY) {
    var dx = currentDragDeltaXY.x;
    var dy = currentDragDeltaXY.y;
    var dragDirection = Math.atan2(dy, dx) / Math.PI * 180;
    var range = this.dragAngleRange_;
    if (dragDirection < 90 + range && dragDirection > 90 - range || dragDirection > -90 - range && dragDirection < -90 + range) return true;
    return false
};
Blockly.HorizontalFlyout.prototype.getClientRect = function() {
    if (!this.svgGroup_) return null;
    var flyoutRect = this.svgGroup_.getBoundingClientRect();
    var BIG_NUM = 1E9;
    var y = flyoutRect.top;
    var height = flyoutRect.height;
    if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_TOP) return new goog.math.Rect(-BIG_NUM, y - BIG_NUM, BIG_NUM * 2, BIG_NUM + height);
    else if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_BOTTOM) return new goog.math.Rect(-BIG_NUM, y, BIG_NUM * 2, BIG_NUM + height)
};
Blockly.HorizontalFlyout.prototype.reflowInternal_ = function() {
    this.workspace_.scale = this.targetWorkspace_.scale;
    var flyoutHeight = 0;
    var blocks = this.workspace_.getTopBlocks(false);
    for (var i = 0, block; block = blocks[i]; i++) flyoutHeight = Math.max(flyoutHeight, block.getHeightWidth().height);
    flyoutHeight += this.MARGIN * 1.5;
    flyoutHeight *= this.workspace_.scale;
    flyoutHeight += Blockly.Scrollbar.scrollbarThickness;
    if (this.height_ != flyoutHeight) {
        for (var i = 0, block; block = blocks[i]; i++)
            if (block.flyoutRect_) this.moveRectToBlock_(block.flyoutRect_,
                block);
        this.height_ = flyoutHeight;
        this.targetWorkspace_.resize()
    }
};
goog.provide("Blockly.VerticalFlyout");
goog.require("Blockly.Block");
goog.require("Blockly.Events");
goog.require("Blockly.Flyout");
goog.require("Blockly.FlyoutButton");
goog.require("Blockly.WorkspaceSvg");
goog.require("goog.math.Rect");
goog.require("goog.userAgent");
Blockly.VerticalFlyout = function(workspaceOptions) {
    workspaceOptions.getMetrics = this.getMetrics_.bind(this);
    workspaceOptions.setMetrics = this.setMetrics_.bind(this);
    Blockly.VerticalFlyout.superClass_.constructor.call(this, workspaceOptions);
    this.horizontalLayout_ = false
};
goog.inherits(Blockly.VerticalFlyout, Blockly.Flyout);
Blockly.VerticalFlyout.prototype.getMetrics_ = function() {
    if (!this.isVisible()) return null;
    try {
        var optionBox = this.workspace_.getCanvas().getBBox()
    } catch (e) {
        var optionBox = {
            height: 0,
            y: 0,
            width: 0,
            x: 0
        }
    }
    var absoluteTop = this.SCROLLBAR_PADDING;
    var absoluteLeft = 0;
    var viewHeight = this.height_ - 2 * this.SCROLLBAR_PADDING;
    var viewWidth = this.width_;
    if (!this.RTL) viewWidth -= this.SCROLLBAR_PADDING;
    var metrics = {
        viewHeight: viewHeight,
        viewWidth: viewWidth,
        contentHeight: optionBox.height * this.workspace_.scale + 2 * this.MARGIN,
        contentWidth: optionBox.width * this.workspace_.scale + 2 * this.MARGIN,
        viewTop: -this.workspace_.scrollY + optionBox.y,
        viewLeft: -this.workspace_.scrollX,
        contentTop: optionBox.y,
        contentLeft: optionBox.x,
        absoluteTop: absoluteTop,
        absoluteLeft: absoluteLeft
    };
    return metrics
};
Blockly.VerticalFlyout.prototype.setMetrics_ = function(xyRatio) {
    var metrics = this.getMetrics_();
    if (!metrics) return;
    if (typeof xyRatio.y == "number") this.workspace_.scrollY = -metrics.contentHeight * xyRatio.y;
    this.workspace_.translate(this.workspace_.scrollX + metrics.absoluteLeft, this.workspace_.scrollY + metrics.absoluteTop)
};
Blockly.VerticalFlyout.prototype.position = function() {
    if (!this.isVisible()) return;
    var targetWorkspaceMetrics = this.targetWorkspace_.getMetrics();
    if (!targetWorkspaceMetrics) return;
    this.height_ = targetWorkspaceMetrics.viewHeight;
    var edgeWidth = this.width_ - this.CORNER_RADIUS;
    var edgeHeight = targetWorkspaceMetrics.viewHeight - 2 * this.CORNER_RADIUS;
    this.setBackgroundPath_(edgeWidth, edgeHeight);
    var y = targetWorkspaceMetrics.absoluteTop;
    var x = targetWorkspaceMetrics.absoluteLeft;
    if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_RIGHT) {
        x +=
            targetWorkspaceMetrics.viewWidth - this.width_;
        this.leftEdge_ = x
    }
    this.positionAt_(this.width_, this.height_, x, y)
};
Blockly.VerticalFlyout.prototype.setBackgroundPath_ = function(width, height) {
    var atRight = this.toolboxPosition_ == Blockly.TOOLBOX_AT_RIGHT;
    var totalWidth = width + this.CORNER_RADIUS;
    var path = ["M " + (atRight ? totalWidth : 0) + ",0"];
    path.push("h", atRight ? -width : width);
    path.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, atRight ? 0 : 1, atRight ? -this.CORNER_RADIUS : this.CORNER_RADIUS, this.CORNER_RADIUS);
    path.push("v", Math.max(0, height));
    path.push("a", this.CORNER_RADIUS, this.CORNER_RADIUS, 0, 0, atRight ? 0 : 1, atRight ? this.CORNER_RADIUS :
        -this.CORNER_RADIUS, this.CORNER_RADIUS);
    path.push("h", atRight ? width : -width);
    path.push("z");
    this.svgBackground_.setAttribute("d", path.join(" "))
};
Blockly.VerticalFlyout.prototype.scrollToStart = function() {
    this.scrollbar_.set(0)
};
Blockly.VerticalFlyout.prototype.wheel_ = function(e) {
    var delta = e.deltaY;
    if (delta) {
        if (goog.userAgent.GECKO && e.deltaMode === 1) delta *= 10;
        var metrics = this.getMetrics_();
        var pos = metrics.viewTop - metrics.contentTop + delta;
        var limit = metrics.contentHeight - metrics.viewHeight;
        pos = Math.min(pos, limit);
        pos = Math.max(pos, 0);
        this.scrollbar_.set(pos);
        Blockly.WidgetDiv.hide()
    }
    e.preventDefault();
    e.stopPropagation()
};
Blockly.VerticalFlyout.prototype.layout_ = function(contents, gaps) {
    this.workspace_.scale = this.targetWorkspace_.scale;
    var margin = this.MARGIN;
    var cursorX = this.RTL ? margin : margin + Blockly.BlockSvg.TAB_WIDTH;
    var cursorY = margin;
    for (var i = 0, item; item = contents[i]; i++)
        if (item.type == "block") {
            var block = item.block;
            var allBlocks = block.getDescendants(false);
            for (var j = 0, child; child = allBlocks[j]; j++) child.isInFlyout = true;
            block.render();
            var root = block.getSvgRoot();
            var blockHW = block.getHeightWidth();
            block.moveBy(cursorX,
                cursorY);
            var rect = this.createRect_(block, this.RTL ? cursorX - blockHW.width : cursorX, cursorY, blockHW, i);
            this.addBlockListeners_(root, block, rect);
            cursorY += blockHW.height + gaps[i]
        } else if (item.type == "button") {
        this.initFlyoutButton_(item.button, cursorX, cursorY);
        cursorY += item.button.height + gaps[i]
    }
};
Blockly.VerticalFlyout.prototype.isDragTowardWorkspace = function(currentDragDeltaXY) {
    var dx = currentDragDeltaXY.x;
    var dy = currentDragDeltaXY.y;
    var dragDirection = Math.atan2(dy, dx) / Math.PI * 180;
    var range = this.dragAngleRange_;
    if (dragDirection < range && dragDirection > -range || (dragDirection < -180 + range || dragDirection > 180 - range)) return true;
    return false
};
Blockly.VerticalFlyout.prototype.getClientRect = function() {
    if (!this.svgGroup_) return null;
    var flyoutRect = this.svgGroup_.getBoundingClientRect();
    var BIG_NUM = 1E9;
    var x = flyoutRect.left;
    var width = flyoutRect.width;
    if (this.toolboxPosition_ == Blockly.TOOLBOX_AT_LEFT) return new goog.math.Rect(x - BIG_NUM, -BIG_NUM, BIG_NUM + width, BIG_NUM * 2);
    else {
        if (goog.userAgent.GECKO && this.targetWorkspace_ && this.targetWorkspace_.isMutator) {
            var targetWsLeftPixels = this.targetWorkspace_.svgGroup_.getBoundingClientRect().x;
            if (Math.abs(targetWsLeftPixels -
                    x) < 10) {
                var scale = this.targetWorkspace_.options.parentWorkspace.scale;
                x = x + this.leftEdge_ * scale
            }
        }
        return new goog.math.Rect(x, -BIG_NUM, BIG_NUM + width, BIG_NUM * 2)
    }
};
Blockly.VerticalFlyout.prototype.reflowInternal_ = function() {
    this.workspace_.scale = this.targetWorkspace_.scale;
    var flyoutWidth = 0;
    var blocks = this.workspace_.getTopBlocks(false);
    for (var i = 0, block; block = blocks[i]; i++) {
        var width = block.getHeightWidth().width;
        if (block.outputConnection) width -= Blockly.BlockSvg.TAB_WIDTH;
        flyoutWidth = Math.max(flyoutWidth, width)
    }
    for (var i = 0, button; button = this.buttons_[i]; i++) flyoutWidth = Math.max(flyoutWidth, button.width);
    flyoutWidth += this.MARGIN * 1.5 + Blockly.BlockSvg.TAB_WIDTH;
    flyoutWidth *= this.workspace_.scale;
    flyoutWidth += Blockly.Scrollbar.scrollbarThickness;
    if (this.width_ != flyoutWidth) {
        for (var i = 0, block; block = blocks[i]; i++) {
            if (this.RTL) {
                var oldX = block.getRelativeToSurfaceXY().x;
                var newX = flyoutWidth / this.workspace_.scale - this.MARGIN - Blockly.BlockSvg.TAB_WIDTH;
                block.moveBy(newX - oldX, 0)
            }
            if (block.flyoutRect_) this.moveRectToBlock_(block.flyoutRect_, block)
        }
        if (this.RTL)
            for (var i = 0, button; button = this.buttons_[i]; i++) {
                var y = button.getPosition().y;
                var x = flyoutWidth / this.workspace_.scale -
                    button.width - this.MARGIN - Blockly.BlockSvg.TAB_WIDTH;
                button.moveTo(x, y)
            }
        this.width_ = flyoutWidth;
        this.targetWorkspace_.resize()
    }
};
goog.provide("Blockly.Generator");
goog.require("Blockly.Block");
Blockly.Generator = function(name) {
    this.name_ = name;
    this.FUNCTION_NAME_PLACEHOLDER_REGEXP_ = new RegExp(this.FUNCTION_NAME_PLACEHOLDER_, "g")
};
Blockly.Generator.NAME_TYPE = "generated_function";
Blockly.Generator.prototype.INFINITE_LOOP_TRAP = null;
Blockly.Generator.prototype.STATEMENT_PREFIX = null;
Blockly.Generator.prototype.INDENT = "  ";
Blockly.Generator.prototype.COMMENT_WRAP = 60;
Blockly.Generator.prototype.ORDER_OVERRIDES = [];
Blockly.Generator.prototype.workspaceToCode = function(workspace) {
    if (!workspace) {
        console.warn("No workspace specified in workspaceToCode call.  Guessing.");
        workspace = Blockly.getMainWorkspace()
    }
    var code = [];
    this.init(workspace);
    var blocks = workspace.getTopBlocks(true);
    for (var x = 0, block; block = blocks[x]; x++) {
        var line = this.blockToCode(block);
        if (Array.isArray(line)) line = line[0];
        if (line) {
            if (block.outputConnection) line = this.scrubNakedValue(line);
            code.push(line)
        }
    }
    code = code.join("\n");
    code = this.finish(code);
    code =
        code.replace(/^\s+\n/, "");
    code = code.replace(/\n\s+$/, "\n");
    code = code.replace(/[ \t]+\n/g, "\n");
    return code
};
Blockly.Generator.prototype.prefixLines = function(text, prefix) {
    return prefix + text.replace(/(?!\n$)\n/g, "\n" + prefix)
};
Blockly.Generator.prototype.allNestedComments = function(block) {
    var comments = [];
    var blocks = block.getDescendants(true);
    for (var i = 0; i < blocks.length; i++) {
        var comment = blocks[i].getCommentText();
        if (comment) comments.push(comment)
    }
    if (comments.length) comments.push("");
    return comments.join("\n")
};
Blockly.Generator.prototype.blockToCode = function(block) {
    if (!block) return "";
    if (block.disabled) return this.blockToCode(block.getNextBlock());
    var func = this[block.type];
    if (typeof func != "function") throw Error('Language "' + this.name_ + '" does not know how to generate ' + ' code for block type "' + block.type + '".');
    var code = func.call(block, block);
    if (Array.isArray(code)) {
        if (!block.outputConnection) throw TypeError("Expecting string from statement block: " + block.type);
        return [this.scrub_(block, code[0]), code[1]]
    } else if (typeof code ==
        "string") {
        var id = block.id.replace(/\$/g, "$$$$");
        if (this.STATEMENT_PREFIX) code = this.STATEMENT_PREFIX.replace(/%1/g, "'" + id + "'") + code;
        return this.scrub_(block, code)
    } else if (code === null) return "";
    else throw SyntaxError("Invalid code generated: " + code);
};
Blockly.Generator.prototype.valueToCode = function(block, name, outerOrder) {
    if (isNaN(outerOrder)) throw TypeError("Expecting valid order from block: " + block.type);
    var targetBlock = block.getInputTargetBlock(name);
    if (!targetBlock) return "";
    var tuple = this.blockToCode(targetBlock);
    if (tuple === "") return "";
    if (!Array.isArray(tuple)) throw TypeError("Expecting tuple from value block: " + targetBlock.type);
    var code = tuple[0];
    var innerOrder = tuple[1];
    if (isNaN(innerOrder)) throw TypeError("Expecting valid order from value block: " +
        targetBlock.type);
    if (!code) return "";
    var parensNeeded = false;
    var outerOrderClass = Math.floor(outerOrder);
    var innerOrderClass = Math.floor(innerOrder);
    if (outerOrderClass <= innerOrderClass)
        if (outerOrderClass == innerOrderClass && (outerOrderClass == 0 || outerOrderClass == 99));
        else {
            parensNeeded = true;
            for (var i = 0; i < this.ORDER_OVERRIDES.length; i++)
                if (this.ORDER_OVERRIDES[i][0] == outerOrder && this.ORDER_OVERRIDES[i][1] == innerOrder) {
                    parensNeeded = false;
                    break
                }
        } if (parensNeeded) code = "(" + code + ")";
    return code
};
Blockly.Generator.prototype.statementToCode = function(block, name) {
    var targetBlock = block.getInputTargetBlock(name);
    var code = this.blockToCode(targetBlock);
    if (typeof code != "string") throw TypeError("Expecting code from statement block: " + (targetBlock && targetBlock.type));
    if (code) code = this.prefixLines(code, this.INDENT);
    return code
};
Blockly.Generator.prototype.addLoopTrap = function(branch, id) {
    id = id.replace(/\$/g, "$$$$");
    if (this.INFINITE_LOOP_TRAP) branch = this.INFINITE_LOOP_TRAP.replace(/%1/g, "'" + id + "'") + branch;
    if (this.STATEMENT_PREFIX) branch += this.prefixLines(this.STATEMENT_PREFIX.replace(/%1/g, "'" + id + "'"), this.INDENT);
    return branch
};
Blockly.Generator.prototype.RESERVED_WORDS_ = "";
Blockly.Generator.prototype.addReservedWords = function(words) {
    this.RESERVED_WORDS_ += words + ","
};
Blockly.Generator.prototype.FUNCTION_NAME_PLACEHOLDER_ = "{leCUI8hutHZI4480Dc}";
Blockly.Generator.prototype.provideFunction_ = function(desiredName, code) {
    if (!this.definitions_[desiredName]) {
        var functionName = this.variableDB_.getDistinctName(desiredName, Blockly.Procedures.NAME_TYPE);
        this.functionNames_[desiredName] = functionName;
        var codeText = code.join("\n").replace(this.FUNCTION_NAME_PLACEHOLDER_REGEXP_, functionName);
        var oldCodeText;
        while (oldCodeText != codeText) {
            oldCodeText = codeText;
            codeText = codeText.replace(/^(( {2})*) {2}/gm, "$1\x00")
        }
        codeText = codeText.replace(/\0/g, this.INDENT);
        this.definitions_[desiredName] = codeText
    }
    return this.functionNames_[desiredName]
};
Blockly.Generator.prototype.init = function(_workspace) {};
Blockly.Generator.prototype.scrub_ = function(_block, code) {
    return code
};
Blockly.Generator.prototype.finish = function(code) {
    return code
};
Blockly.Generator.prototype.scrubNakedValue = function(line) {
    return line
};
goog.provide("Blockly.Gesture");
goog.require("Blockly.BlockAnimations");
goog.require("Blockly.BlockDragger");
goog.require("Blockly.BubbleDragger");
goog.require("Blockly.constants");
goog.require("Blockly.Events.Ui");
goog.require("Blockly.FlyoutDragger");
goog.require("Blockly.Tooltip");
goog.require("Blockly.Touch");
goog.require("Blockly.utils");
goog.require("Blockly.WorkspaceDragger");
goog.require("goog.math.Coordinate");
Blockly.Gesture = function(e, creatorWorkspace) {
    this.mouseDownXY_ = null;
    this.currentDragDeltaXY_ = null;
    this.startBubble_ = null;
    this.startField_ = null;
    this.startBlock_ = null;
    this.targetBlock_ = null;
    this.startWorkspace_ = null;
    this.creatorWorkspace_ = creatorWorkspace;
    this.hasExceededDragRadius_ = false;
    this.isDraggingWorkspace_ = false;
    this.isDraggingBlock_ = false;
    this.isDraggingBubble_ = false;
    this.mostRecentEvent_ = e;
    this.onMoveWrapper_ = null;
    this.onUpWrapper_ = null;
    this.bubbleDragger_ = null;
    this.blockDragger_ = null;
    this.workspaceDragger_ =
        null;
    this.flyout_ = null;
    this.calledUpdateIsDragging_ = false;
    this.hasStarted_ = false;
    this.isEnding_ = false;
    this.healStack_ = !Blockly.DRAG_STACK
};
Blockly.Gesture.prototype.dispose = function() {
    Blockly.Touch.clearTouchIdentifier();
    Blockly.Tooltip.unblock();
    this.creatorWorkspace_.clearGesture();
    if (this.onMoveWrapper_) Blockly.unbindEvent_(this.onMoveWrapper_);
    if (this.onUpWrapper_) Blockly.unbindEvent_(this.onUpWrapper_);
    this.startField_ = null;
    this.startBlock_ = null;
    this.targetBlock_ = null;
    this.startWorkspace_ = null;
    this.flyout_ = null;
    if (this.blockDragger_) {
        this.blockDragger_.dispose();
        this.blockDragger_ = null
    }
    if (this.workspaceDragger_) {
        this.workspaceDragger_.dispose();
        this.workspaceDragger_ = null
    }
    if (this.bubbleDragger_) {
        this.bubbleDragger_.dispose();
        this.bubbleDragger_ = null
    }
};
Blockly.Gesture.prototype.updateFromEvent_ = function(e) {
    var currentXY = new goog.math.Coordinate(e.clientX, e.clientY);
    var changed = this.updateDragDelta_(currentXY);
    if (changed) {
        this.updateIsDragging_();
        Blockly.longStop_()
    }
    this.mostRecentEvent_ = e
};
Blockly.Gesture.prototype.updateDragDelta_ = function(currentXY) {
    this.currentDragDeltaXY_ = goog.math.Coordinate.difference(currentXY, this.mouseDownXY_);
    if (!this.hasExceededDragRadius_) {
        var currentDragDelta = goog.math.Coordinate.magnitude(this.currentDragDeltaXY_);
        var limitRadius = this.flyout_ ? Blockly.FLYOUT_DRAG_RADIUS : Blockly.DRAG_RADIUS;
        this.hasExceededDragRadius_ = currentDragDelta > limitRadius;
        return this.hasExceededDragRadius_
    }
    return false
};
Blockly.Gesture.prototype.updateIsDraggingFromFlyout_ = function() {
    if (this.targetBlock_.disabled) return false;
    if (!this.flyout_.isScrollable() || this.flyout_.isDragTowardWorkspace(this.currentDragDeltaXY_)) {
        this.startWorkspace_ = this.flyout_.targetWorkspace_;
        this.startWorkspace_.updateScreenCalculationsIfScrolled();
        if (!Blockly.Events.getGroup()) Blockly.Events.setGroup(true);
        this.startBlock_ = null;
        this.targetBlock_ = this.flyout_.createBlock(this.targetBlock_);
        this.targetBlock_.select();
        return true
    }
    return false
};
Blockly.Gesture.prototype.updateIsDraggingBubble_ = function() {
    if (!this.startBubble_) return false;
    this.isDraggingBubble_ = true;
    this.startDraggingBubble_();
    return true
};
Blockly.Gesture.prototype.updateIsDraggingBlock_ = function() {
    if (!this.targetBlock_) return false;
    if (this.flyout_) this.isDraggingBlock_ = this.updateIsDraggingFromFlyout_();
    else if (this.targetBlock_.isMovable()) this.isDraggingBlock_ = true;
    if (this.isDraggingBlock_) {
        this.startDraggingBlock_();
        return true
    }
    return false
};
Blockly.Gesture.prototype.updateIsDraggingWorkspace_ = function() {
    var wsMovable = this.flyout_ ? this.flyout_.isScrollable() : this.startWorkspace_ && this.startWorkspace_.isDraggable();
    if (!wsMovable) return;
    if (this.flyout_) this.workspaceDragger_ = new Blockly.FlyoutDragger(this.flyout_);
    else this.workspaceDragger_ = new Blockly.WorkspaceDragger(this.startWorkspace_);
    this.isDraggingWorkspace_ = true;
    this.workspaceDragger_.startDrag()
};
Blockly.Gesture.prototype.updateIsDragging_ = function() {
    if (this.calledUpdateIsDragging_) throw Error("updateIsDragging_ should only be called once per gesture.");
    this.calledUpdateIsDragging_ = true;
    if (this.updateIsDraggingBubble_()) return;
    if (this.updateIsDraggingBlock_()) return;
    this.updateIsDraggingWorkspace_()
};
Blockly.Gesture.prototype.startDraggingBlock_ = function() {
    this.blockDragger_ = new Blockly.BlockDragger(this.targetBlock_, this.startWorkspace_);
    this.blockDragger_.startBlockDrag(this.currentDragDeltaXY_, this.healStack_);
    this.blockDragger_.dragBlock(this.mostRecentEvent_, this.currentDragDeltaXY_)
};
Blockly.Gesture.prototype.startDraggingBubble_ = function() {
    this.bubbleDragger_ = new Blockly.BubbleDragger(this.startBubble_, this.startWorkspace_);
    this.bubbleDragger_.startBubbleDrag();
    this.bubbleDragger_.dragBubble(this.mostRecentEvent_, this.currentDragDeltaXY_)
};
Blockly.Gesture.prototype.doStart = function(e) {
    if (Blockly.utils.isTargetInput(e)) {
        this.cancel();
        return
    }
    this.hasStarted_ = true;
    Blockly.BlockAnimations.disconnectUiStop();
    this.startWorkspace_.updateScreenCalculationsIfScrolled();
    if (this.startWorkspace_.isMutator) this.startWorkspace_.resize();
    this.startWorkspace_.markFocused();
    this.mostRecentEvent_ = e;
    Blockly.hideChaff(!!this.flyout_);
    Blockly.Tooltip.block();
    if (this.targetBlock_) this.targetBlock_.select();
    if (Blockly.utils.isRightButton(e)) {
        this.handleRightClick(e);
        return
    }
    if ((e.type.toLowerCase() == "touchstart" || e.type.toLowerCase() == "pointerdown") && e.pointerType != "mouse") Blockly.longStart_(e, this);
    this.mouseDownXY_ = new goog.math.Coordinate(e.clientX, e.clientY);
    this.healStack_ = e.altKey || e.ctrlKey || e.metaKey;
    this.bindMouseEvents(e)
};
Blockly.Gesture.prototype.bindMouseEvents = function(e) {
    this.onMoveWrapper_ = Blockly.bindEventWithChecks_(document, "mousemove", null, this.handleMove.bind(this));
    this.onUpWrapper_ = Blockly.bindEventWithChecks_(document, "mouseup", null, this.handleUp.bind(this));
    e.preventDefault();
    e.stopPropagation()
};
Blockly.Gesture.prototype.handleMove = function(e) {
    this.updateFromEvent_(e);
    if (this.isDraggingWorkspace_) this.workspaceDragger_.drag(this.currentDragDeltaXY_);
    else if (this.isDraggingBlock_) this.blockDragger_.dragBlock(this.mostRecentEvent_, this.currentDragDeltaXY_);
    else if (this.isDraggingBubble_) this.bubbleDragger_.dragBubble(this.mostRecentEvent_, this.currentDragDeltaXY_);
    e.preventDefault();
    e.stopPropagation()
};
Blockly.Gesture.prototype.handleUp = function(e) {
    this.updateFromEvent_(e);
    Blockly.longStop_();
    if (this.isEnding_) {
        console.log("Trying to end a gesture recursively.");
        return
    }
    this.isEnding_ = true;
    if (this.isDraggingBubble_) this.bubbleDragger_.endBubbleDrag(e, this.currentDragDeltaXY_);
    else if (this.isDraggingBlock_) this.blockDragger_.endBlockDrag(e, this.currentDragDeltaXY_);
    else if (this.isDraggingWorkspace_) this.workspaceDragger_.endDrag(this.currentDragDeltaXY_);
    else if (this.isBubbleClick_()) this.doBubbleClick_();
    else if (this.isFieldClick_()) this.doFieldClick_();
    else if (this.isBlockClick_()) this.doBlockClick_();
    else if (this.isWorkspaceClick_()) this.doWorkspaceClick_();
    e.preventDefault();
    e.stopPropagation();
    this.dispose()
};
Blockly.Gesture.prototype.cancel = function() {
    if (this.isEnding_) return;
    Blockly.longStop_();
    if (this.isDraggingBubble_) this.bubbleDragger_.endBubbleDrag(this.mostRecentEvent_, this.currentDragDeltaXY_);
    else if (this.isDraggingBlock_) this.blockDragger_.endBlockDrag(this.mostRecentEvent_, this.currentDragDeltaXY_);
    else if (this.isDraggingWorkspace_) this.workspaceDragger_.endDrag(this.currentDragDeltaXY_);
    this.dispose()
};
Blockly.Gesture.prototype.handleRightClick = function(e) {
    if (this.targetBlock_) {
        this.bringBlockToFront_();
        Blockly.hideChaff(this.flyout_);
        this.targetBlock_.showContextMenu_(e)
    } else if (this.startBubble_) this.startBubble_.showContextMenu_(e);
    else if (this.startWorkspace_ && !this.flyout_) {
        Blockly.hideChaff();
        this.startWorkspace_.showContextMenu_(e)
    }
    e.preventDefault();
    e.stopPropagation();
    this.dispose()
};
Blockly.Gesture.prototype.handleWsStart = function(e, ws) {
    if (this.hasStarted_) throw Error("Tried to call gesture.handleWsStart, " + "but the gesture had already been started.");
    this.setStartWorkspace_(ws);
    this.mostRecentEvent_ = e;
    this.doStart(e)
};
Blockly.Gesture.prototype.handleFlyoutStart = function(e, flyout) {
    if (this.hasStarted_) throw Error("Tried to call gesture.handleFlyoutStart, " + "but the gesture had already been started.");
    this.setStartFlyout_(flyout);
    this.handleWsStart(e, flyout.getWorkspace())
};
Blockly.Gesture.prototype.handleBlockStart = function(e, block) {
    if (this.hasStarted_) throw Error("Tried to call gesture.handleBlockStart, " + "but the gesture had already been started.");
    this.setStartBlock(block);
    this.mostRecentEvent_ = e
};
Blockly.Gesture.prototype.handleBubbleStart = function(e, bubble) {
    if (this.hasStarted_) throw Error("Tried to call gesture.handleBubbleStart, " + "but the gesture had already been started.");
    this.setStartBubble(bubble);
    this.mostRecentEvent_ = e
};
Blockly.Gesture.prototype.doBubbleClick_ = function() {
    this.startBubble_.setFocus && this.startBubble_.setFocus();
    this.startBubble_.select && this.startBubble_.select()
};
Blockly.Gesture.prototype.doFieldClick_ = function() {
    this.startField_.showEditor_();
    this.bringBlockToFront_()
};
Blockly.Gesture.prototype.doBlockClick_ = function() {
    if (this.flyout_ && this.flyout_.autoClose) {
        if (!this.targetBlock_.disabled) {
            if (!Blockly.Events.getGroup()) Blockly.Events.setGroup(true);
            var newBlock = this.flyout_.createBlock(this.targetBlock_);
            newBlock.scheduleSnapAndBump()
        }
    } else Blockly.Events.fire(new Blockly.Events.Ui(this.startBlock_, "click", undefined, undefined));
    this.bringBlockToFront_();
    Blockly.Events.setGroup(false)
};
Blockly.Gesture.prototype.doWorkspaceClick_ = function() {
    if (Blockly.selected) Blockly.selected.unselect()
};
Blockly.Gesture.prototype.bringBlockToFront_ = function() {
    if (this.targetBlock_ && !this.flyout_) this.targetBlock_.bringToFront()
};
Blockly.Gesture.prototype.setStartField = function(field) {
    if (this.hasStarted_) throw Error("Tried to call gesture.setStartField, " + "but the gesture had already been started.");
    if (!this.startField_) this.startField_ = field
};
Blockly.Gesture.prototype.setStartBubble = function(bubble) {
    if (!this.startBubble_) this.startBubble_ = bubble
};
Blockly.Gesture.prototype.setStartBlock = function(block) {
    if (!this.startBlock_ && !this.startBubble_) {
        this.startBlock_ = block;
        if (block.isInFlyout && block != block.getRootBlock()) this.setTargetBlock_(block.getRootBlock());
        else this.setTargetBlock_(block)
    }
};
Blockly.Gesture.prototype.setTargetBlock_ = function(block) {
    if (block.isShadow()) this.setTargetBlock_(block.getParent());
    else this.targetBlock_ = block
};
Blockly.Gesture.prototype.setStartWorkspace_ = function(ws) {
    if (!this.startWorkspace_) this.startWorkspace_ = ws
};
Blockly.Gesture.prototype.setStartFlyout_ = function(flyout) {
    if (!this.flyout_) this.flyout_ = flyout
};
Blockly.Gesture.prototype.isBubbleClick_ = function() {
    var hasStartBubble = !!this.startBubble_;
    return hasStartBubble && !this.hasExceededDragRadius_
};
Blockly.Gesture.prototype.isBlockClick_ = function() {
    var hasStartBlock = !!this.startBlock_;
    return hasStartBlock && !this.hasExceededDragRadius_ && !this.isFieldClick_()
};
Blockly.Gesture.prototype.isFieldClick_ = function() {
    var fieldEditable = this.startField_ ? this.startField_.isCurrentlyEditable() : false;
    return fieldEditable && !this.hasExceededDragRadius_ && (!this.flyout_ || !this.flyout_.autoClose)
};
Blockly.Gesture.prototype.isWorkspaceClick_ = function() {
    var onlyTouchedWorkspace = !this.startBlock_ && !this.startBubble_ && !this.startField_;
    return onlyTouchedWorkspace && !this.hasExceededDragRadius_
};
Blockly.Gesture.prototype.isDragging = function() {
    return this.isDraggingWorkspace_ || this.isDraggingBlock_ || this.isDraggingBubble_
};
Blockly.Gesture.prototype.hasStarted = function() {
    return this.hasStarted_
};
goog.provide("Blockly.Grid");
goog.require("Blockly.utils");
goog.require("goog.userAgent");
Blockly.Grid = function(pattern, options) {
    this.gridPattern_ = pattern;
    this.spacing_ = options["spacing"];
    this.length_ = options["length"];
    this.line1_ = pattern.firstChild;
    this.line2_ = this.line1_ && this.line1_.nextSibling;
    this.snapToGrid_ = options["snap"]
};
Blockly.Grid.prototype.scale_ = 1;
Blockly.Grid.prototype.dispose = function() {
    this.gridPattern_ = null
};
Blockly.Grid.prototype.shouldSnap = function() {
    return this.snapToGrid_
};
Blockly.Grid.prototype.getSpacing = function() {
    return this.spacing_
};
Blockly.Grid.prototype.getPatternId = function() {
    return this.gridPattern_.id
};
Blockly.Grid.prototype.update = function(scale) {
    this.scale_ = scale;
    var safeSpacing = this.spacing_ * scale || 100;
    this.gridPattern_.setAttribute("width", safeSpacing);
    this.gridPattern_.setAttribute("height", safeSpacing);
    var half = Math.floor(this.spacing_ / 2) + .5;
    var start = half - this.length_ / 2;
    var end = half + this.length_ / 2;
    half *= scale;
    start *= scale;
    end *= scale;
    this.setLineAttributes_(this.line1_, scale, start, end, half, half);
    this.setLineAttributes_(this.line2_, scale, half, half, start, end)
};
Blockly.Grid.prototype.setLineAttributes_ = function(line, width, x1, x2, y1, y2) {
    if (line) {
        line.setAttribute("stroke-width", width);
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2)
    }
};
Blockly.Grid.prototype.moveTo = function(x, y) {
    this.gridPattern_.setAttribute("x", x);
    this.gridPattern_.setAttribute("y", y);
    if (goog.userAgent.IE || goog.userAgent.EDGE) this.update(this.scale_)
};
Blockly.Grid.createDom = function(rnd, gridOptions, defs) {
    var gridPattern = Blockly.utils.createSvgElement("pattern", {
        "id": "blocklyGridPattern" + rnd,
        "patternUnits": "userSpaceOnUse"
    }, defs);
    if (gridOptions["length"] > 0 && gridOptions["spacing"] > 0) {
        Blockly.utils.createSvgElement("line", {
            "stroke": gridOptions["colour"]
        }, gridPattern);
        if (gridOptions["length"] > 1) Blockly.utils.createSvgElement("line", {
            "stroke": gridOptions["colour"]
        }, gridPattern)
    } else Blockly.utils.createSvgElement("line", {}, gridPattern);
    return gridPattern
};
goog.provide("Blockly.Icon");
goog.require("Blockly.utils");
goog.require("goog.math.Coordinate");
Blockly.Icon = function(block) {
    this.block_ = block
};
Blockly.Icon.prototype.collapseHidden = true;
Blockly.Icon.prototype.SIZE = 17;
Blockly.Icon.prototype.bubble_ = null;
Blockly.Icon.prototype.iconXY_ = null;
Blockly.Icon.prototype.createIcon = function() {
    if (this.iconGroup_) return;
    this.iconGroup_ = Blockly.utils.createSvgElement("g", {
        "class": "blocklyIconGroup"
    }, null);
    if (this.block_.isInFlyout) Blockly.utils.addClass(this.iconGroup_, "blocklyIconGroupReadonly");
    this.drawIcon_(this.iconGroup_);
    this.block_.getSvgRoot().appendChild(this.iconGroup_);
    Blockly.bindEventWithChecks_(this.iconGroup_, "mouseup", this, this.iconClick_);
    this.updateEditable()
};
Blockly.Icon.prototype.dispose = function() {
    Blockly.utils.removeNode(this.iconGroup_);
    this.iconGroup_ = null;
    this.setVisible(false);
    this.block_ = null
};
Blockly.Icon.prototype.updateEditable = function() {};
Blockly.Icon.prototype.isVisible = function() {
    return !!this.bubble_
};
Blockly.Icon.prototype.iconClick_ = function(e) {
    if (this.block_.workspace.isDragging()) return;
    if (!this.block_.isInFlyout && !Blockly.utils.isRightButton(e)) this.setVisible(!this.isVisible())
};
Blockly.Icon.prototype.updateColour = function() {
    if (this.isVisible()) this.bubble_.setColour(this.block_.getColour())
};
Blockly.Icon.prototype.renderIcon = function(cursorX) {
    if (this.collapseHidden && this.block_.isCollapsed()) {
        this.iconGroup_.setAttribute("display", "none");
        return cursorX
    }
    this.iconGroup_.setAttribute("display", "block");
    var TOP_MARGIN = 5;
    var width = this.SIZE;
    if (this.block_.RTL) cursorX -= width;
    this.iconGroup_.setAttribute("transform", "translate(" + cursorX + "," + TOP_MARGIN + ")");
    this.computeIconLocation();
    if (this.block_.RTL) cursorX -= Blockly.BlockSvg.SEP_SPACE_X;
    else cursorX += width + Blockly.BlockSvg.SEP_SPACE_X;
    return cursorX
};
Blockly.Icon.prototype.setIconLocation = function(xy) {
    this.iconXY_ = xy;
    if (this.isVisible()) this.bubble_.setAnchorLocation(xy)
};
Blockly.Icon.prototype.computeIconLocation = function() {
    var blockXY = this.block_.getRelativeToSurfaceXY();
    var iconXY = Blockly.utils.getRelativeXY(this.iconGroup_);
    var newXY = new goog.math.Coordinate(blockXY.x + iconXY.x + this.SIZE / 2, blockXY.y + iconXY.y + this.SIZE / 2);
    if (!goog.math.Coordinate.equals(this.getIconLocation(), newXY)) this.setIconLocation(newXY)
};
Blockly.Icon.prototype.getIconLocation = function() {
    return this.iconXY_
};
goog.provide("Blockly.inject");
goog.require("Blockly.BlockDragSurfaceSvg");
goog.require("Blockly.Css");
goog.require("Blockly.Grid");
goog.require("Blockly.Options");
goog.require("Blockly.utils");
goog.require("Blockly.WorkspaceSvg");
goog.require("Blockly.WorkspaceDragSurfaceSvg");
goog.require("goog.ui.Component");
goog.require("goog.userAgent");
Blockly.inject = function(container, opt_options) {
    Blockly.checkBlockColourConstants();
    if (typeof container == "string") container = document.getElementById(container) || document.querySelector(container);
    if (!Blockly.utils.containsNode(document, container)) throw Error("Error: container is not in current document.");
    var options = new Blockly.Options(opt_options || {});
    var subContainer = document.createElement("div");
    subContainer.className = "injectionDiv";
    container.appendChild(subContainer);
    var svg = Blockly.createDom_(subContainer,
        options);
    var blockDragSurface = new Blockly.BlockDragSurfaceSvg(subContainer);
    var workspaceDragSurface = new Blockly.WorkspaceDragSurfaceSvg(subContainer);
    var workspace = Blockly.createMainWorkspace_(svg, options, blockDragSurface, workspaceDragSurface);
    Blockly.init_(workspace);
    Blockly.mainWorkspace = workspace;
    Blockly.svgResize(workspace);
    return workspace
};
Blockly.createDom_ = function(container, options) {
    container.setAttribute("dir", "LTR");
    goog.ui.Component.setDefaultRightToLeft(options.RTL);
    Blockly.Css.inject(options.hasCss, options.pathToMedia);
    var svg = Blockly.utils.createSvgElement("svg", {
        "xmlns": "http://www.w3.org/2000/svg",
        "xmlns:html": "http://www.w3.org/1999/xhtml",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "version": "1.1",
        "class": "blocklySvg"
    }, container);
    var defs = Blockly.utils.createSvgElement("defs", {}, svg);
    var rnd = String(Math.random()).substring(2);
    var embossFilter = Blockly.utils.createSvgElement("filter", {
        "id": "blocklyEmbossFilter" + rnd
    }, defs);
    Blockly.utils.createSvgElement("feGaussianBlur", {
        "in": "SourceAlpha",
        "stdDeviation": 1,
        "result": "blur"
    }, embossFilter);
    var feSpecularLighting = Blockly.utils.createSvgElement("feSpecularLighting", {
        "in": "blur",
        "surfaceScale": 1,
        "specularConstant": .5,
        "specularExponent": 10,
        "lighting-color": "white",
        "result": "specOut"
    }, embossFilter);
    Blockly.utils.createSvgElement("fePointLight", {
        "x": -5E3,
        "y": -1E4,
        "z": 2E4
    }, feSpecularLighting);
    Blockly.utils.createSvgElement("feComposite", {
        "in": "specOut",
        "in2": "SourceAlpha",
        "operator": "in",
        "result": "specOut"
    }, embossFilter);
    Blockly.utils.createSvgElement("feComposite", {
        "in": "SourceGraphic",
        "in2": "specOut",
        "operator": "arithmetic",
        "k1": 0,
        "k2": 1,
        "k3": 1,
        "k4": 0
    }, embossFilter);
    options.embossFilterId = embossFilter.id;
    var disabledPattern = Blockly.utils.createSvgElement("pattern", {
        "id": "blocklyDisabledPattern" + rnd,
        "patternUnits": "userSpaceOnUse",
        "width": 10,
        "height": 10
    }, defs);
    Blockly.utils.createSvgElement("rect", {
        "width": 10,
        "height": 10,
        "fill": "#aaa"
    }, disabledPattern);
    Blockly.utils.createSvgElement("path", {
        "d": "M 0 0 L 10 10 M 10 0 L 0 10",
        "stroke": "#cc0"
    }, disabledPattern);
    options.disabledPatternId = disabledPattern.id;
    options.gridPattern = Blockly.Grid.createDom(rnd, options.gridOptions, defs);
    return svg
};
Blockly.createMainWorkspace_ = function(svg, options, blockDragSurface, workspaceDragSurface) {
    options.parentWorkspace = null;
    var mainWorkspace = new Blockly.WorkspaceSvg(options, blockDragSurface, workspaceDragSurface);
    mainWorkspace.scale = options.zoomOptions.startScale;
    svg.appendChild(mainWorkspace.createDom("blocklyMainBackground"));
    if (!options.hasCategories && options.languageTree) {
        var flyout = mainWorkspace.addFlyout_("svg");
        Blockly.utils.insertAfter(flyout, svg)
    }
    mainWorkspace.translate(0, 0);
    Blockly.mainWorkspace =
        mainWorkspace;
    if (!options.readOnly && !options.hasScrollbars) {
        var workspaceChanged = function() {
            if (!mainWorkspace.isDragging()) {
                var metrics = mainWorkspace.getMetrics();
                var edgeLeft = metrics.viewLeft + metrics.absoluteLeft;
                var edgeTop = metrics.viewTop + metrics.absoluteTop;
                if (metrics.contentTop < edgeTop || metrics.contentTop + metrics.contentHeight > metrics.viewHeight + edgeTop || metrics.contentLeft < (options.RTL ? metrics.viewLeft : edgeLeft) || metrics.contentLeft + metrics.contentWidth > (options.RTL ? metrics.viewWidth : metrics.viewWidth +
                        edgeLeft)) {
                    var MARGIN = 25;
                    var blocks = mainWorkspace.getTopBlocks(false);
                    for (var b = 0, block; block = blocks[b]; b++) {
                        var blockXY = block.getRelativeToSurfaceXY();
                        var blockHW = block.getHeightWidth();
                        var overflowTop = edgeTop + MARGIN - blockHW.height - blockXY.y;
                        if (overflowTop > 0) block.moveBy(0, overflowTop);
                        var overflowBottom = edgeTop + metrics.viewHeight - MARGIN - blockXY.y;
                        if (overflowBottom < 0) block.moveBy(0, overflowBottom);
                        var overflowLeft = MARGIN + edgeLeft - blockXY.x - (options.RTL ? 0 : blockHW.width);
                        if (overflowLeft > 0) block.moveBy(overflowLeft,
                            0);
                        var overflowRight = edgeLeft + metrics.viewWidth - MARGIN - blockXY.x + (options.RTL ? blockHW.width : 0);
                        if (overflowRight < 0) block.moveBy(overflowRight, 0)
                    }
                }
            }
        };
        mainWorkspace.addChangeListener(workspaceChanged)
    }
    Blockly.svgResize(mainWorkspace);
    Blockly.WidgetDiv.createDom();
    Blockly.Tooltip.createDom();
    return mainWorkspace
};
Blockly.init_ = function(mainWorkspace) {
    var options = mainWorkspace.options;
    var svg = mainWorkspace.getParentSvg();
    Blockly.bindEventWithChecks_(svg.parentNode, "contextmenu", null, function(e) {
        if (!Blockly.utils.isTargetInput(e)) e.preventDefault()
    });
    var workspaceResizeHandler = Blockly.bindEventWithChecks_(window, "resize", null, function() {
        Blockly.hideChaff(true);
        Blockly.svgResize(mainWorkspace)
    });
    mainWorkspace.setResizeHandlerWrapper(workspaceResizeHandler);
    Blockly.inject.bindDocumentEvents_();
    if (options.languageTree)
        if (mainWorkspace.toolbox_) mainWorkspace.toolbox_.init(mainWorkspace);
        else if (mainWorkspace.flyout_) {
        mainWorkspace.flyout_.init(mainWorkspace);
        mainWorkspace.flyout_.show(options.languageTree.childNodes);
        mainWorkspace.flyout_.scrollToStart();
        mainWorkspace.scrollX = mainWorkspace.flyout_.width_;
        if (options.toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) mainWorkspace.scrollX *= -1;
        mainWorkspace.translate(mainWorkspace.scrollX, 0)
    }
    if (options.hasScrollbars) {
        mainWorkspace.scrollbar = new Blockly.ScrollbarPair(mainWorkspace);
        mainWorkspace.scrollbar.resize()
    }
    if (options.hasSounds) Blockly.inject.loadSounds_(options.pathToMedia,
        mainWorkspace)
};
Blockly.inject.bindDocumentEvents_ = function() {
    if (!Blockly.documentEventsBound_) {
        Blockly.bindEventWithChecks_(document, "keydown", null, Blockly.onKeyDown_);
        Blockly.bindEvent_(document, "touchend", null, Blockly.longStop_);
        Blockly.bindEvent_(document, "touchcancel", null, Blockly.longStop_);
        if (goog.userAgent.IPAD) Blockly.bindEventWithChecks_(window, "orientationchange", document, function() {
            Blockly.svgResize(Blockly.getMainWorkspace())
        })
    }
    Blockly.documentEventsBound_ = true
};
Blockly.inject.loadSounds_ = function(pathToMedia, workspace) {
    var audioMgr = workspace.getAudioManager();
    audioMgr.load([pathToMedia + "click.mp3", pathToMedia + "click.wav", pathToMedia + "click.ogg"], "click");
    audioMgr.load([pathToMedia + "disconnect.wav", pathToMedia + "disconnect.mp3", pathToMedia + "disconnect.ogg"], "disconnect");
    audioMgr.load([pathToMedia + "delete.mp3", pathToMedia + "delete.ogg", pathToMedia + "delete.wav"], "delete");
    var soundBinds = [];
    var unbindSounds = function() {
        while (soundBinds.length) Blockly.unbindEvent_(soundBinds.pop());
        audioMgr.preload()
    };
    soundBinds.push(Blockly.bindEventWithChecks_(document, "mousemove", null, unbindSounds, true));
    soundBinds.push(Blockly.bindEventWithChecks_(document, "touchstart", null, unbindSounds, true))
};
Blockly.updateToolbox = function(tree) {
    console.warn("Deprecated call to Blockly.updateToolbox, " + "use workspace.updateToolbox instead.");
    Blockly.getMainWorkspace().updateToolbox(tree)
};
goog.provide("Blockly.Input");
goog.require("Blockly.Connection");
goog.require("Blockly.FieldLabel");
Blockly.Input = function(type, name, block, connection) {
    if (type != Blockly.DUMMY_INPUT && !name) throw Error("Value inputs and statement inputs must have non-empty name.");
    this.type = type;
    this.name = name;
    this.sourceBlock_ = block;
    this.connection = connection;
    this.fieldRow = []
};
Blockly.Input.prototype.align = Blockly.ALIGN_LEFT;
Blockly.Input.prototype.visible_ = true;
Blockly.Input.prototype.appendField = function(field, opt_name) {
    this.insertFieldAt(this.fieldRow.length, field, opt_name);
    return this
};
Blockly.Input.prototype.insertFieldAt = function(index, field, opt_name) {
    if (index < 0 || index > this.fieldRow.length) throw Error("index " + index + " out of bounds.");
    if (!field && !opt_name) return index;
    if (typeof field == "string") field = new Blockly.FieldLabel(field);
    field.setSourceBlock(this.sourceBlock_);
    if (this.sourceBlock_.rendered) field.init();
    field.name = opt_name;
    if (field.prefixField) index = this.insertFieldAt(index, field.prefixField);
    this.fieldRow.splice(index, 0, field);
    ++index;
    if (field.suffixField) index = this.insertFieldAt(index,
        field.suffixField);
    if (this.sourceBlock_.rendered) {
        this.sourceBlock_.render();
        this.sourceBlock_.bumpNeighbours_()
    }
    return index
};
Blockly.Input.prototype.removeField = function(name) {
    for (var i = 0, field; field = this.fieldRow[i]; i++)
        if (field.name === name) {
            field.dispose();
            this.fieldRow.splice(i, 1);
            if (this.sourceBlock_.rendered) {
                this.sourceBlock_.render();
                this.sourceBlock_.bumpNeighbours_()
            }
            return
        } throw Error('Field "%s" not found.', name);
};
Blockly.Input.prototype.isVisible = function() {
    return this.visible_
};
Blockly.Input.prototype.setVisible = function(visible) {
    var renderList = [];
    if (this.visible_ == visible) return renderList;
    this.visible_ = visible;
    var display = visible ? "block" : "none";
    for (var y = 0, field; field = this.fieldRow[y]; y++) field.setVisible(visible);
    if (this.connection) {
        if (visible) renderList = this.connection.unhideAll();
        else this.connection.hideAll();
        var child = this.connection.targetBlock();
        if (child) {
            child.getSvgRoot().style.display = display;
            if (!visible) child.rendered = false
        }
    }
    return renderList
};
Blockly.Input.prototype.setCheck = function(check) {
    if (!this.connection) throw Error("This input does not have a connection.");
    this.connection.setCheck(check);
    return this
};
Blockly.Input.prototype.setAlign = function(align) {
    this.align = align;
    if (this.sourceBlock_.rendered) this.sourceBlock_.render();
    return this
};
Blockly.Input.prototype.init = function() {
    if (!this.sourceBlock_.workspace.rendered) return;
    for (var i = 0; i < this.fieldRow.length; i++) this.fieldRow[i].init()
};
Blockly.Input.prototype.dispose = function() {
    for (var i = 0, field; field = this.fieldRow[i]; i++) field.dispose();
    if (this.connection) this.connection.dispose();
    this.sourceBlock_ = null
};
goog.provide("Blockly.Msg");
goog.getMsgOrig = goog.getMsg;
goog.getMsg = function(str, opt_values) {
    var key = goog.getMsg.blocklyMsgMap[str];
    if (key) str = Blockly.Msg[key];
    return goog.getMsgOrig(str, opt_values)
};
goog.getMsg.blocklyMsgMap = {
    "Today": "TODAY"
};
goog.provide("Blockly.Mutator");
goog.require("Blockly.Bubble");
goog.require("Blockly.Events.BlockChange");
goog.require("Blockly.Events.Ui");
goog.require("Blockly.Icon");
goog.require("Blockly.utils");
goog.require("Blockly.WorkspaceSvg");
goog.require("Blockly.Xml");
goog.require("Blockly.Xml.utils");
Blockly.Mutator = function(quarkNames) {
    Blockly.Mutator.superClass_.constructor.call(this, null);
    this.quarkNames_ = quarkNames
};
goog.inherits(Blockly.Mutator, Blockly.Icon);
Blockly.Mutator.prototype.workspaceWidth_ = 0;
Blockly.Mutator.prototype.workspaceHeight_ = 0;
Blockly.Mutator.prototype.drawIcon_ = function(group) {
    Blockly.utils.createSvgElement("rect", {
        "class": "blocklyIconShape",
        "rx": "4",
        "ry": "4",
        "height": "16",
        "width": "16"
    }, group);
    Blockly.utils.createSvgElement("path", {
        "class": "blocklyIconSymbol",
        "d": "m4.203,7.296 0,1.368 -0.92,0.677 -0.11,0.41 0.9,1.559 0.41," + "0.11 1.043,-0.457 1.187,0.683 0.127,1.134 0.3,0.3 1.8,0 0.3," + "-0.299 0.127,-1.138 1.185,-0.682 1.046,0.458 0.409,-0.11 0.9," + "-1.559 -0.11,-0.41 -0.92,-0.677 0,-1.366 0.92,-0.677 0.11," + "-0.41 -0.9,-1.559 -0.409,-0.109 -1.046,0.458 -1.185,-0.682 " +
            "-0.127,-1.138 -0.3,-0.299 -1.8,0 -0.3,0.3 -0.126,1.135 -1.187," + "0.682 -1.043,-0.457 -0.41,0.11 -0.899,1.559 0.108,0.409z"
    }, group);
    Blockly.utils.createSvgElement("circle", {
        "class": "blocklyIconShape",
        "r": "2.7",
        "cx": "8",
        "cy": "8"
    }, group)
};
Blockly.Mutator.prototype.iconClick_ = function(e) {
    if (this.block_.isEditable()) Blockly.Icon.prototype.iconClick_.call(this, e)
};
Blockly.Mutator.prototype.createEditor_ = function() {
    this.svgDialog_ = Blockly.utils.createSvgElement("svg", {
        "x": Blockly.Bubble.BORDER_WIDTH,
        "y": Blockly.Bubble.BORDER_WIDTH
    }, null);
    if (this.quarkNames_.length) {
        var quarkXml = Blockly.Xml.utils.createElement("xml");
        for (var i = 0, quarkName; quarkName = this.quarkNames_[i]; i++) {
            var element = Blockly.Xml.utils.createElement("block");
            element.setAttribute("type", quarkName);
            quarkXml.appendChild(element)
        }
    } else var quarkXml = null;
    var workspaceOptions = {
        languageTree: quarkXml,
        parentWorkspace: this.block_.workspace,
        pathToMedia: this.block_.workspace.options.pathToMedia,
        RTL: this.block_.RTL,
        toolboxPosition: this.block_.RTL ? Blockly.TOOLBOX_AT_RIGHT : Blockly.TOOLBOX_AT_LEFT,
        horizontalLayout: false,
        getMetrics: this.getFlyoutMetrics_.bind(this),
        setMetrics: null
    };
    this.workspace_ = new Blockly.WorkspaceSvg(workspaceOptions);
    this.workspace_.isMutator = true;
    var flyoutSvg = this.workspace_.addFlyout_("g");
    var background = this.workspace_.createDom("blocklyMutatorBackground");
    background.insertBefore(flyoutSvg,
        this.workspace_.svgBlockCanvas_);
    this.svgDialog_.appendChild(background);
    return this.svgDialog_
};
Blockly.Mutator.prototype.updateEditable = function() {
    if (!this.block_.isInFlyout)
        if (this.block_.isEditable()) {
            if (this.iconGroup_) Blockly.utils.removeClass(this.iconGroup_, "blocklyIconGroupReadonly")
        } else {
            this.setVisible(false);
            if (this.iconGroup_) Blockly.utils.addClass(this.iconGroup_, "blocklyIconGroupReadonly")
        } Blockly.Icon.prototype.updateEditable.call(this)
};
Blockly.Mutator.prototype.resizeBubble_ = function() {
    var doubleBorderWidth = 2 * Blockly.Bubble.BORDER_WIDTH;
    var workspaceSize = this.workspace_.getCanvas().getBBox();
    var width;
    if (this.block_.RTL) width = -workspaceSize.x;
    else width = workspaceSize.width + workspaceSize.x;
    var height = workspaceSize.height + doubleBorderWidth * 3;
    if (this.workspace_.flyout_) {
        var flyoutMetrics = this.workspace_.flyout_.getMetrics_();
        height = Math.max(height, flyoutMetrics.contentHeight + 20)
    }
    width += doubleBorderWidth * 3;
    if (Math.abs(this.workspaceWidth_ -
            width) > doubleBorderWidth || Math.abs(this.workspaceHeight_ - height) > doubleBorderWidth) {
        this.workspaceWidth_ = width;
        this.workspaceHeight_ = height;
        this.bubble_.setBubbleSize(width + doubleBorderWidth, height + doubleBorderWidth);
        this.svgDialog_.setAttribute("width", this.workspaceWidth_);
        this.svgDialog_.setAttribute("height", this.workspaceHeight_)
    }
    if (this.block_.RTL) {
        var translation = "translate(" + this.workspaceWidth_ + ",0)";
        this.workspace_.getCanvas().setAttribute("transform", translation)
    }
    this.workspace_.resize()
};
Blockly.Mutator.prototype.setVisible = function(visible) {
    if (visible == this.isVisible()) return;
    Blockly.Events.fire(new Blockly.Events.Ui(this.block_, "mutatorOpen", !visible, visible));
    if (visible) {
        this.bubble_ = new Blockly.Bubble(this.block_.workspace, this.createEditor_(), this.block_.svgPath_, this.iconXY_, null, null);
        this.bubble_.setSvgId(this.block_.id);
        var tree = this.workspace_.options.languageTree;
        if (tree) {
            this.workspace_.flyout_.init(this.workspace_);
            this.workspace_.flyout_.show(tree.childNodes)
        }
        this.rootBlock_ =
            this.block_.decompose(this.workspace_);
        var blocks = this.rootBlock_.getDescendants(false);
        for (var i = 0, child; child = blocks[i]; i++) child.render();
        this.rootBlock_.setMovable(false);
        this.rootBlock_.setDeletable(false);
        if (this.workspace_.flyout_) {
            var margin = this.workspace_.flyout_.CORNER_RADIUS * 2;
            var x = this.workspace_.flyout_.width_ + margin
        } else {
            var margin = 16;
            var x = margin
        }
        if (this.block_.RTL) x = -x;
        this.rootBlock_.moveBy(x, margin);
        if (this.block_.saveConnections) {
            var thisMutator = this;
            this.block_.saveConnections(this.rootBlock_);
            this.sourceListener_ = function() {
                thisMutator.block_.saveConnections(thisMutator.rootBlock_)
            };
            this.block_.workspace.addChangeListener(this.sourceListener_)
        }
        this.resizeBubble_();
        this.workspace_.addChangeListener(this.workspaceChanged_.bind(this));
        this.updateColour()
    } else {
        this.svgDialog_ = null;
        this.workspace_.dispose();
        this.workspace_ = null;
        this.rootBlock_ = null;
        this.bubble_.dispose();
        this.bubble_ = null;
        this.workspaceWidth_ = 0;
        this.workspaceHeight_ = 0;
        if (this.sourceListener_) {
            this.block_.workspace.removeChangeListener(this.sourceListener_);
            this.sourceListener_ = null
        }
    }
};
Blockly.Mutator.prototype.workspaceChanged_ = function() {
    if (!this.workspace_.isDragging()) {
        var blocks = this.workspace_.getTopBlocks(false);
        var MARGIN = 20;
        for (var b = 0, block; block = blocks[b]; b++) {
            var blockXY = block.getRelativeToSurfaceXY();
            var blockHW = block.getHeightWidth();
            if (blockXY.y + blockHW.height < MARGIN) block.moveBy(0, MARGIN - blockHW.height - blockXY.y)
        }
    }
    if (this.rootBlock_.workspace == this.workspace_) {
        Blockly.Events.setGroup(true);
        var block = this.block_;
        var oldMutationDom = block.mutationToDom();
        var oldMutation =
            oldMutationDom && Blockly.Xml.domToText(oldMutationDom);
        var savedRendered = block.rendered;
        block.rendered = false;
        block.compose(this.rootBlock_);
        block.rendered = savedRendered;
        block.initSvg();
        var newMutationDom = block.mutationToDom();
        var newMutation = newMutationDom && Blockly.Xml.domToText(newMutationDom);
        if (oldMutation != newMutation) {
            Blockly.Events.fire(new Blockly.Events.BlockChange(block, "mutation", null, oldMutation, newMutation));
            var group = Blockly.Events.getGroup();
            setTimeout(function() {
                Blockly.Events.setGroup(group);
                block.bumpNeighbours_();
                Blockly.Events.setGroup(false)
            }, Blockly.BUMP_DELAY)
        }
        if (block.rendered) block.render();
        if (!this.workspace_.isDragging()) this.resizeBubble_();
        Blockly.Events.setGroup(false)
    }
};
Blockly.Mutator.prototype.getFlyoutMetrics_ = function() {
    return {
        viewHeight: this.workspaceHeight_,
        viewWidth: this.workspaceWidth_,
        absoluteTop: 0,
        absoluteLeft: 0
    }
};
Blockly.Mutator.prototype.dispose = function() {
    this.block_.mutator = null;
    Blockly.Icon.prototype.dispose.call(this)
};
Blockly.Mutator.reconnect = function(connectionChild, block, inputName) {
    if (!connectionChild || !connectionChild.getSourceBlock().workspace) return false;
    var connectionParent = block.getInput(inputName).connection;
    var currentParent = connectionChild.targetBlock();
    if ((!currentParent || currentParent == block) && connectionParent.targetConnection != connectionChild) {
        if (connectionParent.isConnected()) connectionParent.disconnect();
        connectionParent.connect(connectionChild);
        return true
    }
    return false
};
Blockly.Mutator.findParentWs = function(workspace) {
    var outerWs = null;
    if (workspace && workspace.options) {
        var parent = workspace.options.parentWorkspace;
        if (workspace.isFlyout) {
            if (parent && parent.options) outerWs = parent.options.parentWorkspace
        } else if (parent) outerWs = parent
    }
    return outerWs
};
if (!goog.global["Blockly"]) goog.global["Blockly"] = {};
if (!goog.global["Blockly"]["Mutator"]) goog.global["Blockly"]["Mutator"] = {};
goog.global["Blockly"]["Mutator"]["reconnect"] = Blockly.Mutator.reconnect;
goog.provide("Blockly.Names");
Blockly.Names = function(reservedWords, opt_variablePrefix) {
    this.variablePrefix_ = opt_variablePrefix || "";
    this.reservedDict_ = Object.create(null);
    if (reservedWords) {
        var splitWords = reservedWords.split(",");
        for (var i = 0; i < splitWords.length; i++) this.reservedDict_[splitWords[i]] = true
    }
    this.reset()
};
Blockly.Names.DEVELOPER_VARIABLE_TYPE = "DEVELOPER_VARIABLE";
Blockly.Names.prototype.reset = function() {
    this.db_ = Object.create(null);
    this.dbReverse_ = Object.create(null);
    this.variableMap_ = null
};
Blockly.Names.prototype.setVariableMap = function(map) {
    this.variableMap_ = map
};
Blockly.Names.prototype.getNameForUserVariable_ = function(id) {
    if (!this.variableMap_) {
        console.log("Deprecated call to Blockly.Names.prototype.getName without " + "defining a variable map. To fix, add the folowing code in your " + "generator's init() function:\n" + "Blockly.YourGeneratorName.variableDB_.setVariableMap(" + "workspace.getVariableMap());");
        return null
    }
    var variable = this.variableMap_.getVariableById(id);
    if (variable) return variable.name;
    else return null
};
Blockly.Names.prototype.getName = function(name, type) {
    if (type == Blockly.Variables.NAME_TYPE) {
        var varName = this.getNameForUserVariable_(name);
        if (varName) name = varName
    }
    var normalized = name.toLowerCase() + "_" + type;
    var isVarType = type == Blockly.Variables.NAME_TYPE || type == Blockly.Names.DEVELOPER_VARIABLE_TYPE;
    var prefix = isVarType ? this.variablePrefix_ : "";
    if (normalized in this.db_) return prefix + this.db_[normalized];
    var safeName = this.getDistinctName(name, type);
    this.db_[normalized] = safeName.substr(prefix.length);
    return safeName
};
Blockly.Names.prototype.getDistinctName = function(name, type) {
    var safeName = this.safeName_(name);
    var i = "";
    while (this.dbReverse_[safeName + i] || safeName + i in this.reservedDict_) i = i ? i + 1 : 2;
    safeName += i;
    this.dbReverse_[safeName] = true;
    var isVarType = type == Blockly.Variables.NAME_TYPE || type == Blockly.Names.DEVELOPER_VARIABLE_TYPE;
    var prefix = isVarType ? this.variablePrefix_ : "";
    return prefix + safeName
};
Blockly.Names.prototype.safeName_ = function(name) {
    if (!name) name = "unnamed";
    else {
        name = encodeURI(name.replace(/ /g, "_")).replace(/[^\w]/g, "_");
        if ("0123456789".indexOf(name[0]) != -1) name = "my_" + name
    }
    return name
};
Blockly.Names.equals = function(name1, name2) {
    return name1.toLowerCase() == name2.toLowerCase()
};
goog.provide("Blockly.Options");
goog.require("Blockly.Xml");
Blockly.Options = function(options) {
    var readOnly = !!options["readOnly"];
    if (readOnly) {
        var languageTree = null;
        var hasCategories = false;
        var hasTrashcan = false;
        var hasCollapse = false;
        var hasComments = false;
        var hasDisable = false;
        var hasSounds = false
    } else {
        var languageTree = Blockly.Options.parseToolboxTree(options["toolbox"]);
        var hasCategories = Boolean(languageTree && languageTree.getElementsByTagName("category").length);
        var hasTrashcan = options["trashcan"];
        if (hasTrashcan === undefined) hasTrashcan = hasCategories;
        var hasCollapse =
            options["collapse"];
        if (hasCollapse === undefined) hasCollapse = hasCategories;
        var hasComments = options["comments"];
        if (hasComments === undefined) hasComments = hasCategories;
        var hasDisable = options["disable"];
        if (hasDisable === undefined) hasDisable = hasCategories;
        var hasSounds = options["sounds"];
        if (hasSounds === undefined) hasSounds = true
    }
    var rtl = !!options["rtl"];
    var horizontalLayout = options["horizontalLayout"];
    if (horizontalLayout === undefined) horizontalLayout = false;
    var toolboxAtStart = options["toolboxPosition"];
    if (toolboxAtStart ===
        "end") toolboxAtStart = false;
    else toolboxAtStart = true;
    if (horizontalLayout) var toolboxPosition = toolboxAtStart ? Blockly.TOOLBOX_AT_TOP : Blockly.TOOLBOX_AT_BOTTOM;
    else var toolboxPosition = toolboxAtStart == rtl ? Blockly.TOOLBOX_AT_RIGHT : Blockly.TOOLBOX_AT_LEFT;
    var hasScrollbars = options["scrollbars"];
    if (hasScrollbars === undefined) hasScrollbars = hasCategories;
    var hasCss = options["css"];
    if (hasCss === undefined) hasCss = true;
    var pathToMedia = "https://blockly-demo.appspot.com/static/media/";
    if (options["media"]) pathToMedia =
        options["media"];
    else if (options["path"]) pathToMedia = options["path"] + "media/";
    if (options["oneBasedIndex"] === undefined) var oneBasedIndex = true;
    else var oneBasedIndex = !!options["oneBasedIndex"];
    this.RTL = rtl;
    this.oneBasedIndex = oneBasedIndex;
    this.collapse = hasCollapse;
    this.comments = hasComments;
    this.disable = hasDisable;
    this.readOnly = readOnly;
    this.maxBlocks = options["maxBlocks"] || Infinity;
    this.pathToMedia = pathToMedia;
    this.hasCategories = hasCategories;
    this.hasScrollbars = hasScrollbars;
    this.hasTrashcan = hasTrashcan;
    this.hasSounds = hasSounds;
    this.hasCss = hasCss;
    this.horizontalLayout = horizontalLayout;
    this.languageTree = languageTree;
    this.gridOptions = Blockly.Options.parseGridOptions_(options);
    this.zoomOptions = Blockly.Options.parseZoomOptions_(options);
    this.toolboxPosition = toolboxPosition
};
Blockly.Options.prototype.parentWorkspace = null;
Blockly.Options.prototype.setMetrics = null;
Blockly.Options.prototype.getMetrics = null;
Blockly.Options.parseZoomOptions_ = function(options) {
    var zoom = options["zoom"] || {};
    var zoomOptions = {};
    if (zoom["controls"] === undefined) zoomOptions.controls = false;
    else zoomOptions.controls = !!zoom["controls"];
    if (zoom["wheel"] === undefined) zoomOptions.wheel = false;
    else zoomOptions.wheel = !!zoom["wheel"];
    if (zoom["startScale"] === undefined) zoomOptions.startScale = 1;
    else zoomOptions.startScale = parseFloat(zoom["startScale"]);
    if (zoom["maxScale"] === undefined) zoomOptions.maxScale = 3;
    else zoomOptions.maxScale = parseFloat(zoom["maxScale"]);
    if (zoom["minScale"] === undefined) zoomOptions.minScale = .3;
    else zoomOptions.minScale = parseFloat(zoom["minScale"]);
    if (zoom["scaleSpeed"] === undefined) zoomOptions.scaleSpeed = 1.2;
    else zoomOptions.scaleSpeed = parseFloat(zoom["scaleSpeed"]);
    return zoomOptions
};
Blockly.Options.parseGridOptions_ = function(options) {
    var grid = options["grid"] || {};
    var gridOptions = {};
    gridOptions.spacing = parseFloat(grid["spacing"]) || 0;
    gridOptions.colour = grid["colour"] || "#888";
    gridOptions.length = parseFloat(grid["length"]) || 1;
    gridOptions.snap = gridOptions.spacing > 0 && !!grid["snap"];
    return gridOptions
};
Blockly.Options.parseToolboxTree = function(tree) {
    if (tree) {
        if (typeof tree != "string")
            if (typeof XSLTProcessor == "undefined" && tree.outerHTML) tree = tree.outerHTML;
            else if (!(tree instanceof Element)) tree = null;
        if (typeof tree == "string") tree = Blockly.Xml.textToDom(tree)
    } else tree = null;
    return tree
};
goog.provide("Blockly.Procedures");
goog.require("Blockly.Blocks");
goog.require("Blockly.constants");
goog.require("Blockly.Events.BlockChange");
goog.require("Blockly.Field");
goog.require("Blockly.Names");
goog.require("Blockly.Workspace");
goog.require("Blockly.Xml");
goog.require("Blockly.Xml.utils");
Blockly.Procedures.NAME_TYPE = Blockly.PROCEDURE_CATEGORY_NAME;
Blockly.Procedures.allProcedures = function(root) {
    var blocks = root.getAllBlocks(false);
    var proceduresReturn = [];
    var proceduresNoReturn = [];
    for (var i = 0; i < blocks.length; i++)
        if (blocks[i].getProcedureDef) {
            var tuple = blocks[i].getProcedureDef();
            if (tuple)
                if (tuple[2]) proceduresReturn.push(tuple);
                else proceduresNoReturn.push(tuple)
        } proceduresNoReturn.sort(Blockly.Procedures.procTupleComparator_);
    proceduresReturn.sort(Blockly.Procedures.procTupleComparator_);
    return [proceduresNoReturn, proceduresReturn]
};
Blockly.Procedures.procTupleComparator_ = function(ta, tb) {
    return ta[0].toLowerCase().localeCompare(tb[0].toLowerCase())
};
Blockly.Procedures.findLegalName = function(name, block) {
    if (block.isInFlyout) return name;
    while (!Blockly.Procedures.isLegalName_(name, block.workspace, block)) {
        var r = name.match(/^(.*?)(\d+)$/);
        if (!r) name += "2";
        else name = r[1] + (parseInt(r[2], 10) + 1)
    }
    return name
};
Blockly.Procedures.isLegalName_ = function(name, workspace, opt_exclude) {
    return !Blockly.Procedures.isNameUsed(name, workspace, opt_exclude)
};
Blockly.Procedures.isNameUsed = function(name, workspace, opt_exclude) {
    var blocks = workspace.getAllBlocks(false);
    for (var i = 0; i < blocks.length; i++) {
        if (blocks[i] == opt_exclude) continue;
        if (blocks[i].getProcedureDef) {
            var procName = blocks[i].getProcedureDef();
            if (Blockly.Names.equals(procName[0], name)) return true
        }
    }
    return false
};
Blockly.Procedures.rename = function(name) {
    name = name.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
    var legalName = Blockly.Procedures.findLegalName(name, this.sourceBlock_);
    var oldName = this.text_;
    if (oldName != name && oldName != legalName) {
        var blocks = this.sourceBlock_.workspace.getAllBlocks(false);
        for (var i = 0; i < blocks.length; i++)
            if (blocks[i].renameProcedure) blocks[i].renameProcedure(oldName, legalName)
    }
    return legalName
};
Blockly.Procedures.flyoutCategory = function(workspace) {
    var xmlList = [];
    if (Blockly.Blocks["procedures_defnoreturn"]) {
        var block = Blockly.Xml.utils.createElement("block");
        block.setAttribute("type", "procedures_defnoreturn");
        block.setAttribute("gap", 16);
        var nameField = Blockly.Xml.utils.createElement("field");
        nameField.setAttribute("name", "NAME");
        nameField.appendChild(Blockly.Xml.utils.createTextNode(Blockly.Msg["PROCEDURES_DEFNORETURN_PROCEDURE"]));
        block.appendChild(nameField);
        xmlList.push(block)
    }
    if (Blockly.Blocks["procedures_defreturn"]) {
        var block =
            Blockly.Xml.utils.createElement("block");
        block.setAttribute("type", "procedures_defreturn");
        block.setAttribute("gap", 16);
        var nameField = Blockly.Xml.utils.createElement("field");
        nameField.setAttribute("name", "NAME");
        nameField.appendChild(Blockly.Xml.utils.createTextNode(Blockly.Msg["PROCEDURES_DEFRETURN_PROCEDURE"]));
        block.appendChild(nameField);
        xmlList.push(block)
    }
    if (Blockly.Blocks["procedures_ifreturn"]) {
        var block = Blockly.Xml.utils.createElement("block");
        block.setAttribute("type", "procedures_ifreturn");
        block.setAttribute("gap", 16);
        xmlList.push(block)
    }
    if (xmlList.length) xmlList[xmlList.length - 1].setAttribute("gap", 24);

    function populateProcedures(procedureList, templateName) {
        for (var i = 0; i < procedureList.length; i++) {
            var name = procedureList[i][0];
            var args = procedureList[i][1];
            var block = Blockly.Xml.utils.createElement("block");
            block.setAttribute("type", templateName);
            block.setAttribute("gap", 16);
            var mutation = Blockly.Xml.utils.createElement("mutation");
            mutation.setAttribute("name", name);
            block.appendChild(mutation);
            for (var j = 0; j < args.length; j++) {
                var arg = Blockly.Xml.utils.createElement("arg");
                arg.setAttribute("name", args[j]);
                mutation.appendChild(arg)
            }
            xmlList.push(block)
        }
    }
    var tuple = Blockly.Procedures.allProcedures(workspace);
    populateProcedures(tuple[0], "procedures_callnoreturn");
    populateProcedures(tuple[1], "procedures_callreturn");
    return xmlList
};
Blockly.Procedures.getCallers = function(name, workspace) {
    var callers = [];
    var blocks = workspace.getAllBlocks(false);
    for (var i = 0; i < blocks.length; i++)
        if (blocks[i].getProcedureCall) {
            var procName = blocks[i].getProcedureCall();
            if (procName && Blockly.Names.equals(procName, name)) callers.push(blocks[i])
        } return callers
};
Blockly.Procedures.mutateCallers = function(defBlock) {
    var oldRecordUndo = Blockly.Events.recordUndo;
    var name = defBlock.getProcedureDef()[0];
    var xmlElement = defBlock.mutationToDom(true);
    var callers = Blockly.Procedures.getCallers(name, defBlock.workspace);
    for (var i = 0, caller; caller = callers[i]; i++) {
        var oldMutationDom = caller.mutationToDom();
        var oldMutation = oldMutationDom && Blockly.Xml.domToText(oldMutationDom);
        caller.domToMutation(xmlElement);
        var newMutationDom = caller.mutationToDom();
        var newMutation = newMutationDom &&
            Blockly.Xml.domToText(newMutationDom);
        if (oldMutation != newMutation) {
            Blockly.Events.recordUndo = false;
            Blockly.Events.fire(new Blockly.Events.BlockChange(caller, "mutation", null, oldMutation, newMutation));
            Blockly.Events.recordUndo = oldRecordUndo
        }
    }
};
Blockly.Procedures.getDefinition = function(name, workspace) {
    var blocks = workspace.getTopBlocks(false);
    for (var i = 0; i < blocks.length; i++)
        if (blocks[i].getProcedureDef) {
            var tuple = blocks[i].getProcedureDef();
            if (tuple && Blockly.Names.equals(tuple[0], name)) return blocks[i]
        } return null
};
goog.provide("Blockly.RenderedConnection");
goog.require("Blockly.Connection");
goog.require("Blockly.utils");
goog.require("goog.math.Coordinate");
Blockly.RenderedConnection = function(source, type) {
    Blockly.RenderedConnection.superClass_.constructor.call(this, source, type);
    this.offsetInBlock_ = new goog.math.Coordinate(0, 0)
};
goog.inherits(Blockly.RenderedConnection, Blockly.Connection);
Blockly.RenderedConnection.prototype.distanceFrom = function(otherConnection) {
    var xDiff = this.x_ - otherConnection.x_;
    var yDiff = this.y_ - otherConnection.y_;
    return Math.sqrt(xDiff * xDiff + yDiff * yDiff)
};
Blockly.RenderedConnection.prototype.bumpAwayFrom_ = function(staticConnection) {
    if (this.sourceBlock_.workspace.isDragging()) return;
    var rootBlock = this.sourceBlock_.getRootBlock();
    if (rootBlock.isInFlyout) return;
    var reverse = false;
    if (!rootBlock.isMovable()) {
        rootBlock = staticConnection.getSourceBlock().getRootBlock();
        if (!rootBlock.isMovable()) return;
        staticConnection = this;
        reverse = true
    }
    var selected = Blockly.selected == rootBlock;
    selected || rootBlock.addSelect();
    var dx = staticConnection.x_ + Blockly.SNAP_RADIUS - this.x_;
    var dy = staticConnection.y_ + Blockly.SNAP_RADIUS - this.y_;
    if (reverse) dy = -dy;
    if (rootBlock.RTL) dx = -dx;
    rootBlock.moveBy(dx, dy);
    selected || rootBlock.removeSelect()
};
Blockly.RenderedConnection.prototype.moveTo = function(x, y) {
    if (this.inDB_) this.db_.removeConnection_(this);
    this.x_ = x;
    this.y_ = y;
    if (!this.hidden_) this.db_.addConnection(this)
};
Blockly.RenderedConnection.prototype.moveBy = function(dx, dy) {
    this.moveTo(this.x_ + dx, this.y_ + dy)
};
Blockly.RenderedConnection.prototype.moveToOffset = function(blockTL) {
    this.moveTo(blockTL.x + this.offsetInBlock_.x, blockTL.y + this.offsetInBlock_.y)
};
Blockly.RenderedConnection.prototype.setOffsetInBlock = function(x, y) {
    this.offsetInBlock_.x = x;
    this.offsetInBlock_.y = y
};
Blockly.RenderedConnection.prototype.tighten_ = function() {
    var dx = this.targetConnection.x_ - this.x_;
    var dy = this.targetConnection.y_ - this.y_;
    if (dx != 0 || dy != 0) {
        var block = this.targetBlock();
        var svgRoot = block.getSvgRoot();
        if (!svgRoot) throw Error("block is not rendered.");
        var xy = Blockly.utils.getRelativeXY(svgRoot);
        block.getSvgRoot().setAttribute("transform", "translate(" + (xy.x - dx) + "," + (xy.y - dy) + ")");
        block.moveConnections_(-dx, -dy)
    }
};
Blockly.RenderedConnection.prototype.closest = function(maxLimit, dxy) {
    return this.dbOpposite_.searchForClosest(this, maxLimit, dxy)
};
Blockly.RenderedConnection.prototype.highlight = function() {
    var steps;
    if (this.type == Blockly.INPUT_VALUE || this.type == Blockly.OUTPUT_VALUE) steps = "m 0,0 " + Blockly.BlockSvg.TAB_PATH_DOWN + " v 5";
    else steps = "m -20,0 h 5 " + Blockly.BlockSvg.NOTCH_PATH_LEFT + " h 5";
    var xy = this.sourceBlock_.getRelativeToSurfaceXY();
    var x = this.x_ - xy.x;
    var y = this.y_ - xy.y;
    Blockly.Connection.highlightedPath_ = Blockly.utils.createSvgElement("path", {
        "class": "blocklyHighlightedConnectionPath",
        "d": steps,
        transform: "translate(" + x + "," + y +
            ")" + (this.sourceBlock_.RTL ? " scale(-1 1)" : "")
    }, this.sourceBlock_.getSvgRoot())
};
Blockly.RenderedConnection.prototype.unhideAll = function() {
    this.setHidden(false);
    var renderList = [];
    if (this.type != Blockly.INPUT_VALUE && this.type != Blockly.NEXT_STATEMENT) return renderList;
    var block = this.targetBlock();
    if (block) {
        var connections;
        if (block.isCollapsed()) {
            connections = [];
            block.outputConnection && connections.push(block.outputConnection);
            block.nextConnection && connections.push(block.nextConnection);
            block.previousConnection && connections.push(block.previousConnection)
        } else connections = block.getConnections_(true);
        for (var i = 0; i < connections.length; i++) renderList.push.apply(renderList, connections[i].unhideAll());
        if (!renderList.length) renderList[0] = block
    }
    return renderList
};
Blockly.RenderedConnection.prototype.unhighlight = function() {
    Blockly.utils.removeNode(Blockly.Connection.highlightedPath_);
    delete Blockly.Connection.highlightedPath_
};
Blockly.RenderedConnection.prototype.setHidden = function(hidden) {
    this.hidden_ = hidden;
    if (hidden && this.inDB_) this.db_.removeConnection_(this);
    else if (!hidden && !this.inDB_) this.db_.addConnection(this)
};
Blockly.RenderedConnection.prototype.hideAll = function() {
    this.setHidden(true);
    if (this.targetConnection) {
        var blocks = this.targetBlock().getDescendants(false);
        for (var i = 0; i < blocks.length; i++) {
            var block = blocks[i];
            var connections = block.getConnections_(true);
            for (var j = 0; j < connections.length; j++) connections[j].setHidden(true);
            var icons = block.getIcons();
            for (var j = 0; j < icons.length; j++) icons[j].setVisible(false)
        }
    }
};
Blockly.RenderedConnection.prototype.isConnectionAllowed = function(candidate, maxRadius) {
    if (this.distanceFrom(candidate) > maxRadius) return false;
    return Blockly.RenderedConnection.superClass_.isConnectionAllowed.call(this, candidate)
};
Blockly.RenderedConnection.prototype.disconnectInternal_ = function(parentBlock, childBlock) {
    Blockly.RenderedConnection.superClass_.disconnectInternal_.call(this, parentBlock, childBlock);
    if (parentBlock.rendered) parentBlock.render();
    if (childBlock.rendered) {
        childBlock.updateDisabled();
        childBlock.render()
    }
};
Blockly.RenderedConnection.prototype.respawnShadow_ = function() {
    var parentBlock = this.getSourceBlock();
    var shadow = this.getShadowDom();
    if (parentBlock.workspace && shadow && Blockly.Events.recordUndo) {
        Blockly.RenderedConnection.superClass_.respawnShadow_.call(this);
        var blockShadow = this.targetBlock();
        if (!blockShadow) throw Error("Couldn't respawn the shadow block that should exist here.");
        blockShadow.initSvg();
        blockShadow.render(false);
        if (parentBlock.rendered) parentBlock.render()
    }
};
Blockly.RenderedConnection.prototype.neighbours_ = function(maxLimit) {
    return this.dbOpposite_.getNeighbours(this, maxLimit)
};
Blockly.RenderedConnection.prototype.connect_ = function(childConnection) {
    Blockly.RenderedConnection.superClass_.connect_.call(this, childConnection);
    var parentConnection = this;
    var parentBlock = parentConnection.getSourceBlock();
    var childBlock = childConnection.getSourceBlock();
    if (parentBlock.rendered) parentBlock.updateDisabled();
    if (childBlock.rendered) childBlock.updateDisabled();
    if (parentBlock.rendered && childBlock.rendered)
        if (parentConnection.type == Blockly.NEXT_STATEMENT || parentConnection.type == Blockly.PREVIOUS_STATEMENT) childBlock.render();
        else parentBlock.render()
};
Blockly.RenderedConnection.prototype.onCheckChanged_ = function() {
    if (this.isConnected() && !this.checkType_(this.targetConnection)) {
        var child = this.isSuperior() ? this.targetBlock() : this.sourceBlock_;
        child.unplug();
        this.sourceBlock_.bumpNeighbours_()
    }
};
goog.provide("Blockly.Scrollbar");
goog.provide("Blockly.ScrollbarPair");
goog.require("Blockly.utils");
goog.require("goog.events.BrowserFeature");
goog.require("goog.math.Coordinate");
Blockly.ScrollbarPair = function(workspace) {
    this.workspace_ = workspace;
    this.hScroll = new Blockly.Scrollbar(workspace, true, true, "blocklyMainWorkspaceScrollbar");
    this.vScroll = new Blockly.Scrollbar(workspace, false, true, "blocklyMainWorkspaceScrollbar");
    this.corner_ = Blockly.utils.createSvgElement("rect", {
        "height": Blockly.Scrollbar.scrollbarThickness,
        "width": Blockly.Scrollbar.scrollbarThickness,
        "class": "blocklyScrollbarBackground"
    }, null);
    Blockly.utils.insertAfter(this.corner_, workspace.getBubbleCanvas())
};
Blockly.ScrollbarPair.prototype.oldHostMetrics_ = null;
Blockly.ScrollbarPair.prototype.dispose = function() {
    Blockly.utils.removeNode(this.corner_);
    this.corner_ = null;
    this.workspace_ = null;
    this.oldHostMetrics_ = null;
    this.hScroll.dispose();
    this.hScroll = null;
    this.vScroll.dispose();
    this.vScroll = null
};
Blockly.ScrollbarPair.prototype.resize = function() {
    var hostMetrics = this.workspace_.getMetrics();
    if (!hostMetrics) return;
    var resizeH = false;
    var resizeV = false;
    if (!this.oldHostMetrics_ || this.oldHostMetrics_.viewWidth != hostMetrics.viewWidth || this.oldHostMetrics_.viewHeight != hostMetrics.viewHeight || this.oldHostMetrics_.absoluteTop != hostMetrics.absoluteTop || this.oldHostMetrics_.absoluteLeft != hostMetrics.absoluteLeft) {
        resizeH = true;
        resizeV = true
    } else {
        if (!this.oldHostMetrics_ || this.oldHostMetrics_.contentWidth !=
            hostMetrics.contentWidth || this.oldHostMetrics_.viewLeft != hostMetrics.viewLeft || this.oldHostMetrics_.contentLeft != hostMetrics.contentLeft) resizeH = true;
        if (!this.oldHostMetrics_ || this.oldHostMetrics_.contentHeight != hostMetrics.contentHeight || this.oldHostMetrics_.viewTop != hostMetrics.viewTop || this.oldHostMetrics_.contentTop != hostMetrics.contentTop) resizeV = true
    }
    if (resizeH) this.hScroll.resize(hostMetrics);
    if (resizeV) this.vScroll.resize(hostMetrics);
    if (!this.oldHostMetrics_ || this.oldHostMetrics_.viewWidth !=
        hostMetrics.viewWidth || this.oldHostMetrics_.absoluteLeft != hostMetrics.absoluteLeft) this.corner_.setAttribute("x", this.vScroll.position_.x);
    if (!this.oldHostMetrics_ || this.oldHostMetrics_.viewHeight != hostMetrics.viewHeight || this.oldHostMetrics_.absoluteTop != hostMetrics.absoluteTop) this.corner_.setAttribute("y", this.hScroll.position_.y);
    this.oldHostMetrics_ = hostMetrics
};
Blockly.ScrollbarPair.prototype.set = function(x, y) {
    var xyRatio = {};
    var hHandlePosition = x * this.hScroll.ratio_;
    var vHandlePosition = y * this.vScroll.ratio_;
    var hBarLength = this.hScroll.scrollViewSize_;
    var vBarLength = this.vScroll.scrollViewSize_;
    xyRatio.x = this.getRatio_(hHandlePosition, hBarLength);
    xyRatio.y = this.getRatio_(vHandlePosition, vBarLength);
    this.workspace_.setMetrics(xyRatio);
    this.hScroll.setHandlePosition(hHandlePosition);
    this.vScroll.setHandlePosition(vHandlePosition)
};
Blockly.ScrollbarPair.prototype.getRatio_ = function(handlePosition, viewSize) {
    var ratio = handlePosition / viewSize;
    if (isNaN(ratio)) return 0;
    return ratio
};
Blockly.Scrollbar = function(workspace, horizontal, opt_pair, opt_class) {
    this.workspace_ = workspace;
    this.pair_ = opt_pair || false;
    this.horizontal_ = horizontal;
    this.oldHostMetrics_ = null;
    this.createDom_(opt_class);
    this.position_ = new goog.math.Coordinate(0, 0);
    var scrollbarThickness = Blockly.Scrollbar.scrollbarThickness;
    if (horizontal) {
        this.svgBackground_.setAttribute("height", scrollbarThickness);
        this.outerSvg_.setAttribute("height", scrollbarThickness);
        this.svgHandle_.setAttribute("height", scrollbarThickness - 5);
        this.svgHandle_.setAttribute("y", 2.5);
        this.lengthAttribute_ = "width";
        this.positionAttribute_ = "x"
    } else {
        this.svgBackground_.setAttribute("width", scrollbarThickness);
        this.outerSvg_.setAttribute("width", scrollbarThickness);
        this.svgHandle_.setAttribute("width", scrollbarThickness - 5);
        this.svgHandle_.setAttribute("x", 2.5);
        this.lengthAttribute_ = "height";
        this.positionAttribute_ = "y"
    }
    var scrollbar = this;
    this.onMouseDownBarWrapper_ = Blockly.bindEventWithChecks_(this.svgBackground_, "mousedown", scrollbar, scrollbar.onMouseDownBar_);
    this.onMouseDownHandleWrapper_ = Blockly.bindEventWithChecks_(this.svgHandle_, "mousedown", scrollbar, scrollbar.onMouseDownHandle_)
};
Blockly.Scrollbar.prototype.origin_ = new goog.math.Coordinate(0, 0);
Blockly.Scrollbar.prototype.startDragMouse_ = 0;
Blockly.Scrollbar.prototype.scrollViewSize_ = 0;
Blockly.Scrollbar.prototype.handleLength_ = 0;
Blockly.Scrollbar.prototype.handlePosition_ = 0;
Blockly.Scrollbar.prototype.isVisible_ = true;
Blockly.Scrollbar.prototype.containerVisible_ = true;
Blockly.Scrollbar.scrollbarThickness = 15;
if (goog.events.BrowserFeature.TOUCH_ENABLED) Blockly.Scrollbar.scrollbarThickness = 25;
Blockly.Scrollbar.metricsAreEquivalent_ = function(first, second) {
    if (!(first && second)) return false;
    if (first.viewWidth != second.viewWidth || first.viewHeight != second.viewHeight || first.viewLeft != second.viewLeft || first.viewTop != second.viewTop || first.absoluteTop != second.absoluteTop || first.absoluteLeft != second.absoluteLeft || first.contentWidth != second.contentWidth || first.contentHeight != second.contentHeight || first.contentLeft != second.contentLeft || first.contentTop != second.contentTop) return false;
    return true
};
Blockly.Scrollbar.prototype.dispose = function() {
    this.cleanUp_();
    Blockly.unbindEvent_(this.onMouseDownBarWrapper_);
    this.onMouseDownBarWrapper_ = null;
    Blockly.unbindEvent_(this.onMouseDownHandleWrapper_);
    this.onMouseDownHandleWrapper_ = null;
    Blockly.utils.removeNode(this.outerSvg_);
    this.outerSvg_ = null;
    this.svgGroup_ = null;
    this.svgBackground_ = null;
    this.svgHandle_ = null;
    this.workspace_ = null
};
Blockly.Scrollbar.prototype.setHandleLength_ = function(newLength) {
    this.handleLength_ = newLength;
    this.svgHandle_.setAttribute(this.lengthAttribute_, this.handleLength_)
};
Blockly.Scrollbar.prototype.setHandlePosition = function(newPosition) {
    this.handlePosition_ = newPosition;
    this.svgHandle_.setAttribute(this.positionAttribute_, this.handlePosition_)
};
Blockly.Scrollbar.prototype.setScrollViewSize_ = function(newSize) {
    this.scrollViewSize_ = newSize;
    this.outerSvg_.setAttribute(this.lengthAttribute_, this.scrollViewSize_);
    this.svgBackground_.setAttribute(this.lengthAttribute_, this.scrollViewSize_)
};
Blockly.ScrollbarPair.prototype.setContainerVisible = function(visible) {
    this.hScroll.setContainerVisible(visible);
    this.vScroll.setContainerVisible(visible)
};
Blockly.Scrollbar.prototype.setPosition_ = function(x, y) {
    this.position_.x = x;
    this.position_.y = y;
    var tempX = this.position_.x + this.origin_.x;
    var tempY = this.position_.y + this.origin_.y;
    var transform = "translate(" + tempX + "px," + tempY + "px)";
    Blockly.utils.setCssTransform(this.outerSvg_, transform)
};
Blockly.Scrollbar.prototype.resize = function(opt_metrics) {
    var hostMetrics = opt_metrics;
    if (!hostMetrics) {
        hostMetrics = this.workspace_.getMetrics();
        if (!hostMetrics) return
    }
    if (Blockly.Scrollbar.metricsAreEquivalent_(hostMetrics, this.oldHostMetrics_)) return;
    this.oldHostMetrics_ = hostMetrics;
    if (this.horizontal_) this.resizeHorizontal_(hostMetrics);
    else this.resizeVertical_(hostMetrics);
    this.onScroll_()
};
Blockly.Scrollbar.prototype.resizeHorizontal_ = function(hostMetrics) {
    this.resizeViewHorizontal(hostMetrics)
};
Blockly.Scrollbar.prototype.resizeViewHorizontal = function(hostMetrics) {
    var viewSize = hostMetrics.viewWidth - 1;
    if (this.pair_) viewSize -= Blockly.Scrollbar.scrollbarThickness;
    this.setScrollViewSize_(Math.max(0, viewSize));
    var xCoordinate = hostMetrics.absoluteLeft + .5;
    if (this.pair_ && this.workspace_.RTL) xCoordinate += Blockly.Scrollbar.scrollbarThickness;
    var yCoordinate = hostMetrics.absoluteTop + hostMetrics.viewHeight - Blockly.Scrollbar.scrollbarThickness - .5;
    this.setPosition_(xCoordinate, yCoordinate);
    this.resizeContentHorizontal(hostMetrics)
};
Blockly.Scrollbar.prototype.resizeContentHorizontal = function(hostMetrics) {
    if (!this.pair_) this.setVisible(this.scrollViewSize_ < hostMetrics.contentWidth);
    this.ratio_ = this.scrollViewSize_ / hostMetrics.contentWidth;
    if (this.ratio_ == -Infinity || this.ratio_ == Infinity || isNaN(this.ratio_)) this.ratio_ = 0;
    var handleLength = hostMetrics.viewWidth * this.ratio_;
    this.setHandleLength_(Math.max(0, handleLength));
    var handlePosition = (hostMetrics.viewLeft - hostMetrics.contentLeft) * this.ratio_;
    this.setHandlePosition(this.constrainHandle_(handlePosition))
};
Blockly.Scrollbar.prototype.resizeVertical_ = function(hostMetrics) {
    this.resizeViewVertical(hostMetrics)
};
Blockly.Scrollbar.prototype.resizeViewVertical = function(hostMetrics) {
    var viewSize = hostMetrics.viewHeight - 1;
    if (this.pair_) viewSize -= Blockly.Scrollbar.scrollbarThickness;
    this.setScrollViewSize_(Math.max(0, viewSize));
    var xCoordinate = hostMetrics.absoluteLeft + .5;
    if (!this.workspace_.RTL) xCoordinate += hostMetrics.viewWidth - Blockly.Scrollbar.scrollbarThickness - 1;
    var yCoordinate = hostMetrics.absoluteTop + .5;
    this.setPosition_(xCoordinate, yCoordinate);
    this.resizeContentVertical(hostMetrics)
};
Blockly.Scrollbar.prototype.resizeContentVertical = function(hostMetrics) {
    if (!this.pair_) this.setVisible(this.scrollViewSize_ < hostMetrics.contentHeight);
    this.ratio_ = this.scrollViewSize_ / hostMetrics.contentHeight;
    if (this.ratio_ == -Infinity || this.ratio_ == Infinity || isNaN(this.ratio_)) this.ratio_ = 0;
    var handleLength = hostMetrics.viewHeight * this.ratio_;
    this.setHandleLength_(Math.max(0, handleLength));
    var handlePosition = (hostMetrics.viewTop - hostMetrics.contentTop) * this.ratio_;
    this.setHandlePosition(this.constrainHandle_(handlePosition))
};
Blockly.Scrollbar.prototype.createDom_ = function(opt_class) {
    var className = "blocklyScrollbar" + (this.horizontal_ ? "Horizontal" : "Vertical");
    if (opt_class) className += " " + opt_class;
    this.outerSvg_ = Blockly.utils.createSvgElement("svg", {
        "class": className
    }, null);
    this.svgGroup_ = Blockly.utils.createSvgElement("g", {}, this.outerSvg_);
    this.svgBackground_ = Blockly.utils.createSvgElement("rect", {
        "class": "blocklyScrollbarBackground"
    }, this.svgGroup_);
    var radius = Math.floor((Blockly.Scrollbar.scrollbarThickness - 5) / 2);
    this.svgHandle_ =
        Blockly.utils.createSvgElement("rect", {
            "class": "blocklyScrollbarHandle",
            "rx": radius,
            "ry": radius
        }, this.svgGroup_);
    Blockly.utils.insertAfter(this.outerSvg_, this.workspace_.getParentSvg())
};
Blockly.Scrollbar.prototype.isVisible = function() {
    return this.isVisible_
};
Blockly.Scrollbar.prototype.setContainerVisible = function(visible) {
    var visibilityChanged = visible != this.containerVisible_;
    this.containerVisible_ = visible;
    if (visibilityChanged) this.updateDisplay_()
};
Blockly.Scrollbar.prototype.setVisible = function(visible) {
    var visibilityChanged = visible != this.isVisible();
    if (this.pair_) throw Error("Unable to toggle visibility of paired scrollbars.");
    this.isVisible_ = visible;
    if (visibilityChanged) this.updateDisplay_()
};
Blockly.Scrollbar.prototype.updateDisplay_ = function() {
    var show = true;
    if (!this.containerVisible_) show = false;
    else show = this.isVisible();
    if (show) this.outerSvg_.setAttribute("display", "block");
    else this.outerSvg_.setAttribute("display", "none")
};
Blockly.Scrollbar.prototype.onMouseDownBar_ = function(e) {
    this.workspace_.markFocused();
    Blockly.Touch.clearTouchIdentifier();
    this.cleanUp_();
    if (Blockly.utils.isRightButton(e)) {
        e.stopPropagation();
        return
    }
    var mouseXY = Blockly.utils.mouseToSvg(e, this.workspace_.getParentSvg(), this.workspace_.getInverseScreenCTM());
    var mouseLocation = this.horizontal_ ? mouseXY.x : mouseXY.y;
    var handleXY = Blockly.utils.getInjectionDivXY_(this.svgHandle_);
    var handleStart = this.horizontal_ ? handleXY.x : handleXY.y;
    var handlePosition =
        this.handlePosition_;
    var pageLength = this.handleLength_ * .95;
    if (mouseLocation <= handleStart) handlePosition -= pageLength;
    else if (mouseLocation >= handleStart + this.handleLength_) handlePosition += pageLength;
    this.setHandlePosition(this.constrainHandle_(handlePosition));
    this.onScroll_();
    e.stopPropagation();
    e.preventDefault()
};
Blockly.Scrollbar.prototype.onMouseDownHandle_ = function(e) {
    this.workspace_.markFocused();
    this.cleanUp_();
    if (Blockly.utils.isRightButton(e)) {
        e.stopPropagation();
        return
    }
    this.startDragHandle = this.handlePosition_;
    this.workspace_.setupDragSurface();
    this.startDragMouse_ = this.horizontal_ ? e.clientX : e.clientY;
    Blockly.Scrollbar.onMouseUpWrapper_ = Blockly.bindEventWithChecks_(document, "mouseup", this, this.onMouseUpHandle_);
    Blockly.Scrollbar.onMouseMoveWrapper_ = Blockly.bindEventWithChecks_(document, "mousemove",
        this, this.onMouseMoveHandle_);
    e.stopPropagation();
    e.preventDefault()
};
Blockly.Scrollbar.prototype.onMouseMoveHandle_ = function(e) {
    var currentMouse = this.horizontal_ ? e.clientX : e.clientY;
    var mouseDelta = currentMouse - this.startDragMouse_;
    var handlePosition = this.startDragHandle + mouseDelta;
    this.setHandlePosition(this.constrainHandle_(handlePosition));
    this.onScroll_()
};
Blockly.Scrollbar.prototype.onMouseUpHandle_ = function() {
    this.workspace_.resetDragSurface();
    Blockly.Touch.clearTouchIdentifier();
    this.cleanUp_()
};
Blockly.Scrollbar.prototype.cleanUp_ = function() {
    Blockly.hideChaff(true);
    if (Blockly.Scrollbar.onMouseUpWrapper_) {
        Blockly.unbindEvent_(Blockly.Scrollbar.onMouseUpWrapper_);
        Blockly.Scrollbar.onMouseUpWrapper_ = null
    }
    if (Blockly.Scrollbar.onMouseMoveWrapper_) {
        Blockly.unbindEvent_(Blockly.Scrollbar.onMouseMoveWrapper_);
        Blockly.Scrollbar.onMouseMoveWrapper_ = null
    }
};
Blockly.Scrollbar.prototype.constrainHandle_ = function(value) {
    if (value <= 0 || isNaN(value) || this.scrollViewSize_ < this.handleLength_) value = 0;
    else value = Math.min(value, this.scrollViewSize_ - this.handleLength_);
    return value
};
Blockly.Scrollbar.prototype.onScroll_ = function() {
    var ratio = this.handlePosition_ / this.scrollViewSize_;
    if (isNaN(ratio)) ratio = 0;
    var xyRatio = {};
    if (this.horizontal_) xyRatio.x = ratio;
    else xyRatio.y = ratio;
    this.workspace_.setMetrics(xyRatio)
};
Blockly.Scrollbar.prototype.set = function(value) {
    this.setHandlePosition(this.constrainHandle_(value * this.ratio_));
    this.onScroll_()
};
Blockly.Scrollbar.prototype.setOrigin = function(x, y) {
    this.origin_ = new goog.math.Coordinate(x, y)
};
goog.provide("Blockly.Toolbox");
goog.require("Blockly.Events.Ui");
goog.require("Blockly.Flyout");
goog.require("Blockly.HorizontalFlyout");
goog.require("Blockly.Touch");
goog.require("Blockly.utils");
goog.require("Blockly.VerticalFlyout");
goog.require("goog.events");
goog.require("goog.events.BrowserFeature");
goog.require("goog.html.SafeHtml");
goog.require("goog.html.SafeStyle");
goog.require("goog.math.Rect");
goog.require("goog.style");
goog.require("goog.ui.tree.TreeControl");
goog.require("goog.ui.tree.TreeNode");
Blockly.Toolbox = function(workspace) {
    this.workspace_ = workspace;
    this.RTL = workspace.options.RTL;
    this.horizontalLayout_ = workspace.options.horizontalLayout;
    this.toolboxPosition = workspace.options.toolboxPosition;
    this.config_ = {
        indentWidth: 19,
        cssRoot: "blocklyTreeRoot",
        cssHideRoot: "blocklyHidden",
        cssItem: "",
        cssTreeRow: "blocklyTreeRow",
        cssItemLabel: "blocklyTreeLabel",
        cssTreeIcon: "blocklyTreeIcon",
        cssExpandedFolderIcon: "blocklyTreeIconOpen",
        cssFileIcon: "blocklyTreeIconNone",
        cssSelectedRow: "blocklyTreeSelected"
    };
    this.treeSeparatorConfig_ = {
        cssTreeRow: "blocklyTreeSeparator"
    };
    if (this.horizontalLayout_) {
        this.config_["cssTreeRow"] = this.config_["cssTreeRow"] + (workspace.RTL ? " blocklyHorizontalTreeRtl" : " blocklyHorizontalTree");
        this.treeSeparatorConfig_["cssTreeRow"] = "blocklyTreeSeparatorHorizontal " + (workspace.RTL ? "blocklyHorizontalTreeRtl" : "blocklyHorizontalTree");
        this.config_["cssTreeIcon"] = ""
    }
};
Blockly.Toolbox.prototype.width = 0;
Blockly.Toolbox.prototype.height = 0;
Blockly.Toolbox.prototype.selectedOption_ = null;
Blockly.Toolbox.prototype.lastCategory_ = null;
Blockly.Toolbox.prototype.init = function() {
    var workspace = this.workspace_;
    var svg = this.workspace_.getParentSvg();
    this.HtmlDiv = document.createElement("div");
    this.HtmlDiv.className = "blocklyToolboxDiv";
    this.HtmlDiv.setAttribute("dir", workspace.RTL ? "RTL" : "LTR");
    svg.parentNode.insertBefore(this.HtmlDiv, svg);
    Blockly.bindEventWithChecks_(this.HtmlDiv, "mousedown", this, function(e) {
            if (Blockly.utils.isRightButton(e) || e.target == this.HtmlDiv) Blockly.hideChaff(false);
            else Blockly.hideChaff(true);
            Blockly.Touch.clearTouchIdentifier()
        },
        false, true);
    var workspaceOptions = {
        disabledPatternId: workspace.options.disabledPatternId,
        parentWorkspace: workspace,
        RTL: workspace.RTL,
        oneBasedIndex: workspace.options.oneBasedIndex,
        horizontalLayout: workspace.horizontalLayout,
        toolboxPosition: workspace.options.toolboxPosition
    };
    this.flyout_ = null;
    if (workspace.horizontalLayout) this.flyout_ = new Blockly.HorizontalFlyout(workspaceOptions);
    else this.flyout_ = new Blockly.VerticalFlyout(workspaceOptions);
    Blockly.utils.insertAfter(this.flyout_.createDom("svg"), this.workspace_.getParentSvg());
    this.flyout_.init(workspace);
    this.config_["cleardotPath"] = workspace.options.pathToMedia + "1x1.gif";
    this.config_["cssCollapsedFolderIcon"] = "blocklyTreeIconClosed" + (workspace.RTL ? "Rtl" : "Ltr");
    var tree = new Blockly.Toolbox.TreeControl(this, this.config_);
    this.tree_ = tree;
    tree.setShowRootNode(false);
    tree.setShowLines(false);
    tree.setShowExpandIcons(false);
    tree.setSelectedItem(null);
    var openNode = this.populate_(workspace.options.languageTree);
    tree.render(this.HtmlDiv);
    if (openNode) tree.setSelectedItem(openNode);
    this.addColour_();
    this.position()
};
Blockly.Toolbox.prototype.dispose = function() {
    this.flyout_.dispose();
    this.tree_.dispose();
    Blockly.utils.removeNode(this.HtmlDiv);
    this.workspace_ = null;
    this.lastCategory_ = null
};
Blockly.Toolbox.prototype.getWidth = function() {
    return this.width
};
Blockly.Toolbox.prototype.getHeight = function() {
    return this.height
};
Blockly.Toolbox.prototype.position = function() {
    var treeDiv = this.HtmlDiv;
    if (!treeDiv) return;
    var svg = this.workspace_.getParentSvg();
    var svgSize = Blockly.svgSize(svg);
    if (this.horizontalLayout_) {
        treeDiv.style.left = "0";
        treeDiv.style.height = "auto";
        treeDiv.style.width = svgSize.width + "px";
        this.height = treeDiv.offsetHeight;
        if (this.toolboxPosition == Blockly.TOOLBOX_AT_TOP) treeDiv.style.top = "0";
        else treeDiv.style.bottom = "0"
    } else {
        if (this.toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) treeDiv.style.right = "0";
        else treeDiv.style.left =
            "0";
        treeDiv.style.height = svgSize.height + "px";
        this.width = treeDiv.offsetWidth
    }
    this.flyout_.position()
};
Blockly.Toolbox.prototype.populate_ = function(newTree) {
    this.tree_.removeChildren();
    this.tree_.blocks = [];
    this.hasColours_ = false;
    var openNode = this.syncTrees_(newTree, this.tree_, this.workspace_.options.pathToMedia);
    if (this.tree_.blocks.length) throw Error("Toolbox cannot have both blocks and categories " + "in the root level.");
    this.workspace_.resizeContents();
    return openNode
};
Blockly.Toolbox.prototype.syncTrees_ = function(treeIn, treeOut, pathToMedia) {
    var openNode = null;
    var lastElement = null;
    for (var i = 0, childIn; childIn = treeIn.childNodes[i]; i++) {
        if (!childIn.tagName) continue;
        switch (childIn.tagName.toUpperCase()) {
            case "CATEGORY":
                var categoryName = Blockly.utils.replaceMessageReferences(childIn.getAttribute("name"));
                var childOut = this.tree_.createNode(categoryName);
                childOut.blocks = [];
                treeOut.add(childOut);
                var custom = childIn.getAttribute("custom");
                if (custom) childOut.blocks = custom;
                else {
                    var newOpenNode = this.syncTrees_(childIn, childOut, pathToMedia);
                    if (newOpenNode) openNode = newOpenNode
                }
                var colour = Blockly.utils.replaceMessageReferences(childIn.getAttribute("colour"));
                if (colour === null || colour === "") childOut.hexColour = "";
                else if (/^#[0-9a-fA-F]{6}$/.test(colour)) {
                    childOut.hexColour = colour;
                    this.hasColours_ = true
                } else if (typeof colour === "number" || typeof colour === "string" && !isNaN(Number(colour))) {
                    childOut.hexColour = Blockly.hueToRgb(Number(colour));
                    this.hasColours_ = true
                } else {
                    childOut.hexColour =
                        "";
                    console.warn('Toolbox category "' + categoryName + '" has unrecognized colour attribute: ' + colour)
                }
                if (childIn.getAttribute("expanded") == "true") {
                    if (childOut.blocks.length) openNode = childOut;
                    childOut.setExpanded(true)
                } else childOut.setExpanded(false);
                lastElement = childIn;
                break;
            case "SEP":
                if (lastElement)
                    if (lastElement.tagName.toUpperCase() == "CATEGORY") treeOut.add(new Blockly.Toolbox.TreeSeparator(this.treeSeparatorConfig_));
                    else {
                        var newGap = parseFloat(childIn.getAttribute("gap"));
                        if (!isNaN(newGap) && lastElement) lastElement.setAttribute("gap",
                            newGap)
                    } break;
            case "BLOCK":
            case "SHADOW":
            case "LABEL":
            case "BUTTON":
                treeOut.blocks.push(childIn);
                lastElement = childIn;
                break
        }
    }
    return openNode
};
Blockly.Toolbox.prototype.addColour_ = function(opt_tree) {
    var tree = opt_tree || this.tree_;
    var children = tree.getChildren(false);
    for (var i = 0, child; child = children[i]; i++) {
        var element = child.getRowElement();
        if (element) {
            if (this.hasColours_) var border = "8px solid " + (child.hexColour || "#ddd");
            else var border = "none";
            if (this.workspace_.RTL) element.style.borderRight = border;
            else element.style.borderLeft = border
        }
        this.addColour_(child)
    }
};
Blockly.Toolbox.prototype.clearSelection = function() {
    this.tree_.setSelectedItem(null)
};
Blockly.Toolbox.prototype.addStyle = function(style) {
    Blockly.utils.addClass(this.HtmlDiv, style)
};
Blockly.Toolbox.prototype.removeStyle = function(style) {
    Blockly.utils.removeClass(this.HtmlDiv, style)
};
Blockly.Toolbox.prototype.getClientRect = function() {
    if (!this.HtmlDiv) return null;
    var BIG_NUM = 1E7;
    var toolboxRect = this.HtmlDiv.getBoundingClientRect();
    var x = toolboxRect.left;
    var y = toolboxRect.top;
    var width = toolboxRect.width;
    var height = toolboxRect.height;
    if (this.toolboxPosition == Blockly.TOOLBOX_AT_LEFT) return new goog.math.Rect(-BIG_NUM, -BIG_NUM, BIG_NUM + x + width, 2 * BIG_NUM);
    else if (this.toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) return new goog.math.Rect(x, -BIG_NUM, BIG_NUM + width, 2 * BIG_NUM);
    else if (this.toolboxPosition ==
        Blockly.TOOLBOX_AT_TOP) return new goog.math.Rect(-BIG_NUM, -BIG_NUM, 2 * BIG_NUM, BIG_NUM + y + height);
    else return new goog.math.Rect(0, y, 2 * BIG_NUM, BIG_NUM + width)
};
Blockly.Toolbox.prototype.refreshSelection = function() {
    var selectedItem = this.tree_.getSelectedItem();
    if (selectedItem && selectedItem.blocks) this.flyout_.show(selectedItem.blocks)
};
Blockly.Toolbox.TreeControl = function(toolbox, config) {
    this.toolbox_ = toolbox;
    goog.ui.tree.TreeControl.call(this, goog.html.SafeHtml.EMPTY, config)
};
goog.inherits(Blockly.Toolbox.TreeControl, goog.ui.tree.TreeControl);
Blockly.Toolbox.TreeControl.prototype.enterDocument = function() {
    Blockly.Toolbox.TreeControl.superClass_.enterDocument.call(this);
    if (goog.events.BrowserFeature.TOUCH_ENABLED) {
        var el = this.getElement();
        Blockly.bindEventWithChecks_(el, goog.events.EventType.TOUCHEND, this, this.handleTouchEvent_)
    }
};
Blockly.Toolbox.TreeControl.prototype.handleTouchEvent_ = function(e) {
    var node = this.getNodeFromEvent_(e);
    if (node && e.type === goog.events.EventType.TOUCHEND) setTimeout(function() {
        node.onClick_(e)
    }, 1)
};
Blockly.Toolbox.TreeControl.prototype.createNode = function(opt_html) {
    var html = opt_html ? goog.html.SafeHtml.htmlEscape(opt_html) : goog.html.SafeHtml.EMPTY;
    return new Blockly.Toolbox.TreeNode(this.toolbox_, html, this.getConfig(), this.getDomHelper())
};
Blockly.Toolbox.TreeControl.prototype.setSelectedItem = function(node) {
    var toolbox = this.toolbox_;
    if (node == this.selectedItem_ || node == toolbox.tree_) return;
    if (toolbox.lastCategory_) toolbox.lastCategory_.getRowElement().style.backgroundColor = "";
    if (node) {
        var hexColour = node.hexColour || "#57e";
        node.getRowElement().style.backgroundColor = hexColour;
        toolbox.addColour_(node)
    }
    var oldNode = this.getSelectedItem();
    goog.ui.tree.TreeControl.prototype.setSelectedItem.call(this, node);
    if (node && node.blocks && node.blocks.length) {
        toolbox.flyout_.show(node.blocks);
        if (toolbox.lastCategory_ != node) toolbox.flyout_.scrollToStart()
    } else toolbox.flyout_.hide();
    if (oldNode != node && oldNode != this) {
        var event = new Blockly.Events.Ui(null, "category", oldNode && oldNode.getHtml(), node && node.getHtml());
        event.workspaceId = toolbox.workspace_.id;
        Blockly.Events.fire(event)
    }
    if (node) toolbox.lastCategory_ = node
};
Blockly.Toolbox.TreeNode = function(toolbox, html, opt_config, opt_domHelper) {
    goog.ui.tree.TreeNode.call(this, html, opt_config, opt_domHelper);
    if (toolbox) {
        var resize = function() {
            Blockly.svgResize(toolbox.workspace_)
        };
        goog.events.listen(toolbox.tree_, goog.ui.tree.BaseNode.EventType.EXPAND, resize);
        goog.events.listen(toolbox.tree_, goog.ui.tree.BaseNode.EventType.COLLAPSE, resize)
    }
};
goog.inherits(Blockly.Toolbox.TreeNode, goog.ui.tree.TreeNode);
Blockly.Toolbox.TreeNode.prototype.getExpandIconSafeHtml = function() {
    return goog.html.SafeHtml.create("span")
};
Blockly.Toolbox.TreeNode.prototype.onClick_ = function(_e) {
    if (this.hasChildren() && this.isUserCollapsible_) {
        this.toggle();
        this.select()
    } else if (this.isSelected()) this.getTree().setSelectedItem(null);
    else this.select();
    this.updateRow()
};
Blockly.Toolbox.TreeNode.prototype.onMouseDown = function(_e) {};
Blockly.Toolbox.TreeNode.prototype.onDoubleClick_ = function(_e) {};
Blockly.Toolbox.TreeNode.prototype.onKeyDown = function(e) {
    if (this.tree.toolbox_.horizontalLayout_) {
        var map = {};
        var next = goog.events.KeyCodes.DOWN;
        var prev = goog.events.KeyCodes.UP;
        map[goog.events.KeyCodes.RIGHT] = this.rightToLeft_ ? prev : next;
        map[goog.events.KeyCodes.LEFT] = this.rightToLeft_ ? next : prev;
        map[goog.events.KeyCodes.UP] = goog.events.KeyCodes.LEFT;
        map[goog.events.KeyCodes.DOWN] = goog.events.KeyCodes.RIGHT;
        var newKeyCode = map[e.keyCode];
        e.keyCode = newKeyCode || e.keyCode
    }
    return Blockly.Toolbox.TreeNode.superClass_.onKeyDown.call(this,
        e)
};
Blockly.Toolbox.TreeSeparator = function(config) {
    Blockly.Toolbox.TreeNode.call(this, null, goog.html.SafeHtml.EMPTY, config)
};
goog.inherits(Blockly.Toolbox.TreeSeparator, Blockly.Toolbox.TreeNode);
goog.provide("Blockly.Tooltip");
goog.require("Blockly.utils");
goog.require("goog.dom");
Blockly.Tooltip.visible = false;
Blockly.Tooltip.blocked_ = false;
Blockly.Tooltip.LIMIT = 50;
Blockly.Tooltip.mouseOutPid_ = 0;
Blockly.Tooltip.showPid_ = 0;
Blockly.Tooltip.lastX_ = 0;
Blockly.Tooltip.lastY_ = 0;
Blockly.Tooltip.element_ = null;
Blockly.Tooltip.poisonedElement_ = null;
Blockly.Tooltip.OFFSET_X = 0;
Blockly.Tooltip.OFFSET_Y = 10;
Blockly.Tooltip.RADIUS_OK = 10;
Blockly.Tooltip.HOVER_MS = 750;
Blockly.Tooltip.MARGINS = 5;
Blockly.Tooltip.DIV = null;
Blockly.Tooltip.createDom = function() {
    if (Blockly.Tooltip.DIV) return;
    Blockly.Tooltip.DIV = document.createElement("div");
    Blockly.Tooltip.DIV.className = "blocklyTooltipDiv";
    document.body.appendChild(Blockly.Tooltip.DIV)
};
Blockly.Tooltip.bindMouseEvents = function(element) {
    Blockly.bindEvent_(element, "mouseover", null, Blockly.Tooltip.onMouseOver_);
    Blockly.bindEvent_(element, "mouseout", null, Blockly.Tooltip.onMouseOut_);
    element.addEventListener("mousemove", Blockly.Tooltip.onMouseMove_, false)
};
Blockly.Tooltip.onMouseOver_ = function(e) {
    if (Blockly.Tooltip.blocked_) return;
    var element = e.target;
    while (typeof element.tooltip != "string" && typeof element.tooltip != "function") element = element.tooltip;
    if (Blockly.Tooltip.element_ != element) {
        Blockly.Tooltip.hide();
        Blockly.Tooltip.poisonedElement_ = null;
        Blockly.Tooltip.element_ = element
    }
    clearTimeout(Blockly.Tooltip.mouseOutPid_)
};
Blockly.Tooltip.onMouseOut_ = function(_e) {
    if (Blockly.Tooltip.blocked_) return;
    Blockly.Tooltip.mouseOutPid_ = setTimeout(function() {
        Blockly.Tooltip.element_ = null;
        Blockly.Tooltip.poisonedElement_ = null;
        Blockly.Tooltip.hide()
    }, 1);
    clearTimeout(Blockly.Tooltip.showPid_)
};
Blockly.Tooltip.onMouseMove_ = function(e) {
    if (!Blockly.Tooltip.element_ || !Blockly.Tooltip.element_.tooltip) return;
    else if (Blockly.WidgetDiv.isVisible()) return;
    else if (Blockly.Tooltip.blocked_) return;
    if (Blockly.Tooltip.visible) {
        var dx = Blockly.Tooltip.lastX_ - e.pageX;
        var dy = Blockly.Tooltip.lastY_ - e.pageY;
        if (Math.sqrt(dx * dx + dy * dy) > Blockly.Tooltip.RADIUS_OK) Blockly.Tooltip.hide()
    } else if (Blockly.Tooltip.poisonedElement_ != Blockly.Tooltip.element_) {
        clearTimeout(Blockly.Tooltip.showPid_);
        Blockly.Tooltip.lastX_ =
            e.pageX;
        Blockly.Tooltip.lastY_ = e.pageY;
        Blockly.Tooltip.showPid_ = setTimeout(Blockly.Tooltip.show_, Blockly.Tooltip.HOVER_MS)
    }
};
Blockly.Tooltip.hide = function() {
    if (Blockly.Tooltip.visible) {
        Blockly.Tooltip.visible = false;
        if (Blockly.Tooltip.DIV) Blockly.Tooltip.DIV.style.display = "none"
    }
    if (Blockly.Tooltip.showPid_) clearTimeout(Blockly.Tooltip.showPid_)
};
Blockly.Tooltip.block = function() {
    Blockly.Tooltip.hide();
    Blockly.Tooltip.blocked_ = true
};
Blockly.Tooltip.unblock = function() {
    Blockly.Tooltip.blocked_ = false
};
Blockly.Tooltip.show_ = function() {
    if (Blockly.Tooltip.blocked_) return;
    Blockly.Tooltip.poisonedElement_ = Blockly.Tooltip.element_;
    if (!Blockly.Tooltip.DIV) return;
    Blockly.Tooltip.DIV.innerHTML = "";
    var tip = Blockly.Tooltip.element_.tooltip;
    while (typeof tip == "function") tip = tip();
    tip = Blockly.utils.wrap(tip, Blockly.Tooltip.LIMIT);
    var lines = tip.split("\n");
    for (var i = 0; i < lines.length; i++) {
        var div = document.createElement("div");
        div.appendChild(document.createTextNode(lines[i]));
        Blockly.Tooltip.DIV.appendChild(div)
    }
    var rtl =
        Blockly.Tooltip.element_.RTL;
    var windowSize = goog.dom.getViewportSize();
    Blockly.Tooltip.DIV.style.direction = rtl ? "rtl" : "ltr";
    Blockly.Tooltip.DIV.style.display = "block";
    Blockly.Tooltip.visible = true;
    var anchorX = Blockly.Tooltip.lastX_;
    if (rtl) anchorX -= Blockly.Tooltip.OFFSET_X + Blockly.Tooltip.DIV.offsetWidth;
    else anchorX += Blockly.Tooltip.OFFSET_X;
    var anchorY = Blockly.Tooltip.lastY_ + Blockly.Tooltip.OFFSET_Y;
    if (anchorY + Blockly.Tooltip.DIV.offsetHeight > windowSize.height + window.scrollY) anchorY -= Blockly.Tooltip.DIV.offsetHeight +
        2 * Blockly.Tooltip.OFFSET_Y;
    if (rtl) anchorX = Math.max(Blockly.Tooltip.MARGINS - window.scrollX, anchorX);
    else if (anchorX + Blockly.Tooltip.DIV.offsetWidth > windowSize.width + window.scrollX - 2 * Blockly.Tooltip.MARGINS) anchorX = windowSize.width - Blockly.Tooltip.DIV.offsetWidth - 2 * Blockly.Tooltip.MARGINS;
    Blockly.Tooltip.DIV.style.top = anchorY + "px";
    Blockly.Tooltip.DIV.style.left = anchorX + "px"
};
goog.provide("Blockly.Touch");
goog.require("Blockly.utils");
goog.require("goog.events.BrowserFeature");
Blockly.Touch.touchIdentifier_ = null;
Blockly.Touch.TOUCH_MAP = {};
if (goog.global.PointerEvent) Blockly.Touch.TOUCH_MAP = {
    "mousedown": ["pointerdown"],
    "mouseenter": ["pointerenter"],
    "mouseleave": ["pointerleave"],
    "mousemove": ["pointermove"],
    "mouseout": ["pointerout"],
    "mouseover": ["pointerover"],
    "mouseup": ["pointerup", "pointercancel"],
    "touchend": ["pointerup"],
    "touchcancel": ["pointercancel"]
};
else if (goog.events.BrowserFeature.TOUCH_ENABLED) Blockly.Touch.TOUCH_MAP = {
    "mousedown": ["touchstart"],
    "mousemove": ["touchmove"],
    "mouseup": ["touchend", "touchcancel"]
};
Blockly.longPid_ = 0;
Blockly.longStart_ = function(e, gesture) {
    Blockly.longStop_();
    if (e.changedTouches && e.changedTouches.length != 1) return;
    Blockly.longPid_ = setTimeout(function() {
        if (e.changedTouches) {
            e.button = 2;
            e.clientX = e.changedTouches[0].clientX;
            e.clientY = e.changedTouches[0].clientY
        }
        if (gesture) gesture.handleRightClick(e)
    }, Blockly.LONGPRESS)
};
Blockly.longStop_ = function() {
    if (Blockly.longPid_) {
        clearTimeout(Blockly.longPid_);
        Blockly.longPid_ = 0
    }
};
Blockly.Touch.clearTouchIdentifier = function() {
    Blockly.Touch.touchIdentifier_ = null
};
Blockly.Touch.shouldHandleEvent = function(e) {
    return !Blockly.Touch.isMouseOrTouchEvent(e) || Blockly.Touch.checkTouchIdentifier(e)
};
Blockly.Touch.getTouchIdentifierFromEvent = function(e) {
    return e.pointerId != undefined ? e.pointerId : e.changedTouches && e.changedTouches[0] && e.changedTouches[0].identifier !== undefined && e.changedTouches[0].identifier !== null ? e.changedTouches[0].identifier : "mouse"
};
Blockly.Touch.checkTouchIdentifier = function(e) {
    var identifier = Blockly.Touch.getTouchIdentifierFromEvent(e);
    if (Blockly.Touch.touchIdentifier_ !== undefined && Blockly.Touch.touchIdentifier_ !== null) return Blockly.Touch.touchIdentifier_ == identifier;
    if (e.type == "mousedown" || e.type == "touchstart" || e.type == "pointerdown") {
        Blockly.Touch.touchIdentifier_ = identifier;
        return true
    }
    return false
};
Blockly.Touch.setClientFromTouch = function(e) {
    if (Blockly.utils.startsWith(e.type, "touch")) {
        var touchPoint = e.changedTouches[0];
        e.clientX = touchPoint.clientX;
        e.clientY = touchPoint.clientY
    }
};
Blockly.Touch.isMouseOrTouchEvent = function(e) {
    return Blockly.utils.startsWith(e.type, "touch") || Blockly.utils.startsWith(e.type, "mouse") || Blockly.utils.startsWith(e.type, "pointer")
};
Blockly.Touch.isTouchEvent = function(e) {
    return Blockly.utils.startsWith(e.type, "touch") || Blockly.utils.startsWith(e.type, "pointer")
};
Blockly.Touch.splitEventByTouches = function(e) {
    var events = [];
    if (e.changedTouches)
        for (var i = 0; i < e.changedTouches.length; i++) {
            var newEvent = {
                type: e.type,
                changedTouches: [e.changedTouches[i]],
                target: e.target,
                stopPropagation: function() {
                    e.stopPropagation()
                },
                preventDefault: function() {
                    e.preventDefault()
                }
            };
            events[i] = newEvent
        } else events.push(e);
    return events
};
goog.provide("Blockly.TouchGesture");
goog.require("Blockly.Gesture");
goog.require("Blockly.utils");
goog.require("goog.math.Coordinate");
Blockly.TouchGesture = function(e, creatorWorkspace) {
    Blockly.TouchGesture.superClass_.constructor.call(this, e, creatorWorkspace);
    this.isMultiTouch_ = false;
    this.cachedPoints_ = {};
    this.previousScale_ = 0;
    this.startDistance_ = 0;
    this.onStartWrapper_ = null
};
goog.inherits(Blockly.TouchGesture, Blockly.Gesture);
Blockly.TouchGesture.ZOOM_IN_MULTIPLIER = 5;
Blockly.TouchGesture.ZOOM_OUT_MULTIPLIER = 6;
Blockly.TouchGesture.prototype.doStart = function(e) {
    Blockly.TouchGesture.superClass_.doStart.call(this, e);
    if (!this.isEnding_ && Blockly.Touch.isTouchEvent(e)) this.handleTouchStart(e)
};
Blockly.TouchGesture.prototype.bindMouseEvents = function(e) {
    this.onStartWrapper_ = Blockly.bindEventWithChecks_(document, "mousedown", null, this.handleStart.bind(this), true);
    this.onMoveWrapper_ = Blockly.bindEventWithChecks_(document, "mousemove", null, this.handleMove.bind(this), true);
    this.onUpWrapper_ = Blockly.bindEventWithChecks_(document, "mouseup", null, this.handleUp.bind(this), true);
    e.preventDefault();
    e.stopPropagation()
};
Blockly.TouchGesture.prototype.handleStart = function(e) {
    if (this.isDragging()) return;
    if (Blockly.Touch.isTouchEvent(e)) {
        this.handleTouchStart(e);
        if (this.isMultiTouch()) Blockly.longStop_()
    }
};
Blockly.TouchGesture.prototype.handleMove = function(e) {
    if (this.isDragging()) {
        if (Blockly.Touch.shouldHandleEvent(e)) Blockly.TouchGesture.superClass_.handleMove.call(this, e);
        return
    }
    if (this.isMultiTouch()) {
        if (Blockly.Touch.isTouchEvent(e)) this.handleTouchMove(e);
        Blockly.longStop_()
    } else Blockly.TouchGesture.superClass_.handleMove.call(this, e)
};
Blockly.TouchGesture.prototype.handleUp = function(e) {
    if (Blockly.Touch.isTouchEvent(e) && !this.isDragging()) this.handleTouchEnd(e);
    if (!this.isMultiTouch() || this.isDragging()) {
        if (!Blockly.Touch.shouldHandleEvent(e)) return;
        Blockly.TouchGesture.superClass_.handleUp.call(this, e)
    } else {
        e.preventDefault();
        e.stopPropagation();
        this.dispose()
    }
};
Blockly.TouchGesture.prototype.isMultiTouch = function() {
    return this.isMultiTouch_
};
Blockly.TouchGesture.prototype.dispose = function() {
    Blockly.TouchGesture.superClass_.dispose.call(this);
    if (this.onStartWrapper_) Blockly.unbindEvent_(this.onStartWrapper_)
};
Blockly.TouchGesture.prototype.handleTouchStart = function(e) {
    var pointerId = Blockly.Touch.getTouchIdentifierFromEvent(e);
    this.cachedPoints_[pointerId] = this.getTouchPoint(e);
    var pointers = Object.keys(this.cachedPoints_);
    if (pointers.length == 2) {
        var point0 = this.cachedPoints_[pointers[0]];
        var point1 = this.cachedPoints_[pointers[1]];
        this.startDistance_ = goog.math.Coordinate.distance(point0, point1);
        this.isMultiTouch_ = true;
        e.preventDefault()
    }
};
Blockly.TouchGesture.prototype.handleTouchMove = function(e) {
    var pointerId = Blockly.Touch.getTouchIdentifierFromEvent(e);
    this.cachedPoints_[pointerId] = this.getTouchPoint(e);
    var pointers = Object.keys(this.cachedPoints_);
    if (pointers.length == 2) {
        var point0 = this.cachedPoints_[pointers[0]];
        var point1 = this.cachedPoints_[pointers[1]];
        var moveDistance = goog.math.Coordinate.distance(point0, point1);
        var startDistance = this.startDistance_;
        var scale = this.touchScale_ = moveDistance / startDistance;
        if (this.previousScale_ >
            0 && this.previousScale_ < Infinity) {
            var gestureScale = scale - this.previousScale_;
            var delta = gestureScale > 0 ? gestureScale * Blockly.TouchGesture.ZOOM_IN_MULTIPLIER : gestureScale * Blockly.TouchGesture.ZOOM_OUT_MULTIPLIER;
            var workspace = this.startWorkspace_;
            var position = Blockly.utils.mouseToSvg(e, workspace.getParentSvg(), workspace.getInverseScreenCTM());
            workspace.zoom(position.x, position.y, delta)
        }
        this.previousScale_ = scale;
        e.preventDefault()
    }
};
Blockly.TouchGesture.prototype.handleTouchEnd = function(e) {
    var pointerId = Blockly.Touch.getTouchIdentifierFromEvent(e);
    if (this.cachedPoints_[pointerId]) delete this.cachedPoints_[pointerId];
    if (Object.keys(this.cachedPoints_).length < 2) {
        this.cachedPoints_ = {};
        this.previousScale_ = 0
    }
};
Blockly.TouchGesture.prototype.getTouchPoint = function(e) {
    if (!this.startWorkspace_) return null;
    return new goog.math.Coordinate(e.pageX ? e.pageX : e.changedTouches[0].pageX, e.pageY ? e.pageY : e.changedTouches[0].pageY)
};
goog.provide("Blockly.Trashcan");
goog.require("Blockly.utils");
goog.require("goog.math.Rect");
Blockly.Trashcan = function(workspace) {
    this.workspace_ = workspace
};
Blockly.Trashcan.prototype.WIDTH_ = 47;
Blockly.Trashcan.prototype.BODY_HEIGHT_ = 44;
Blockly.Trashcan.prototype.LID_HEIGHT_ = 16;
Blockly.Trashcan.prototype.MARGIN_BOTTOM_ = 20;
Blockly.Trashcan.prototype.MARGIN_SIDE_ = 20;
Blockly.Trashcan.prototype.MARGIN_HOTSPOT_ = 10;
Blockly.Trashcan.prototype.SPRITE_LEFT_ = 0;
Blockly.Trashcan.prototype.SPRITE_TOP_ = 32;
Blockly.Trashcan.prototype.isOpen = false;
Blockly.Trashcan.prototype.svgGroup_ = null;
Blockly.Trashcan.prototype.svgLid_ = null;
Blockly.Trashcan.prototype.lidTask_ = 0;
Blockly.Trashcan.prototype.lidOpen_ = 0;
Blockly.Trashcan.prototype.left_ = 0;
Blockly.Trashcan.prototype.top_ = 0;
Blockly.Trashcan.prototype.createDom = function() {
    this.svgGroup_ = Blockly.utils.createSvgElement("g", {
        "class": "blocklyTrash"
    }, null);
    var clip;
    var rnd = String(Math.random()).substring(2);
    clip = Blockly.utils.createSvgElement("clipPath", {
        "id": "blocklyTrashBodyClipPath" + rnd
    }, this.svgGroup_);
    Blockly.utils.createSvgElement("rect", {
        "width": this.WIDTH_,
        "height": this.BODY_HEIGHT_,
        "y": this.LID_HEIGHT_
    }, clip);
    var body = Blockly.utils.createSvgElement("image", {
        "width": Blockly.SPRITE.width,
        "x": -this.SPRITE_LEFT_,
        "height": Blockly.SPRITE.height,
        "y": -this.SPRITE_TOP_,
        "clip-path": "url(#blocklyTrashBodyClipPath" + rnd + ")"
    }, this.svgGroup_);
    body.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.workspace_.options.pathToMedia + Blockly.SPRITE.url);
    clip = Blockly.utils.createSvgElement("clipPath", {
        "id": "blocklyTrashLidClipPath" + rnd
    }, this.svgGroup_);
    Blockly.utils.createSvgElement("rect", {
        "width": this.WIDTH_,
        "height": this.LID_HEIGHT_
    }, clip);
    this.svgLid_ = Blockly.utils.createSvgElement("image", {
        "width": Blockly.SPRITE.width,
        "x": -this.SPRITE_LEFT_,
        "height": Blockly.SPRITE.height,
        "y": -this.SPRITE_TOP_,
        "clip-path": "url(#blocklyTrashLidClipPath" + rnd + ")"
    }, this.svgGroup_);
    this.svgLid_.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", this.workspace_.options.pathToMedia + Blockly.SPRITE.url);
    Blockly.bindEventWithChecks_(this.svgGroup_, "mouseup", this, this.click);
    this.animateLid_();
    return this.svgGroup_
};
Blockly.Trashcan.prototype.init = function(bottom) {
    this.bottom_ = this.MARGIN_BOTTOM_ + bottom;
    this.setOpen_(false);
    return this.bottom_ + this.BODY_HEIGHT_ + this.LID_HEIGHT_
};
Blockly.Trashcan.prototype.dispose = function() {
    if (this.svgGroup_) {
        Blockly.utils.removeNode(this.svgGroup_);
        this.svgGroup_ = null
    }
    this.svgLid_ = null;
    this.workspace_ = null;
    clearTimeout(this.lidTask_)
};
Blockly.Trashcan.prototype.position = function() {
    var metrics = this.workspace_.getMetrics();
    if (!metrics) return;
    if (this.workspace_.RTL) {
        this.left_ = this.MARGIN_SIDE_ + Blockly.Scrollbar.scrollbarThickness;
        if (metrics.toolboxPosition == Blockly.TOOLBOX_AT_LEFT) {
            this.left_ += metrics.flyoutWidth;
            if (this.workspace_.toolbox_) this.left_ += metrics.absoluteLeft
        }
    } else {
        this.left_ = metrics.viewWidth + metrics.absoluteLeft - this.WIDTH_ - this.MARGIN_SIDE_ - Blockly.Scrollbar.scrollbarThickness;
        if (metrics.toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) this.left_ -=
            metrics.flyoutWidth
    }
    this.top_ = metrics.viewHeight + metrics.absoluteTop - (this.BODY_HEIGHT_ + this.LID_HEIGHT_) - this.bottom_;
    if (metrics.toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM) this.top_ -= metrics.flyoutHeight;
    this.svgGroup_.setAttribute("transform", "translate(" + this.left_ + "," + this.top_ + ")")
};
Blockly.Trashcan.prototype.getClientRect = function() {
    if (!this.svgGroup_) return null;
    var trashRect = this.svgGroup_.getBoundingClientRect();
    var left = trashRect.left + this.SPRITE_LEFT_ - this.MARGIN_HOTSPOT_;
    var top = trashRect.top + this.SPRITE_TOP_ - this.MARGIN_HOTSPOT_;
    var width = this.WIDTH_ + 2 * this.MARGIN_HOTSPOT_;
    var height = this.LID_HEIGHT_ + this.BODY_HEIGHT_ + 2 * this.MARGIN_HOTSPOT_;
    return new goog.math.Rect(left, top, width, height)
};
Blockly.Trashcan.prototype.setOpen_ = function(state) {
    if (this.isOpen == state) return;
    clearTimeout(this.lidTask_);
    this.isOpen = state;
    this.animateLid_()
};
Blockly.Trashcan.prototype.animateLid_ = function() {
    this.lidOpen_ += this.isOpen ? .2 : -.2;
    this.lidOpen_ = Math.min(Math.max(this.lidOpen_, 0), 1);
    var lidAngle = this.lidOpen_ * 45;
    this.svgLid_.setAttribute("transform", "rotate(" + (this.workspace_.RTL ? -lidAngle : lidAngle) + "," + (this.workspace_.RTL ? 4 : this.WIDTH_ - 4) + "," + (this.LID_HEIGHT_ - 2) + ")");
    var opacity = .4 + this.lidOpen_ * (.8 - .4);
    this.svgGroup_.style.opacity = opacity;
    if (this.lidOpen_ > 0 && this.lidOpen_ < 1) this.lidTask_ = setTimeout(this.animateLid_.bind(this), 20)
};
Blockly.Trashcan.prototype.close = function() {
    this.setOpen_(false)
};
Blockly.Trashcan.prototype.click = function() {
    var dx = this.workspace_.startScrollX - this.workspace_.scrollX;
    var dy = this.workspace_.startScrollY - this.workspace_.scrollY;
    if (Math.sqrt(dx * dx + dy * dy) > Blockly.DRAG_RADIUS) return;
    console.log("TODO: Inspect trash.")
};
goog.provide("Blockly.Events.Ui");
goog.require("Blockly.Events");
goog.require("Blockly.Events.Abstract");
Blockly.Events.Ui = function(block, element, oldValue, newValue) {
    Blockly.Events.Ui.superClass_.constructor.call(this);
    this.blockId = block ? block.id : null;
    this.workspaceId = block ? block.workspace.id : null;
    this.element = element;
    this.oldValue = oldValue;
    this.newValue = newValue;
    this.recordUndo = false
};
goog.inherits(Blockly.Events.Ui, Blockly.Events.Abstract);
Blockly.Events.Ui.prototype.type = Blockly.Events.UI;
Blockly.Events.Ui.prototype.toJson = function() {
    var json = Blockly.Events.Ui.superClass_.toJson.call(this);
    json["element"] = this.element;
    if (this.newValue !== undefined) json["newValue"] = this.newValue;
    if (this.blockId) json["blockId"] = this.blockId;
    return json
};
Blockly.Events.Ui.prototype.fromJson = function(json) {
    Blockly.Events.Ui.superClass_.fromJson.call(this, json);
    this.element = json["element"];
    this.newValue = json["newValue"];
    this.blockId = json["blockId"]
};
goog.provide("Blockly.utils.uiMenu");
Blockly.utils.uiMenu.getSize = function(menu) {
    var menuDom = menu.getElement();
    var menuSize = goog.style.getSize(menuDom);
    menuSize.height = menuDom.scrollHeight;
    return menuSize
};
Blockly.utils.uiMenu.adjustBBoxesForRTL = function(viewportBBox, anchorBBox, menuSize) {
    anchorBBox.left += menuSize.width;
    anchorBBox.right += menuSize.width;
    viewportBBox.left += menuSize.width;
    viewportBBox.right += menuSize.width
};
goog.provide("Blockly.utils");
goog.require("goog.dom");
goog.require("goog.math.Coordinate");
goog.require("goog.userAgent");
Blockly.utils.removeAttribute = function(element, attributeName) {
    if (goog.userAgent.IE && goog.userAgent.isVersion("10.0")) element.setAttribute(attributeName, null);
    else element.removeAttribute(attributeName)
};
Blockly.utils.addClass = function(element, className) {
    var classes = element.getAttribute("class") || "";
    if ((" " + classes + " ").indexOf(" " + className + " ") != -1) return false;
    if (classes) classes += " ";
    element.setAttribute("class", classes + className);
    return true
};
Blockly.utils.removeClass = function(element, className) {
    var classes = element.getAttribute("class");
    if ((" " + classes + " ").indexOf(" " + className + " ") == -1) return false;
    var classList = classes.split(/\s+/);
    for (var i = 0; i < classList.length; i++)
        if (!classList[i] || classList[i] == className) {
            classList.splice(i, 1);
            i--
        } if (classList.length) element.setAttribute("class", classList.join(" "));
    else Blockly.utils.removeAttribute(element, "class");
    return true
};
Blockly.utils.hasClass = function(element, className) {
    var classes = element.getAttribute("class");
    return (" " + classes + " ").indexOf(" " + className + " ") != -1
};
Blockly.utils.removeNode = function(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null
};
Blockly.utils.noEvent = function(e) {
    e.preventDefault();
    e.stopPropagation()
};
Blockly.utils.isTargetInput = function(e) {
    return e.target.type == "textarea" || e.target.type == "text" || e.target.type == "number" || e.target.type == "email" || e.target.type == "password" || e.target.type == "search" || e.target.type == "tel" || e.target.type == "url" || e.target.isContentEditable
};
Blockly.utils.getRelativeXY = function(element) {
    var xy = new goog.math.Coordinate(0, 0);
    var x = element.getAttribute("x");
    if (x) xy.x = parseInt(x, 10);
    var y = element.getAttribute("y");
    if (y) xy.y = parseInt(y, 10);
    var transform = element.getAttribute("transform");
    var r = transform && transform.match(Blockly.utils.getRelativeXY.XY_REGEX_);
    if (r) {
        xy.x += parseFloat(r[1]);
        if (r[3]) xy.y += parseFloat(r[3])
    }
    var style = element.getAttribute("style");
    if (style && style.indexOf("translate") > -1) {
        var styleComponents = style.match(Blockly.utils.getRelativeXY.XY_2D_REGEX_);
        if (!styleComponents) styleComponents = style.match(Blockly.utils.getRelativeXY.XY_3D_REGEX_);
        if (styleComponents) {
            xy.x += parseFloat(styleComponents[1]);
            if (styleComponents[3]) xy.y += parseFloat(styleComponents[3])
        }
    }
    return xy
};
Blockly.utils.getInjectionDivXY_ = function(element) {
    var x = 0;
    var y = 0;
    while (element) {
        var xy = Blockly.utils.getRelativeXY(element);
        x = x + xy.x;
        y = y + xy.y;
        var classes = element.getAttribute("class") || "";
        if ((" " + classes + " ").indexOf(" injectionDiv ") != -1) break;
        element = element.parentNode
    }
    return new goog.math.Coordinate(x, y)
};
Blockly.utils.getRelativeXY.XY_REGEX_ = /translate\(\s*([-+\d.e]+)([ ,]\s*([-+\d.e]+)\s*\))?/;
Blockly.utils.getRelativeXY.XY_3D_REGEX_ = /transform:\s*translate3d\(\s*([-+\d.e]+)px([ ,]\s*([-+\d.e]+)\s*)px([ ,]\s*([-+\d.e]+)\s*)px\)?/;
Blockly.utils.getRelativeXY.XY_2D_REGEX_ = /transform:\s*translate\(\s*([-+\d.e]+)px([ ,]\s*([-+\d.e]+)\s*)px\)?/;
Blockly.utils.createSvgElement = function(name, attrs, parent) {
    var e = document.createElementNS(Blockly.SVG_NS, name);
    for (var key in attrs) e.setAttribute(key, attrs[key]);
    if (document.body.runtimeStyle) e.runtimeStyle = e.currentStyle = e.style;
    if (parent) parent.appendChild(e);
    return e
};
Blockly.utils.isRightButton = function(e) {
    if (e.ctrlKey && goog.userAgent.MAC) return true;
    return e.button == 2
};
Blockly.utils.mouseToSvg = function(e, svg, matrix) {
    var svgPoint = svg.createSVGPoint();
    svgPoint.x = e.clientX;
    svgPoint.y = e.clientY;
    if (!matrix) matrix = svg.getScreenCTM().inverse();
    return svgPoint.matrixTransform(matrix)
};
Blockly.utils.shortestStringLength = function(array) {
    if (!array.length) return 0;
    return array.reduce(function(a, b) {
        return a.length < b.length ? a : b
    }).length
};
Blockly.utils.commonWordPrefix = function(array, opt_shortest) {
    if (!array.length) return 0;
    else if (array.length == 1) return array[0].length;
    var wordPrefix = 0;
    var max = opt_shortest || Blockly.utils.shortestStringLength(array);
    for (var len = 0; len < max; len++) {
        var letter = array[0][len];
        for (var i = 1; i < array.length; i++)
            if (letter != array[i][len]) return wordPrefix;
        if (letter == " ") wordPrefix = len + 1
    }
    for (var i = 1; i < array.length; i++) {
        var letter = array[i][len];
        if (letter && letter != " ") return wordPrefix
    }
    return max
};
Blockly.utils.commonWordSuffix = function(array, opt_shortest) {
    if (!array.length) return 0;
    else if (array.length == 1) return array[0].length;
    var wordPrefix = 0;
    var max = opt_shortest || Blockly.utils.shortestStringLength(array);
    for (var len = 0; len < max; len++) {
        var letter = array[0].substr(-len - 1, 1);
        for (var i = 1; i < array.length; i++)
            if (letter != array[i].substr(-len - 1, 1)) return wordPrefix;
        if (letter == " ") wordPrefix = len + 1
    }
    for (var i = 1; i < array.length; i++) {
        var letter = array[i].charAt(array[i].length - len - 1);
        if (letter && letter != " ") return wordPrefix
    }
    return max
};
Blockly.utils.tokenizeInterpolation = function(message) {
    return Blockly.utils.tokenizeInterpolation_(message, true)
};
Blockly.utils.replaceMessageReferences = function(message) {
    if (typeof message != "string") return message;
    var interpolatedResult = Blockly.utils.tokenizeInterpolation_(message, false);
    return interpolatedResult.length ? interpolatedResult[0] : ""
};
Blockly.utils.checkMessageReferences = function(message) {
    var validSoFar = true;
    var msgTable = Blockly.Msg;
    var regex = /%{(BKY_[A-Z][A-Z0-9_]*)}/gi;
    var match = regex.exec(message);
    while (match) {
        var msgKey = match[1];
        msgKey = msgKey.toUpperCase();
        if (msgKey.substr(0, 4) != "BKY_") {
            console.log("WARNING: Unsupported message table prefix in %{" + match[1] + "}.");
            validSoFar = false
        } else if (msgTable[msgKey.substr(4)] == undefined) {
            console.log("WARNING: No message string for %{" + match[1] + "}.");
            validSoFar = false
        }
        message = message.substring(match.index +
            msgKey.length + 1);
        match = regex.exec(message)
    }
    return validSoFar
};
Blockly.utils.tokenizeInterpolation_ = function(message, parseInterpolationTokens) {
    var tokens = [];
    var chars = message.split("");
    chars.push("");
    var state = 0;
    var buffer = [];
    var number = null;
    for (var i = 0; i < chars.length; i++) {
        var c = chars[i];
        if (state == 0)
            if (c == "%") {
                var text = buffer.join("");
                if (text) tokens.push(text);
                buffer.length = 0;
                state = 1
            } else buffer.push(c);
        else if (state == 1)
            if (c == "%") {
                buffer.push(c);
                state = 0
            } else if (parseInterpolationTokens && "0" <= c && c <= "9") {
            state = 2;
            number = c;
            var text = buffer.join("");
            if (text) tokens.push(text);
            buffer.length = 0
        } else if (c == "{") state = 3;
        else {
            buffer.push("%", c);
            state = 0
        } else if (state == 2)
            if ("0" <= c && c <= "9") number += c;
            else {
                tokens.push(parseInt(number, 10));
                i--;
                state = 0
            }
        else if (state == 3)
            if (c == "") {
                buffer.splice(0, 0, "%{");
                i--;
                state = 0
            } else if (c != "}") buffer.push(c);
        else {
            var rawKey = buffer.join("");
            if (/[a-zA-Z][a-zA-Z0-9_]*/.test(rawKey)) {
                var keyUpper = rawKey.toUpperCase();
                var bklyKey = Blockly.utils.startsWith(keyUpper, "BKY_") ? keyUpper.substring(4) : null;
                if (bklyKey && bklyKey in Blockly.Msg) {
                    var rawValue = Blockly.Msg[bklyKey];
                    if (typeof rawValue == "string") Array.prototype.push.apply(tokens, Blockly.utils.tokenizeInterpolation_(rawValue, parseInterpolationTokens));
                    else if (parseInterpolationTokens) tokens.push(String(rawValue));
                    else tokens.push(rawValue)
                } else tokens.push("%{" + rawKey + "}");
                buffer.length = 0;
                state = 0
            } else {
                tokens.push("%{" + rawKey + "}");
                buffer.length = 0;
                state = 0
            }
        }
    }
    var text = buffer.join("");
    if (text) tokens.push(text);
    var mergedTokens = [];
    buffer.length = 0;
    for (var i = 0; i < tokens.length; ++i)
        if (typeof tokens[i] == "string") buffer.push(tokens[i]);
        else {
            text = buffer.join("");
            if (text) mergedTokens.push(text);
            buffer.length = 0;
            mergedTokens.push(tokens[i])
        } text = buffer.join("");
    if (text) mergedTokens.push(text);
    buffer.length = 0;
    return mergedTokens
};
Blockly.utils.genUid = function() {
    var length = 20;
    var soupLength = Blockly.utils.genUid.soup_.length;
    var id = [];
    for (var i = 0; i < length; i++) id[i] = Blockly.utils.genUid.soup_.charAt(Math.random() * soupLength);
    return id.join("")
};
Blockly.utils.genUid.soup_ = "!#$%()*+,-./:;=?@[]^_`{|}~" + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
Blockly.utils.wrap = function(text, limit) {
    var lines = text.split("\n");
    for (var i = 0; i < lines.length; i++) lines[i] = Blockly.utils.wrapLine_(lines[i], limit);
    return lines.join("\n")
};
Blockly.utils.wrapLine_ = function(text, limit) {
    if (text.length <= limit) return text;
    var words = text.trim().split(/\s+/);
    for (var i = 0; i < words.length; i++)
        if (words[i].length > limit) limit = words[i].length;
    var lastScore;
    var score = -Infinity;
    var lastText;
    var lineCount = 1;
    do {
        lastScore = score;
        lastText = text;
        var wordBreaks = [];
        var steps = words.length / lineCount;
        var insertedBreaks = 1;
        for (var i = 0; i < words.length - 1; i++)
            if (insertedBreaks < (i + 1.5) / steps) {
                insertedBreaks++;
                wordBreaks[i] = true
            } else wordBreaks[i] = false;
        wordBreaks = Blockly.utils.wrapMutate_(words,
            wordBreaks, limit);
        score = Blockly.utils.wrapScore_(words, wordBreaks, limit);
        text = Blockly.utils.wrapToText_(words, wordBreaks);
        lineCount++
    } while (score > lastScore);
    return lastText
};
Blockly.utils.wrapScore_ = function(words, wordBreaks, limit) {
    var lineLengths = [0];
    var linePunctuation = [];
    for (var i = 0; i < words.length; i++) {
        lineLengths[lineLengths.length - 1] += words[i].length;
        if (wordBreaks[i] === true) {
            lineLengths.push(0);
            linePunctuation.push(words[i].charAt(words[i].length - 1))
        } else if (wordBreaks[i] === false) lineLengths[lineLengths.length - 1]++
    }
    var maxLength = Math.max.apply(Math, lineLengths);
    var score = 0;
    for (var i = 0; i < lineLengths.length; i++) {
        score -= Math.pow(Math.abs(limit - lineLengths[i]), 1.5) *
            2;
        score -= Math.pow(maxLength - lineLengths[i], 1.5);
        if (".?!".indexOf(linePunctuation[i]) != -1) score += limit / 3;
        else if (",;)]}".indexOf(linePunctuation[i]) != -1) score += limit / 4
    }
    if (lineLengths.length > 1 && lineLengths[lineLengths.length - 1] <= lineLengths[lineLengths.length - 2]) score += .5;
    return score
};
Blockly.utils.wrapMutate_ = function(words, wordBreaks, limit) {
    var bestScore = Blockly.utils.wrapScore_(words, wordBreaks, limit);
    var bestBreaks;
    for (var i = 0; i < wordBreaks.length - 1; i++) {
        if (wordBreaks[i] == wordBreaks[i + 1]) continue;
        var mutatedWordBreaks = [].concat(wordBreaks);
        mutatedWordBreaks[i] = !mutatedWordBreaks[i];
        mutatedWordBreaks[i + 1] = !mutatedWordBreaks[i + 1];
        var mutatedScore = Blockly.utils.wrapScore_(words, mutatedWordBreaks, limit);
        if (mutatedScore > bestScore) {
            bestScore = mutatedScore;
            bestBreaks = mutatedWordBreaks
        }
    }
    if (bestBreaks) return Blockly.utils.wrapMutate_(words,
        bestBreaks, limit);
    return wordBreaks
};
Blockly.utils.wrapToText_ = function(words, wordBreaks) {
    var text = [];
    for (var i = 0; i < words.length; i++) {
        text.push(words[i]);
        if (wordBreaks[i] !== undefined) text.push(wordBreaks[i] ? "\n" : " ")
    }
    return text.join("")
};
Blockly.utils.is3dSupported = function() {
    if (Blockly.utils.is3dSupported.cached_ !== undefined) return Blockly.utils.is3dSupported.cached_;
    if (!goog.global.getComputedStyle) return false;
    var el = document.createElement("p");
    var has3d = "none";
    var transforms = {
        "webkitTransform": "-webkit-transform",
        "OTransform": "-o-transform",
        "msTransform": "-ms-transform",
        "MozTransform": "-moz-transform",
        "transform": "transform"
    };
    document.body.insertBefore(el, null);
    for (var t in transforms)
        if (el.style[t] !== undefined) {
            el.style[t] = "translate3d(1px,1px,1px)";
            var computedStyle = goog.global.getComputedStyle(el);
            if (!computedStyle) {
                document.body.removeChild(el);
                return false
            }
            has3d = computedStyle.getPropertyValue(transforms[t])
        } document.body.removeChild(el);
    Blockly.utils.is3dSupported.cached_ = has3d !== "none";
    return Blockly.utils.is3dSupported.cached_
};
Blockly.utils.insertAfter = function(newNode, refNode) {
    var siblingNode = refNode.nextSibling;
    var parentNode = refNode.parentNode;
    if (!parentNode) throw Error("Reference node has no parent.");
    if (siblingNode) parentNode.insertBefore(newNode, siblingNode);
    else parentNode.appendChild(newNode)
};
Blockly.utils.runAfterPageLoad = function(fn) {
    if (typeof document != "object") throw Error("Blockly.utils.runAfterPageLoad() requires browser document.");
    if (document.readyState == "complete") fn();
    else var readyStateCheckInterval = setInterval(function() {
        if (document.readyState == "complete") {
            clearInterval(readyStateCheckInterval);
            fn()
        }
    }, 10)
};
Blockly.utils.setCssTransform = function(node, transform) {
    node.style["transform"] = transform;
    node.style["-webkit-transform"] = transform
};
Blockly.utils.getViewportBBox = function() {
    var windowSize = goog.dom.getViewportSize();
    var scrollOffset = goog.style.getViewportPageOffset(document);
    return {
        right: windowSize.width + scrollOffset.x,
        bottom: windowSize.height + scrollOffset.y,
        top: scrollOffset.y,
        left: scrollOffset.x
    }
};
Blockly.utils.startsWith = function(str, prefix) {
    return str.lastIndexOf(prefix, 0) == 0
};
Blockly.utils.arrayRemove = function(arr, obj) {
    var i = arr.indexOf(obj);
    if (i == -1) return false;
    arr.splice(i, 1);
    return true
};
Blockly.utils.toRadians = function(angleDegrees) {
    return angleDegrees * Math.PI / 180
};
Blockly.utils.toDegrees = function(angleRadians) {
    return angleRadians * 180 / Math.PI
};
Blockly.utils.containsNode = function(parent, descendant) {
    return !!(parent.compareDocumentPosition(descendant) & Node.DOCUMENT_POSITION_CONTAINED_BY)
};
goog.provide("Blockly.Events.VarBase");
goog.provide("Blockly.Events.VarCreate");
goog.provide("Blockly.Events.VarDelete");
goog.provide("Blockly.Events.VarRename");
goog.require("Blockly.Events");
goog.require("Blockly.Events.Abstract");
Blockly.Events.VarBase = function(variable) {
    Blockly.Events.VarBase.superClass_.constructor.call(this);
    this.varId = variable.getId();
    this.workspaceId = variable.workspace.id
};
goog.inherits(Blockly.Events.VarBase, Blockly.Events.Abstract);
Blockly.Events.VarBase.prototype.toJson = function() {
    var json = Blockly.Events.VarBase.superClass_.toJson.call(this);
    json["varId"] = this.varId;
    return json
};
Blockly.Events.VarBase.prototype.fromJson = function(json) {
    Blockly.Events.VarBase.superClass_.toJson.call(this);
    this.varId = json["varId"]
};
Blockly.Events.VarCreate = function(variable) {
    if (!variable) return;
    Blockly.Events.VarCreate.superClass_.constructor.call(this, variable);
    this.varType = variable.type;
    this.varName = variable.name
};
goog.inherits(Blockly.Events.VarCreate, Blockly.Events.VarBase);
Blockly.Events.VarCreate.prototype.type = Blockly.Events.VAR_CREATE;
Blockly.Events.VarCreate.prototype.toJson = function() {
    var json = Blockly.Events.VarCreate.superClass_.toJson.call(this);
    json["varType"] = this.varType;
    json["varName"] = this.varName;
    return json
};
Blockly.Events.VarCreate.prototype.fromJson = function(json) {
    Blockly.Events.VarCreate.superClass_.fromJson.call(this, json);
    this.varType = json["varType"];
    this.varName = json["varName"]
};
Blockly.Events.VarCreate.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    if (forward) workspace.createVariable(this.varName, this.varType, this.varId);
    else workspace.deleteVariableById(this.varId)
};
Blockly.Events.VarDelete = function(variable) {
    if (!variable) return;
    Blockly.Events.VarDelete.superClass_.constructor.call(this, variable);
    this.varType = variable.type;
    this.varName = variable.name
};
goog.inherits(Blockly.Events.VarDelete, Blockly.Events.VarBase);
Blockly.Events.VarDelete.prototype.type = Blockly.Events.VAR_DELETE;
Blockly.Events.VarDelete.prototype.toJson = function() {
    var json = Blockly.Events.VarDelete.superClass_.toJson.call(this);
    json["varType"] = this.varType;
    json["varName"] = this.varName;
    return json
};
Blockly.Events.VarDelete.prototype.fromJson = function(json) {
    Blockly.Events.VarDelete.superClass_.fromJson.call(this, json);
    this.varType = json["varType"];
    this.varName = json["varName"]
};
Blockly.Events.VarDelete.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    if (forward) workspace.deleteVariableById(this.varId);
    else workspace.createVariable(this.varName, this.varType, this.varId)
};
Blockly.Events.VarRename = function(variable, newName) {
    if (!variable) return;
    Blockly.Events.VarRename.superClass_.constructor.call(this, variable);
    this.oldName = variable.name;
    this.newName = newName
};
goog.inherits(Blockly.Events.VarRename, Blockly.Events.VarBase);
Blockly.Events.VarRename.prototype.type = Blockly.Events.VAR_RENAME;
Blockly.Events.VarRename.prototype.toJson = function() {
    var json = Blockly.Events.VarRename.superClass_.toJson.call(this);
    json["oldName"] = this.oldName;
    json["newName"] = this.newName;
    return json
};
Blockly.Events.VarRename.prototype.fromJson = function(json) {
    Blockly.Events.VarRename.superClass_.fromJson.call(this, json);
    this.oldName = json["oldName"];
    this.newName = json["newName"]
};
Blockly.Events.VarRename.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    if (forward) workspace.renameVariableById(this.varId, this.newName);
    else workspace.renameVariableById(this.varId, this.oldName)
};
goog.provide("Blockly.VariableMap");
goog.require("Blockly.Events.VarDelete");
goog.require("Blockly.Events.VarRename");
goog.require("Blockly.utils");
Blockly.VariableMap = function(workspace) {
    this.variableMap_ = {};
    this.workspace = workspace
};
Blockly.VariableMap.prototype.clear = function() {
    this.variableMap_ = new Object(null)
};
Blockly.VariableMap.prototype.renameVariable = function(variable, newName) {
    var type = variable.type;
    var conflictVar = this.getVariable(newName, type);
    var blocks = this.workspace.getAllBlocks(false);
    Blockly.Events.setGroup(true);
    try {
        if (!conflictVar || conflictVar.getId() == variable.getId()) this.renameVariableAndUses_(variable, newName, blocks);
        else this.renameVariableWithConflict_(variable, newName, conflictVar, blocks)
    } finally {
        Blockly.Events.setGroup(false)
    }
};
Blockly.VariableMap.prototype.renameVariableById = function(id, newName) {
    var variable = this.getVariableById(id);
    if (!variable) throw Error("Tried to rename a variable that didn't exist. ID: " + id);
    this.renameVariable(variable, newName)
};
Blockly.VariableMap.prototype.renameVariableAndUses_ = function(variable, newName, blocks) {
    Blockly.Events.fire(new Blockly.Events.VarRename(variable, newName));
    variable.name = newName;
    for (var i = 0; i < blocks.length; i++) blocks[i].updateVarName(variable)
};
Blockly.VariableMap.prototype.renameVariableWithConflict_ = function(variable, newName, conflictVar, blocks) {
    var type = variable.type;
    var oldCase = conflictVar.name;
    if (newName != oldCase) this.renameVariableAndUses_(conflictVar, newName, blocks);
    for (var i = 0; i < blocks.length; i++) blocks[i].renameVarById(variable.getId(), conflictVar.getId());
    Blockly.Events.fire(new Blockly.Events.VarDelete(variable));
    var variableList = this.getVariablesOfType(type);
    var variableIndex = variableList.indexOf(variable);
    this.variableMap_[type].splice(variableIndex,
        1)
};
Blockly.VariableMap.prototype.createVariable = function(name, opt_type, opt_id) {
    var variable = this.getVariable(name, opt_type);
    if (variable) {
        if (opt_id && variable.getId() != opt_id) throw Error('Variable "' + name + '" is already in use and its id is "' + variable.getId() + '" which conflicts with the passed in ' + 'id, "' + opt_id + '".');
        return variable
    }
    if (opt_id && this.getVariableById(opt_id)) throw Error('Variable id, "' + opt_id + '", is already in use.');
    opt_id = opt_id || Blockly.utils.genUid();
    opt_type = opt_type || "";
    variable = new Blockly.VariableModel(this.workspace,
        name, opt_type, opt_id);
    if (!this.variableMap_[opt_type]) this.variableMap_[opt_type] = [variable];
    else this.variableMap_[opt_type].push(variable);
    return variable
};
Blockly.VariableMap.prototype.deleteVariable = function(variable) {
    var variableList = this.variableMap_[variable.type];
    for (var i = 0, tempVar; tempVar = variableList[i]; i++)
        if (tempVar.getId() == variable.getId()) {
            variableList.splice(i, 1);
            Blockly.Events.fire(new Blockly.Events.VarDelete(variable));
            return
        }
};
Blockly.VariableMap.prototype.deleteVariableById = function(id) {
    var variable = this.getVariableById(id);
    if (variable) {
        var variableName = variable.name;
        var uses = this.getVariableUsesById(id);
        for (var i = 0, block; block = uses[i]; i++)
            if (block.type == "procedures_defnoreturn" || block.type == "procedures_defreturn") {
                var procedureName = block.getFieldValue("NAME");
                var deleteText = Blockly.Msg["CANNOT_DELETE_VARIABLE_PROCEDURE"].replace("%1", variableName).replace("%2", procedureName);
                Blockly.alert(deleteText);
                return
            } var map = this;
        if (uses.length > 1) {
            var confirmText = Blockly.Msg["DELETE_VARIABLE_CONFIRMATION"].replace("%1", String(uses.length)).replace("%2", variableName);
            Blockly.confirm(confirmText, function(ok) {
                if (ok) map.deleteVariableInternal_(variable, uses)
            })
        } else map.deleteVariableInternal_(variable, uses)
    } else console.warn("Can't delete non-existent variable: " + id)
};
Blockly.VariableMap.prototype.deleteVariableInternal_ = function(variable, uses) {
    var existingGroup = Blockly.Events.getGroup();
    if (!existingGroup) Blockly.Events.setGroup(true);
    try {
        for (var i = 0; i < uses.length; i++) uses[i].dispose(true, false);
        this.deleteVariable(variable)
    } finally {
        if (!existingGroup) Blockly.Events.setGroup(false)
    }
};
Blockly.VariableMap.prototype.getVariable = function(name, opt_type) {
    var type = opt_type || "";
    var list = this.variableMap_[type];
    if (list)
        for (var j = 0, variable; variable = list[j]; j++)
            if (Blockly.Names.equals(variable.name, name)) return variable;
    return null
};
Blockly.VariableMap.prototype.getVariableById = function(id) {
    var keys = Object.keys(this.variableMap_);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        for (var j = 0, variable; variable = this.variableMap_[key][j]; j++)
            if (variable.getId() == id) return variable
    }
    return null
};
Blockly.VariableMap.prototype.getVariablesOfType = function(type) {
    type = type || "";
    var variable_list = this.variableMap_[type];
    if (variable_list) return variable_list.slice();
    return []
};
Blockly.VariableMap.prototype.getVariableTypes = function() {
    var types = Object.keys(this.variableMap_);
    var hasEmpty = false;
    for (var i = 0; i < types.length; i++)
        if (types[i] == "") hasEmpty = true;
    if (!hasEmpty) types.push("");
    return types
};
Blockly.VariableMap.prototype.getAllVariables = function() {
    var all_variables = [];
    var keys = Object.keys(this.variableMap_);
    for (var i = 0; i < keys.length; i++) all_variables = all_variables.concat(this.variableMap_[keys[i]]);
    return all_variables
};
Blockly.VariableMap.prototype.getVariableUsesById = function(id) {
    var uses = [];
    var blocks = this.workspace.getAllBlocks(false);
    for (var i = 0; i < blocks.length; i++) {
        var blockVariables = blocks[i].getVarModels();
        if (blockVariables)
            for (var j = 0; j < blockVariables.length; j++)
                if (blockVariables[j].getId() == id) uses.push(blocks[i])
    }
    return uses
};
goog.provide("Blockly.VariableModel");
goog.require("Blockly.Events.VarCreate");
goog.require("Blockly.utils");
Blockly.VariableModel = function(workspace, name, opt_type, opt_id) {
    this.workspace = workspace;
    this.name = name;
    this.type = opt_type || "";
    this.id_ = opt_id || Blockly.utils.genUid();
    Blockly.Events.fire(new Blockly.Events.VarCreate(this))
};
Blockly.VariableModel.prototype.getId = function() {
    return this.id_
};
Blockly.VariableModel.compareByName = function(var1, var2) {
    var name1 = var1.name.toLowerCase();
    var name2 = var2.name.toLowerCase();
    if (name1 < name2) return -1;
    else if (name1 == name2) return 0;
    else return 1
};
goog.provide("Blockly.Variables");
goog.require("Blockly.Blocks");
goog.require("Blockly.constants");
goog.require("Blockly.VariableModel");
goog.require("Blockly.Workspace");
goog.require("Blockly.Xml");
goog.require("goog.string");
Blockly.Variables.NAME_TYPE = Blockly.VARIABLE_CATEGORY_NAME;
Blockly.Variables.allUsedVarModels = function(ws) {
    var blocks = ws.getAllBlocks(false);
    var variableHash = Object.create(null);
    for (var x = 0; x < blocks.length; x++) {
        var blockVariables = blocks[x].getVarModels();
        if (blockVariables)
            for (var y = 0; y < blockVariables.length; y++) {
                var variable = blockVariables[y];
                if (variable.getId()) variableHash[variable.getId()] = variable
            }
    }
    var variableList = [];
    for (var id in variableHash) variableList.push(variableHash[id]);
    return variableList
};
Blockly.Variables.allUsedVariables = function() {
    console.warn("Deprecated call to Blockly.Variables.allUsedVariables. " + "Use Blockly.Variables.allUsedVarModels instead.\nIf this is a major " + "issue please file a bug on GitHub.")
};
Blockly.Variables.ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE_ = {};
Blockly.Variables.allDeveloperVariables = function(workspace) {
    var blocks = workspace.getAllBlocks(false);
    var hash = {};
    for (var i = 0; i < blocks.length; i++) {
        var block = blocks[i];
        var getDeveloperVariables = block.getDeveloperVariables;
        if (!getDeveloperVariables && block.getDeveloperVars) {
            getDeveloperVariables = block.getDeveloperVars;
            if (!Blockly.Variables.ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE_[block.type]) {
                console.warn("Function getDeveloperVars() deprecated. Use " + "getDeveloperVariables() (block type '" + block.type +
                    "')");
                Blockly.Variables.ALL_DEVELOPER_VARS_WARNINGS_BY_BLOCK_TYPE_[block.type] = true
            }
        }
        if (getDeveloperVariables) {
            var devVars = getDeveloperVariables();
            for (var j = 0; j < devVars.length; j++) hash[devVars[j]] = devVars[j]
        }
    }
    var list = [];
    for (var name in hash) list.push(hash[name]);
    return list
};
Blockly.Variables.flyoutCategory = function(workspace) {
    var xmlList = [];
    var button = document.createElement("button");
    button.setAttribute("text", "%{BKY_NEW_VARIABLE}");
    button.setAttribute("callbackKey", "CREATE_VARIABLE");
    workspace.registerButtonCallback("CREATE_VARIABLE", function(button) {
        Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace())
    });
    xmlList.push(button);
    var blockList = Blockly.Variables.flyoutCategoryBlocks(workspace);
    xmlList = xmlList.concat(blockList);
    return xmlList
};
Blockly.Variables.flyoutCategoryBlocks = function(workspace) {
    var variableModelList = workspace.getVariablesOfType("");
    variableModelList.sort(Blockly.VariableModel.compareByName);
    var xmlList = [];
    if (variableModelList.length > 0) {
        var firstVariable = variableModelList[0];
        if (Blockly.Blocks["variables_set"]) {
            var gap = Blockly.Blocks["math_change"] ? 8 : 24;
            var blockText = "<xml>" + '<block type="variables_set" gap="' + gap + '">' + Blockly.Variables.generateVariableFieldXmlString(firstVariable) + "</block>" + "</xml>";
            var block = Blockly.Xml.textToDom(blockText).firstChild;
            xmlList.push(block)
        }
        if (Blockly.Blocks["math_change"]) {
            var gap = Blockly.Blocks["variables_get"] ? 20 : 8;
            var blockText = "<xml>" + '<block type="math_change" gap="' + gap + '">' + Blockly.Variables.generateVariableFieldXmlString(firstVariable) + '<value name="DELTA">' + '<shadow type="math_number">' + '<field name="NUM">1</field>' + "</shadow>" + "</value>" + "</block>" + "</xml>";
            var block = Blockly.Xml.textToDom(blockText).firstChild;
            xmlList.push(block)
        }
        for (var i = 0, variable; variable = variableModelList[i]; i++)
            if (Blockly.Blocks["variables_get"]) {
                var blockText =
                    "<xml>" + '<block type="variables_get" gap="8">' + Blockly.Variables.generateVariableFieldXmlString(variable) + "</block>" + "</xml>";
                var block = Blockly.Xml.textToDom(blockText).firstChild;
                xmlList.push(block)
            }
    }
    return xmlList
};
Blockly.Variables.generateUniqueName = function(workspace) {
    var variableList = workspace.getAllVariables();
    var newName = "";
    if (variableList.length) {
        var nameSuffix = 1;
        var letters = "ijkmnopqrstuvwxyzabcdefgh";
        var letterIndex = 0;
        var potName = letters.charAt(letterIndex);
        while (!newName) {
            var inUse = false;
            for (var i = 0; i < variableList.length; i++)
                if (variableList[i].name.toLowerCase() == potName) {
                    inUse = true;
                    break
                } if (inUse) {
                letterIndex++;
                if (letterIndex == letters.length) {
                    letterIndex = 0;
                    nameSuffix++
                }
                potName = letters.charAt(letterIndex);
                if (nameSuffix > 1) potName += nameSuffix
            } else newName = potName
        }
    } else newName = "i";
    return newName
};
Blockly.Variables.createVariableButtonHandler = function(workspace, opt_callback, opt_type) {
    var type = opt_type || "";
    var promptAndCheckWithAlert = function(defaultName) {
        Blockly.Variables.promptName(Blockly.Msg["NEW_VARIABLE_TITLE"], defaultName, function(text) {
            if (text) {
                var existing = Blockly.Variables.nameUsedWithAnyType_(text, workspace);
                if (existing) {
                    var lowerCase = text.toLowerCase();
                    if (existing.type == type) var msg = Blockly.Msg["VARIABLE_ALREADY_EXISTS"].replace("%1", lowerCase);
                    else {
                        var msg = Blockly.Msg["VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE"];
                        msg = msg.replace("%1", lowerCase).replace("%2", existing.type)
                    }
                    Blockly.alert(msg, function() {
                        promptAndCheckWithAlert(text)
                    })
                } else {
                    workspace.createVariable(text, type);
                    if (opt_callback) opt_callback(text)
                }
            } else if (opt_callback) opt_callback(null)
        })
    };
    promptAndCheckWithAlert("")
};
goog.exportSymbol("Blockly.Variables.createVariableButtonHandler", Blockly.Variables.createVariableButtonHandler);
Blockly.Variables.createVariable = Blockly.Variables.createVariableButtonHandler;
goog.exportSymbol("Blockly.Variables.createVariable", Blockly.Variables.createVariable);
Blockly.Variables.renameVariable = function(workspace, variable, opt_callback) {
    var promptAndCheckWithAlert = function(defaultName) {
        var promptText = Blockly.Msg["RENAME_VARIABLE_TITLE"].replace("%1", variable.name);
        Blockly.Variables.promptName(promptText, defaultName, function(newName) {
            if (newName) {
                var existing = Blockly.Variables.nameUsedWithOtherType_(newName, variable.type, workspace);
                if (existing) {
                    var msg = Blockly.Msg["VARIABLE_ALREADY_EXISTS_FOR_ANOTHER_TYPE"].replace("%1", newName.toLowerCase()).replace("%2", existing.type);
                    Blockly.alert(msg, function() {
                        promptAndCheckWithAlert(newName)
                    })
                } else {
                    workspace.renameVariableById(variable.getId(), newName);
                    if (opt_callback) opt_callback(newName)
                }
            } else if (opt_callback) opt_callback(null)
        })
    };
    promptAndCheckWithAlert("")
};
Blockly.Variables.promptName = function(promptText, defaultText, callback) {
    Blockly.prompt(promptText, defaultText, function(newVar) {
        if (newVar) {
            newVar = newVar.replace(/[\s\xa0]+/g, " ").replace(/^ | $/g, "");
            if (newVar == Blockly.Msg["RENAME_VARIABLE"] || newVar == Blockly.Msg["NEW_VARIABLE"]) newVar = null
        }
        callback(newVar)
    })
};
Blockly.Variables.nameUsedWithOtherType_ = function(name, type, workspace) {
    var allVariables = workspace.getVariableMap().getAllVariables();
    name = name.toLowerCase();
    for (var i = 0, variable; variable = allVariables[i]; i++)
        if (variable.name.toLowerCase() == name && variable.type != type) return variable;
    return null
};
Blockly.Variables.nameUsedWithAnyType_ = function(name, workspace) {
    var allVariables = workspace.getVariableMap().getAllVariables();
    name = name.toLowerCase();
    for (var i = 0, variable; variable = allVariables[i]; i++)
        if (variable.name.toLowerCase() == name) return variable;
    return null
};
Blockly.Variables.generateVariableFieldXmlString = function(variableModel) {
    var typeString = variableModel.type;
    if (typeString == "") typeString = "''";
    var text = '<field name="VAR" id="' + variableModel.getId() + '" variabletype="' + goog.string.htmlEscape(typeString) + '">' + goog.string.htmlEscape(variableModel.name) + "</field>";
    return text
};
Blockly.Variables.generateVariableFieldDom = function(variableModel) {
    var xmlFieldString = Blockly.Variables.generateVariableFieldXmlString(variableModel);
    var text = "<xml>" + xmlFieldString + "</xml>";
    var dom = Blockly.Xml.textToDom(text);
    var fieldDom = dom.firstChild;
    return fieldDom
};
Blockly.Variables.getOrCreateVariablePackage = function(workspace, id, opt_name, opt_type) {
    var variable = Blockly.Variables.getVariable(workspace, id, opt_name, opt_type);
    if (!variable) variable = Blockly.Variables.createVariable_(workspace, id, opt_name, opt_type);
    return variable
};
Blockly.Variables.getVariable = function(workspace, id, opt_name, opt_type) {
    var potentialVariableMap = workspace.getPotentialVariableMap();
    if (id) {
        var variable = workspace.getVariableById(id);
        if (!variable && potentialVariableMap) variable = potentialVariableMap.getVariableById(id)
    } else if (opt_name) {
        if (opt_type == undefined) throw Error("Tried to look up a variable by name without a type");
        var variable = workspace.getVariable(opt_name, opt_type);
        if (!variable && potentialVariableMap) variable = potentialVariableMap.getVariable(opt_name,
            opt_type)
    }
    return variable
};
Blockly.Variables.createVariable_ = function(workspace, id, opt_name, opt_type) {
    var potentialVariableMap = workspace.getPotentialVariableMap();
    if (!opt_name) {
        var ws = workspace.isFlyout ? workspace.targetWorkspace : workspace;
        opt_name = Blockly.Variables.generateUniqueName(ws)
    }
    if (potentialVariableMap) var variable = potentialVariableMap.createVariable(opt_name, opt_type, id);
    else var variable = workspace.createVariable(opt_name, opt_type, id);
    return variable
};
Blockly.Variables.getAddedVariables = function(workspace, originalVariables) {
    var allCurrentVariables = workspace.getAllVariables();
    var addedVariables = [];
    if (originalVariables.length != allCurrentVariables.length)
        for (var i = 0; i < allCurrentVariables.length; i++) {
            var variable = allCurrentVariables[i];
            if (originalVariables.indexOf(variable) == -1) addedVariables.push(variable)
        }
    return addedVariables
};
goog.provide("Blockly.VariablesDynamic");
goog.require("Blockly.Variables");
goog.require("Blockly.Blocks");
goog.require("Blockly.constants");
goog.require("Blockly.VariableModel");
goog.require("Blockly.Xml");
Blockly.VariablesDynamic.onCreateVariableButtonClick_String = function(button) {
    Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace(), null, "String")
};
Blockly.VariablesDynamic.onCreateVariableButtonClick_Number = function(button) {
    Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace(), null, "Number")
};
Blockly.VariablesDynamic.onCreateVariableButtonClick_Colour = function(button) {
    Blockly.Variables.createVariableButtonHandler(button.getTargetWorkspace(), null, "Colour")
};
Blockly.VariablesDynamic.flyoutCategory = function(workspace) {
    var xmlList = [];
    var button = document.createElement("button");
    button.setAttribute("text", Blockly.Msg["NEW_STRING_VARIABLE"]);
    button.setAttribute("callbackKey", "CREATE_VARIABLE_STRING");
    xmlList.push(button);
    button = document.createElement("button");
    button.setAttribute("text", Blockly.Msg["NEW_NUMBER_VARIABLE"]);
    button.setAttribute("callbackKey", "CREATE_VARIABLE_NUMBER");
    xmlList.push(button);
    button = document.createElement("button");
    button.setAttribute("text",
        Blockly.Msg["NEW_COLOUR_VARIABLE"]);
    button.setAttribute("callbackKey", "CREATE_VARIABLE_COLOUR");
    xmlList.push(button);
    workspace.registerButtonCallback("CREATE_VARIABLE_STRING", Blockly.VariablesDynamic.onCreateVariableButtonClick_String);
    workspace.registerButtonCallback("CREATE_VARIABLE_NUMBER", Blockly.VariablesDynamic.onCreateVariableButtonClick_Number);
    workspace.registerButtonCallback("CREATE_VARIABLE_COLOUR", Blockly.VariablesDynamic.onCreateVariableButtonClick_Colour);
    var blockList = Blockly.VariablesDynamic.flyoutCategoryBlocks(workspace);
    xmlList = xmlList.concat(blockList);
    return xmlList
};
Blockly.VariablesDynamic.flyoutCategoryBlocks = function(workspace) {
    var variableModelList = workspace.getAllVariables();
    variableModelList.sort(Blockly.VariableModel.compareByName);
    var xmlList = [];
    if (variableModelList.length > 0) {
        if (Blockly.Blocks["variables_set_dynamic"]) {
            var firstVariable = variableModelList[0];
            var gap = 24;
            var blockText = "<xml>" + '<block type="variables_set_dynamic" gap="' + gap + '">' + Blockly.Variables.generateVariableFieldXmlString(firstVariable) + "</block>" + "</xml>";
            var block = Blockly.Xml.textToDom(blockText).firstChild;
            xmlList.push(block)
        }
        if (Blockly.Blocks["variables_get_dynamic"])
            for (var i = 0, variable; variable = variableModelList[i]; i++) {
                var blockText = "<xml>" + '<block type="variables_get_dynamic" gap="8">' + Blockly.Variables.generateVariableFieldXmlString(variable) + "</block>" + "</xml>";
                var block = Blockly.Xml.textToDom(blockText).firstChild;
                xmlList.push(block)
            }
    }
    return xmlList
};
goog.provide("Blockly.Warning");
goog.require("Blockly.Bubble");
goog.require("Blockly.Events.Ui");
goog.require("Blockly.Icon");
goog.require("Blockly.utils");
Blockly.Warning = function(block) {
    Blockly.Warning.superClass_.constructor.call(this, block);
    this.createIcon();
    this.text_ = {}
};
goog.inherits(Blockly.Warning, Blockly.Icon);
Blockly.Warning.prototype.collapseHidden = false;
Blockly.Warning.prototype.drawIcon_ = function(group) {
    Blockly.utils.createSvgElement("path", {
        "class": "blocklyIconShape",
        "d": "M2,15Q-1,15 0.5,12L6.5,1.7Q8,-1 9.5,1.7L15.5,12Q17,15 14,15z"
    }, group);
    Blockly.utils.createSvgElement("path", {
        "class": "blocklyIconSymbol",
        "d": "m7,4.8v3.16l0.27,2.27h1.46l0.27,-2.27v-3.16z"
    }, group);
    Blockly.utils.createSvgElement("rect", {
        "class": "blocklyIconSymbol",
        "x": "7",
        "y": "11",
        "height": "2",
        "width": "2"
    }, group)
};
Blockly.Warning.textToDom_ = function(text) {
    var paragraph = Blockly.utils.createSvgElement("text", {
        "class": "blocklyText blocklyBubbleText",
        "y": Blockly.Bubble.BORDER_WIDTH
    }, null);
    var lines = text.split("\n");
    for (var i = 0; i < lines.length; i++) {
        var tspanElement = Blockly.utils.createSvgElement("tspan", {
            "dy": "1em",
            "x": Blockly.Bubble.BORDER_WIDTH
        }, paragraph);
        var textNode = document.createTextNode(lines[i]);
        tspanElement.appendChild(textNode)
    }
    return paragraph
};
Blockly.Warning.prototype.setVisible = function(visible) {
    if (visible == this.isVisible()) return;
    Blockly.Events.fire(new Blockly.Events.Ui(this.block_, "warningOpen", !visible, visible));
    if (visible) {
        var paragraph = Blockly.Warning.textToDom_(this.getText());
        this.bubble_ = new Blockly.Bubble(this.block_.workspace, paragraph, this.block_.svgPath_, this.iconXY_, null, null);
        this.bubble_.setSvgId(this.block_.id);
        if (this.block_.RTL) {
            var maxWidth = paragraph.getBBox().width;
            for (var i = 0, textElement; textElement = paragraph.childNodes[i]; i++) {
                textElement.setAttribute("text-anchor",
                    "end");
                textElement.setAttribute("x", maxWidth + Blockly.Bubble.BORDER_WIDTH)
            }
        }
        this.updateColour();
        var size = this.bubble_.getBubbleSize();
        this.bubble_.setBubbleSize(size.width, size.height)
    } else {
        this.bubble_.dispose();
        this.bubble_ = null;
        this.body_ = null
    }
};
Blockly.Warning.prototype.bodyFocus_ = function(_e) {
    this.bubble_.promote_()
};
Blockly.Warning.prototype.setText = function(text, id) {
    if (this.text_[id] == text) return;
    if (text) this.text_[id] = text;
    else delete this.text_[id];
    if (this.isVisible()) {
        this.setVisible(false);
        this.setVisible(true)
    }
};
Blockly.Warning.prototype.getText = function() {
    var allWarnings = [];
    for (var id in this.text_) allWarnings.push(this.text_[id]);
    return allWarnings.join("\n")
};
Blockly.Warning.prototype.dispose = function() {
    this.block_.warning = null;
    Blockly.Icon.prototype.dispose.call(this)
};
goog.provide("Blockly.WidgetDiv");
goog.require("Blockly.Css");
goog.require("goog.style");
Blockly.WidgetDiv.DIV = null;
Blockly.WidgetDiv.owner_ = null;
Blockly.WidgetDiv.dispose_ = null;
Blockly.WidgetDiv.createDom = function() {
    if (Blockly.WidgetDiv.DIV) return;
    Blockly.WidgetDiv.DIV = document.createElement("div");
    Blockly.WidgetDiv.DIV.className = "blocklyWidgetDiv";
    document.body.appendChild(Blockly.WidgetDiv.DIV)
};
Blockly.WidgetDiv.show = function(newOwner, rtl, dispose) {
    Blockly.WidgetDiv.hide();
    Blockly.WidgetDiv.owner_ = newOwner;
    Blockly.WidgetDiv.dispose_ = dispose;
    var xy = goog.style.getViewportPageOffset(document);
    Blockly.WidgetDiv.DIV.style.top = xy.y + "px";
    Blockly.WidgetDiv.DIV.style.direction = rtl ? "rtl" : "ltr";
    Blockly.WidgetDiv.DIV.style.display = "block"
};
Blockly.WidgetDiv.hide = function() {
    if (Blockly.WidgetDiv.owner_) {
        Blockly.WidgetDiv.owner_ = null;
        Blockly.WidgetDiv.DIV.style.display = "none";
        Blockly.WidgetDiv.DIV.style.left = "";
        Blockly.WidgetDiv.DIV.style.top = "";
        Blockly.WidgetDiv.dispose_ && Blockly.WidgetDiv.dispose_();
        Blockly.WidgetDiv.dispose_ = null;
        Blockly.WidgetDiv.DIV.innerHTML = ""
    }
};
Blockly.WidgetDiv.isVisible = function() {
    return !!Blockly.WidgetDiv.owner_
};
Blockly.WidgetDiv.hideIfOwner = function(oldOwner) {
    if (Blockly.WidgetDiv.owner_ == oldOwner) Blockly.WidgetDiv.hide()
};
Blockly.WidgetDiv.position = function(anchorX, anchorY, windowSize, scrollOffset, rtl) {
    if (anchorY < scrollOffset.y) anchorY = scrollOffset.y;
    if (rtl) {
        if (anchorX > windowSize.width + scrollOffset.x) anchorX = windowSize.width + scrollOffset.x
    } else if (anchorX < scrollOffset.x) anchorX = scrollOffset.x;
    Blockly.WidgetDiv.positionInternal_(anchorX, anchorY, windowSize.height)
};
Blockly.WidgetDiv.positionInternal_ = function(x, y, height) {
    Blockly.WidgetDiv.DIV.style.left = x + "px";
    Blockly.WidgetDiv.DIV.style.top = y + "px";
    Blockly.WidgetDiv.DIV.style.height = height + "px"
};
Blockly.WidgetDiv.positionWithAnchor = function(viewportBBox, anchorBBox, widgetSize, rtl) {
    var y = Blockly.WidgetDiv.calculateY_(viewportBBox, anchorBBox, widgetSize);
    var x = Blockly.WidgetDiv.calculateX_(viewportBBox, anchorBBox, widgetSize, rtl);
    Blockly.WidgetDiv.positionInternal_(x, y, widgetSize.height)
};
Blockly.WidgetDiv.calculateX_ = function(viewportBBox, anchorBBox, widgetSize, rtl) {
    if (rtl) {
        var widgetLeft = anchorBBox.right - widgetSize.width;
        var x = Math.max(widgetLeft, viewportBBox.left);
        return Math.min(x, viewportBBox.right - widgetSize.width)
    } else {
        var x = Math.min(anchorBBox.left, viewportBBox.right - widgetSize.width);
        return Math.max(x, viewportBBox.left)
    }
};
Blockly.WidgetDiv.calculateY_ = function(viewportBBox, anchorBBox, widgetSize) {
    if (anchorBBox.bottom + widgetSize.height >= viewportBBox.bottom) return anchorBBox.top - widgetSize.height;
    else return anchorBBox.bottom
};
goog.provide("Blockly.Workspace");
goog.require("Blockly.utils");
goog.require("Blockly.VariableMap");
goog.require("Blockly.WorkspaceComment");
Blockly.Workspace = function(opt_options) {
    this.id = Blockly.utils.genUid();
    Blockly.Workspace.WorkspaceDB_[this.id] = this;
    this.options = opt_options || {};
    this.RTL = !!this.options.RTL;
    this.horizontalLayout = !!this.options.horizontalLayout;
    this.toolboxPosition = this.options.toolboxPosition;
    this.topBlocks_ = [];
    this.topComments_ = [];
    this.commentDB_ = Object.create(null);
    this.listeners_ = [];
    this.undoStack_ = [];
    this.redoStack_ = [];
    this.blockDB_ = Object.create(null);
    this.variableMap_ = new Blockly.VariableMap(this);
    this.potentialVariableMap_ =
        null
};
Blockly.Workspace.prototype.rendered = false;
Blockly.Workspace.prototype.isClearing = false;
Blockly.Workspace.prototype.MAX_UNDO = 1024;
Blockly.Workspace.prototype.dispose = function() {
    this.listeners_.length = 0;
    this.clear();
    delete Blockly.Workspace.WorkspaceDB_[this.id]
};
Blockly.Workspace.SCAN_ANGLE = 3;
Blockly.Workspace.prototype.addTopBlock = function(block) {
    this.topBlocks_.push(block)
};
Blockly.Workspace.prototype.removeTopBlock = function(block) {
    if (!Blockly.utils.arrayRemove(this.topBlocks_, block)) throw Error("Block not present in workspace's list of top-most blocks.");
};
Blockly.Workspace.prototype.getTopBlocks = function(ordered) {
    var blocks = [].concat(this.topBlocks_);
    if (ordered && blocks.length > 1) {
        var offset = Math.sin(Blockly.utils.toRadians(Blockly.Workspace.SCAN_ANGLE));
        if (this.RTL) offset *= -1;
        blocks.sort(function(a, b) {
            var aXY = a.getRelativeToSurfaceXY();
            var bXY = b.getRelativeToSurfaceXY();
            return aXY.y + offset * aXY.x - (bXY.y + offset * bXY.x)
        })
    }
    return blocks
};
Blockly.Workspace.prototype.addTopComment = function(comment) {
    this.topComments_.push(comment);
    if (this.commentDB_[comment.id]) console.warn('Overriding an existing comment on this workspace, with id "' + comment.id + '"');
    this.commentDB_[comment.id] = comment
};
Blockly.Workspace.prototype.removeTopComment = function(comment) {
    if (!Blockly.utils.arrayRemove(this.topComments_, comment)) throw Error("Comment not present in workspace's list of top-most " + "comments.");
    delete this.commentDB_[comment.id]
};
Blockly.Workspace.prototype.getTopComments = function(ordered) {
    var comments = [].concat(this.topComments_);
    if (ordered && comments.length > 1) {
        var offset = Math.sin(Blockly.utils.toRadians(Blockly.Workspace.SCAN_ANGLE));
        if (this.RTL) offset *= -1;
        comments.sort(function(a, b) {
            var aXY = a.getRelativeToSurfaceXY();
            var bXY = b.getRelativeToSurfaceXY();
            return aXY.y + offset * aXY.x - (bXY.y + offset * bXY.x)
        })
    }
    return comments
};
Blockly.Workspace.prototype.getAllBlocks = function(ordered) {
    if (ordered) {
        var topBlocks = this.getTopBlocks(true);
        var blocks = [];
        for (var i = 0; i < topBlocks.length; i++) blocks.push.apply(blocks, topBlocks[i].getDescendants(true))
    } else {
        var blocks = this.getTopBlocks(false);
        for (var i = 0; i < blocks.length; i++) blocks.push.apply(blocks, blocks[i].getChildren(false))
    }
    return blocks
};
Blockly.Workspace.prototype.clear = function() {
    this.isClearing = true;
    try {
        var existingGroup = Blockly.Events.getGroup();
        if (!existingGroup) Blockly.Events.setGroup(true);
        while (this.topBlocks_.length) this.topBlocks_[0].dispose();
        while (this.topComments_.length) this.topComments_[this.topComments_.length - 1].dispose();
        if (!existingGroup) Blockly.Events.setGroup(false);
        this.variableMap_.clear();
        if (this.potentialVariableMap_) this.potentialVariableMap_.clear()
    } finally {
        this.isClearing = false
    }
};
Blockly.Workspace.prototype.renameVariableById = function(id, newName) {
    this.variableMap_.renameVariableById(id, newName)
};
Blockly.Workspace.prototype.createVariable = function(name, opt_type, opt_id) {
    return this.variableMap_.createVariable(name, opt_type, opt_id)
};
Blockly.Workspace.prototype.getVariableUsesById = function(id) {
    return this.variableMap_.getVariableUsesById(id)
};
Blockly.Workspace.prototype.deleteVariableById = function(id) {
    this.variableMap_.deleteVariableById(id)
};
Blockly.Workspace.prototype.deleteVariableInternal_ = function(variable, uses) {
    this.variableMap_.deleteVariableInternal_(variable, uses)
};
Blockly.Workspace.prototype.variableIndexOf = function(_name) {
    console.warn("Deprecated call to Blockly.Workspace.prototype.variableIndexOf");
    return -1
};
Blockly.Workspace.prototype.getVariable = function(name, opt_type) {
    return this.variableMap_.getVariable(name, opt_type)
};
Blockly.Workspace.prototype.getVariableById = function(id) {
    return this.variableMap_.getVariableById(id)
};
Blockly.Workspace.prototype.getVariablesOfType = function(type) {
    return this.variableMap_.getVariablesOfType(type)
};
Blockly.Workspace.prototype.getVariableTypes = function() {
    return this.variableMap_.getVariableTypes()
};
Blockly.Workspace.prototype.getAllVariables = function() {
    return this.variableMap_.getAllVariables()
};
Blockly.Workspace.prototype.getWidth = function() {
    return 0
};
Blockly.Workspace.prototype.newBlock = function(prototypeName, opt_id) {
    return new Blockly.Block(this, prototypeName, opt_id)
};
Blockly.Workspace.prototype.remainingCapacity = function() {
    if (isNaN(this.options.maxBlocks)) return Infinity;
    return this.options.maxBlocks - this.getAllBlocks().length
};
Blockly.Workspace.prototype.undo = function(redo) {
    var inputStack = redo ? this.redoStack_ : this.undoStack_;
    var outputStack = redo ? this.undoStack_ : this.redoStack_;
    var inputEvent = inputStack.pop();
    if (!inputEvent) return;
    var events = [inputEvent];
    while (inputStack.length && inputEvent.group && inputEvent.group == inputStack[inputStack.length - 1].group) events.push(inputStack.pop());
    for (var i = 0, event; event = events[i]; i++) outputStack.push(event);
    events = Blockly.Events.filter(events, redo);
    Blockly.Events.recordUndo = false;
    try {
        for (var i =
                0, event; event = events[i]; i++) event.run(redo)
    } finally {
        Blockly.Events.recordUndo = true
    }
};
Blockly.Workspace.prototype.clearUndo = function() {
    this.undoStack_.length = 0;
    this.redoStack_.length = 0;
    Blockly.Events.clearPendingUndo()
};
Blockly.Workspace.prototype.addChangeListener = function(func) {
    this.listeners_.push(func);
    return func
};
Blockly.Workspace.prototype.removeChangeListener = function(func) {
    Blockly.utils.arrayRemove(this.listeners_, func)
};
Blockly.Workspace.prototype.fireChangeListener = function(event) {
    if (event.recordUndo) {
        this.undoStack_.push(event);
        this.redoStack_.length = 0;
        while (this.undoStack_.length > this.MAX_UNDO && this.MAX_UNDO >= 0) this.undoStack_.shift()
    }
    for (var i = 0, func; func = this.listeners_[i]; i++) func(event)
};
Blockly.Workspace.prototype.getBlockById = function(id) {
    return this.blockDB_[id] || null
};
Blockly.Workspace.prototype.getCommentById = function(id) {
    return this.commentDB_[id] || null
};
Blockly.Workspace.prototype.allInputsFilled = function(opt_shadowBlocksAreFilled) {
    var blocks = this.getTopBlocks(false);
    for (var i = 0, block; block = blocks[i]; i++)
        if (!block.allInputsFilled(opt_shadowBlocksAreFilled)) return false;
    return true
};
Blockly.Workspace.prototype.getPotentialVariableMap = function() {
    return this.potentialVariableMap_
};
Blockly.Workspace.prototype.createPotentialVariableMap = function() {
    this.potentialVariableMap_ = new Blockly.VariableMap(this)
};
Blockly.Workspace.prototype.getVariableMap = function() {
    return this.variableMap_
};
Blockly.Workspace.WorkspaceDB_ = Object.create(null);
Blockly.Workspace.getById = function(id) {
    return Blockly.Workspace.WorkspaceDB_[id] || null
};
Blockly.Workspace.prototype["clear"] = Blockly.Workspace.prototype.clear;
Blockly.Workspace.prototype["clearUndo"] = Blockly.Workspace.prototype.clearUndo;
Blockly.Workspace.prototype["addChangeListener"] = Blockly.Workspace.prototype.addChangeListener;
Blockly.Workspace.prototype["removeChangeListener"] = Blockly.Workspace.prototype.removeChangeListener;
goog.provide("Blockly.WorkspaceAudio");
goog.require("goog.userAgent");
Blockly.WorkspaceAudio = function(parentWorkspace) {
    this.parentWorkspace_ = parentWorkspace;
    this.SOUNDS_ = Object.create(null)
};
Blockly.WorkspaceAudio.prototype.lastSound_ = null;
Blockly.WorkspaceAudio.prototype.dispose = function() {
    this.parentWorkspace_ = null;
    this.SOUNDS_ = null
};
Blockly.WorkspaceAudio.prototype.load = function(filenames, name) {
    if (!filenames.length) return;
    try {
        var audioTest = new window["Audio"]
    } catch (e) {
        return
    }
    var sound;
    for (var i = 0; i < filenames.length; i++) {
        var filename = filenames[i];
        var ext = filename.match(/\.(\w+)$/);
        if (ext && audioTest.canPlayType("audio/" + ext[1])) {
            sound = new window["Audio"](filename);
            break
        }
    }
    if (sound && sound.play) this.SOUNDS_[name] = sound
};
Blockly.WorkspaceAudio.prototype.preload = function() {
    for (var name in this.SOUNDS_) {
        var sound = this.SOUNDS_[name];
        sound.volume = .01;
        sound.play();
        sound.pause();
        if (goog.userAgent.IPAD || goog.userAgent.IPHONE) break
    }
};
Blockly.WorkspaceAudio.prototype.play = function(name, opt_volume) {
    var sound = this.SOUNDS_[name];
    if (sound) {
        var now = new Date;
        if (this.lastSound_ != null && now - this.lastSound_ < Blockly.SOUND_LIMIT) return;
        this.lastSound_ = now;
        var mySound;
        var ie9 = goog.userAgent.DOCUMENT_MODE && goog.userAgent.DOCUMENT_MODE === 9;
        if (ie9 || goog.userAgent.IPAD || goog.userAgent.ANDROID) mySound = sound;
        else mySound = sound.cloneNode();
        mySound.volume = opt_volume === undefined ? 1 : opt_volume;
        mySound.play()
    } else if (this.parentWorkspace_) this.parentWorkspace_.getAudioManager().play(name,
        opt_volume)
};
goog.provide("Blockly.WorkspaceComment");
goog.require("Blockly.Events.CommentChange");
goog.require("Blockly.Events.CommentCreate");
goog.require("Blockly.Events.CommentDelete");
goog.require("Blockly.Events.CommentMove");
goog.require("Blockly.utils");
goog.require("Blockly.Xml.utils");
goog.require("goog.math.Coordinate");
Blockly.WorkspaceComment = function(workspace, content, height, width, opt_id) {
    this.id = opt_id && !workspace.getCommentById(opt_id) ? opt_id : Blockly.utils.genUid();
    workspace.addTopComment(this);
    this.xy_ = new goog.math.Coordinate(0, 0);
    this.height_ = height;
    this.width_ = width;
    this.workspace = workspace;
    this.RTL = workspace.RTL;
    this.deletable_ = true;
    this.movable_ = true;
    this.content_ = content;
    this.isComment = true;
    Blockly.WorkspaceComment.fireCreateEvent(this)
};
Blockly.WorkspaceComment.prototype.dispose = function() {
    if (!this.workspace) return;
    if (Blockly.Events.isEnabled()) Blockly.Events.fire(new Blockly.Events.CommentDelete(this));
    this.workspace.removeTopComment(this);
    this.workspace = null
};
Blockly.WorkspaceComment.prototype.getHeight = function() {
    return this.height_
};
Blockly.WorkspaceComment.prototype.setHeight = function(height) {
    this.height_ = height
};
Blockly.WorkspaceComment.prototype.getWidth = function() {
    return this.width_
};
Blockly.WorkspaceComment.prototype.setWidth = function(width) {
    this.width_ = width
};
Blockly.WorkspaceComment.prototype.getXY = function() {
    return this.xy_.clone()
};
Blockly.WorkspaceComment.prototype.moveBy = function(dx, dy) {
    var event = new Blockly.Events.CommentMove(this);
    this.xy_.translate(dx, dy);
    event.recordNew();
    Blockly.Events.fire(event)
};
Blockly.WorkspaceComment.prototype.isDeletable = function() {
    return this.deletable_ && !(this.workspace && this.workspace.options.readOnly)
};
Blockly.WorkspaceComment.prototype.setDeletable = function(deletable) {
    this.deletable_ = deletable
};
Blockly.WorkspaceComment.prototype.isMovable = function() {
    return this.movable_ && !(this.workspace && this.workspace.options.readOnly)
};
Blockly.WorkspaceComment.prototype.setMovable = function(movable) {
    this.movable_ = movable
};
Blockly.WorkspaceComment.prototype.getContent = function() {
    return this.content_
};
Blockly.WorkspaceComment.prototype.setContent = function(content) {
    if (this.content_ != content) {
        Blockly.Events.fire(new Blockly.Events.CommentChange(this, this.content_, content));
        this.content_ = content
    }
};
Blockly.WorkspaceComment.prototype.toXmlWithXY = function(opt_noId) {
    var element = this.toXml(opt_noId);
    element.setAttribute("x", Math.round(this.xy_.x));
    element.setAttribute("y", Math.round(this.xy_.y));
    element.setAttribute("h", this.height_);
    element.setAttribute("w", this.width_);
    return element
};
Blockly.WorkspaceComment.prototype.toXml = function(opt_noId) {
    var commentElement = Blockly.Xml.utils.createElement("comment");
    if (!opt_noId) commentElement.setAttribute("id", this.id);
    commentElement.textContent = this.getContent();
    return commentElement
};
Blockly.WorkspaceComment.fireCreateEvent = function(comment) {
    if (Blockly.Events.isEnabled()) {
        var existingGroup = Blockly.Events.getGroup();
        if (!existingGroup) Blockly.Events.setGroup(true);
        try {
            Blockly.Events.fire(new Blockly.Events.CommentCreate(comment))
        } finally {
            if (!existingGroup) Blockly.Events.setGroup(false)
        }
    }
};
Blockly.WorkspaceComment.fromXml = function(xmlComment, workspace) {
    var info = Blockly.WorkspaceComment.parseAttributes(xmlComment);
    var comment = new Blockly.WorkspaceComment(workspace, info.content, info.h, info.w, info.id);
    var commentX = parseInt(xmlComment.getAttribute("x"), 10);
    var commentY = parseInt(xmlComment.getAttribute("y"), 10);
    if (!isNaN(commentX) && !isNaN(commentY)) comment.moveBy(commentX, commentY);
    Blockly.WorkspaceComment.fireCreateEvent(comment);
    return comment
};
Blockly.WorkspaceComment.parseAttributes = function(xml) {
    var xmlH = xml.getAttribute("h");
    var xmlW = xml.getAttribute("w");
    return {
        id: xml.getAttribute("id"),
        h: xmlH ? parseInt(xmlH, 10) : 100,
        w: xmlW ? parseInt(xmlW, 10) : 100,
        x: parseInt(xml.getAttribute("x"), 10),
        y: parseInt(xml.getAttribute("y"), 10),
        content: xml.textContent
    }
};
goog.provide("Blockly.WorkspaceCommentSvg.render");
goog.require("Blockly.utils");
goog.require("Blockly.WorkspaceCommentSvg");
goog.require("goog.math.Coordinate");
Blockly.WorkspaceCommentSvg.RESIZE_SIZE = 8;
Blockly.WorkspaceCommentSvg.BORDER_RADIUS = 3;
Blockly.WorkspaceCommentSvg.TEXTAREA_OFFSET = 2;
Blockly.WorkspaceCommentSvg.TOP_OFFSET = 10;
Blockly.WorkspaceCommentSvg.prototype.getHeightWidth = function() {
    return {
        width: this.getWidth(),
        height: this.getHeight()
    }
};
Blockly.WorkspaceCommentSvg.prototype.render = function() {
    if (this.rendered_) return;
    var size = this.getHeightWidth();
    this.createEditor_();
    this.svgGroup_.appendChild(this.foreignObject_);
    this.svgHandleTarget_ = Blockly.utils.createSvgElement("rect", {
        "class": "blocklyCommentHandleTarget",
        "x": 0,
        "y": 0
    });
    this.svgGroup_.appendChild(this.svgHandleTarget_);
    this.svgRectTarget_ = Blockly.utils.createSvgElement("rect", {
        "class": "blocklyCommentTarget",
        "x": 0,
        "y": 0,
        "rx": Blockly.WorkspaceCommentSvg.BORDER_RADIUS,
        "ry": Blockly.WorkspaceCommentSvg.BORDER_RADIUS
    });
    this.svgGroup_.appendChild(this.svgRectTarget_);
    this.addResizeDom_();
    if (this.isDeletable()) this.addDeleteDom_();
    this.setSize_(size.width, size.height);
    this.textarea_.value = this.content_;
    this.rendered_ = true;
    if (this.resizeGroup_) Blockly.bindEventWithChecks_(this.resizeGroup_, "mousedown", this, this.resizeMouseDown_);
    if (this.isDeletable()) {
        Blockly.bindEventWithChecks_(this.deleteGroup_, "mousedown", this, this.deleteMouseDown_);
        Blockly.bindEventWithChecks_(this.deleteGroup_, "mouseout", this, this.deleteMouseOut_);
        Blockly.bindEventWithChecks_(this.deleteGroup_, "mouseup", this, this.deleteMouseUp_)
    }
};
Blockly.WorkspaceCommentSvg.prototype.createEditor_ = function() {
    this.foreignObject_ = Blockly.utils.createSvgElement("foreignObject", {
        "x": 0,
        "y": Blockly.WorkspaceCommentSvg.TOP_OFFSET,
        "class": "blocklyCommentForeignObject"
    }, null);
    var body = document.createElementNS(Blockly.HTML_NS, "body");
    body.setAttribute("xmlns", Blockly.HTML_NS);
    body.className = "blocklyMinimalBody";
    var textarea = document.createElementNS(Blockly.HTML_NS, "textarea");
    textarea.className = "blocklyCommentTextarea";
    textarea.setAttribute("dir", this.RTL ?
        "RTL" : "LTR");
    body.appendChild(textarea);
    this.textarea_ = textarea;
    this.foreignObject_.appendChild(body);
    Blockly.bindEventWithChecks_(textarea, "wheel", this, function(e) {
        e.stopPropagation()
    });
    Blockly.bindEventWithChecks_(textarea, "change", this, function(e) {
        this.setContent(textarea.value)
    });
    return this.foreignObject_
};
Blockly.WorkspaceCommentSvg.prototype.addResizeDom_ = function() {
    this.resizeGroup_ = Blockly.utils.createSvgElement("g", {
        "class": this.RTL ? "blocklyResizeSW" : "blocklyResizeSE"
    }, this.svgGroup_);
    var resizeSize = Blockly.WorkspaceCommentSvg.RESIZE_SIZE;
    Blockly.utils.createSvgElement("polygon", {
        "points": "0,x x,x x,0".replace(/x/g, resizeSize.toString())
    }, this.resizeGroup_);
    Blockly.utils.createSvgElement("line", {
            "class": "blocklyResizeLine",
            "x1": resizeSize / 3,
            "y1": resizeSize - 1,
            "x2": resizeSize - 1,
            "y2": resizeSize / 3
        },
        this.resizeGroup_);
    Blockly.utils.createSvgElement("line", {
        "class": "blocklyResizeLine",
        "x1": resizeSize * 2 / 3,
        "y1": resizeSize - 1,
        "x2": resizeSize - 1,
        "y2": resizeSize * 2 / 3
    }, this.resizeGroup_)
};
Blockly.WorkspaceCommentSvg.prototype.addDeleteDom_ = function() {
    this.deleteGroup_ = Blockly.utils.createSvgElement("g", {
        "class": "blocklyCommentDeleteIcon"
    }, this.svgGroup_);
    this.deleteIconBorder_ = Blockly.utils.createSvgElement("circle", {
        "class": "blocklyDeleteIconShape",
        "r": "7",
        "cx": "7.5",
        "cy": "7.5"
    }, this.deleteGroup_);
    Blockly.utils.createSvgElement("line", {
        "x1": "5",
        "y1": "10",
        "x2": "10",
        "y2": "5",
        "stroke": "#fff",
        "stroke-width": "2"
    }, this.deleteGroup_);
    Blockly.utils.createSvgElement("line", {
        "x1": "5",
        "y1": "5",
        "x2": "10",
        "y2": "10",
        "stroke": "#fff",
        "stroke-width": "2"
    }, this.deleteGroup_)
};
Blockly.WorkspaceCommentSvg.prototype.resizeMouseDown_ = function(e) {
    this.unbindDragEvents_();
    if (Blockly.utils.isRightButton(e)) {
        e.stopPropagation();
        return
    }
    this.workspace.startDrag(e, new goog.math.Coordinate(this.workspace.RTL ? -this.width_ : this.width_, this.height_));
    this.onMouseUpWrapper_ = Blockly.bindEventWithChecks_(document, "mouseup", this, this.resizeMouseUp_);
    this.onMouseMoveWrapper_ = Blockly.bindEventWithChecks_(document, "mousemove", this, this.resizeMouseMove_);
    Blockly.hideChaff();
    e.stopPropagation()
};
Blockly.WorkspaceCommentSvg.prototype.deleteMouseDown_ = function(e) {
    Blockly.utils.addClass(this.deleteIconBorder_, "blocklyDeleteIconHighlighted");
    e.stopPropagation()
};
Blockly.WorkspaceCommentSvg.prototype.deleteMouseOut_ = function() {
    Blockly.utils.removeClass(this.deleteIconBorder_, "blocklyDeleteIconHighlighted")
};
Blockly.WorkspaceCommentSvg.prototype.deleteMouseUp_ = function(e) {
    this.dispose(true, true);
    e.stopPropagation()
};
Blockly.WorkspaceCommentSvg.prototype.unbindDragEvents_ = function() {
    if (this.onMouseUpWrapper_) {
        Blockly.unbindEvent_(this.onMouseUpWrapper_);
        this.onMouseUpWrapper_ = null
    }
    if (this.onMouseMoveWrapper_) {
        Blockly.unbindEvent_(this.onMouseMoveWrapper_);
        this.onMouseMoveWrapper_ = null
    }
};
Blockly.WorkspaceCommentSvg.prototype.resizeMouseUp_ = function() {
    Blockly.Touch.clearTouchIdentifier();
    this.unbindDragEvents_()
};
Blockly.WorkspaceCommentSvg.prototype.resizeMouseMove_ = function(e) {
    this.autoLayout_ = false;
    var newXY = this.workspace.moveDrag(e);
    this.setSize_(this.RTL ? -newXY.x : newXY.x, newXY.y)
};
Blockly.WorkspaceCommentSvg.prototype.resizeComment_ = function() {
    var size = this.getHeightWidth();
    var topOffset = Blockly.WorkspaceCommentSvg.TOP_OFFSET;
    var textOffset = Blockly.WorkspaceCommentSvg.TEXTAREA_OFFSET * 2;
    this.foreignObject_.setAttribute("width", size.width);
    this.foreignObject_.setAttribute("height", size.height - topOffset);
    if (this.RTL) this.foreignObject_.setAttribute("x", -size.width);
    this.textarea_.style.width = size.width - textOffset + "px";
    this.textarea_.style.height = size.height - textOffset - topOffset +
        "px"
};
Blockly.WorkspaceCommentSvg.prototype.setSize_ = function(width, height) {
    width = Math.max(width, 45);
    height = Math.max(height, 20 + Blockly.WorkspaceCommentSvg.TOP_OFFSET);
    this.width_ = width;
    this.height_ = height;
    this.svgRect_.setAttribute("width", width);
    this.svgRect_.setAttribute("height", height);
    this.svgRectTarget_.setAttribute("width", width);
    this.svgRectTarget_.setAttribute("height", height);
    this.svgHandleTarget_.setAttribute("width", width);
    this.svgHandleTarget_.setAttribute("height", Blockly.WorkspaceCommentSvg.TOP_OFFSET);
    if (this.RTL) {
        this.svgRect_.setAttribute("transform",
            "scale(-1 1)");
        this.svgRectTarget_.setAttribute("transform", "scale(-1 1)")
    }
    var resizeSize = Blockly.WorkspaceCommentSvg.RESIZE_SIZE;
    if (this.resizeGroup_)
        if (this.RTL) {
            this.resizeGroup_.setAttribute("transform", "translate(" + (-width + resizeSize) + "," + (height - resizeSize) + ") scale(-1 1)");
            this.deleteGroup_.setAttribute("transform", "translate(" + (-width + resizeSize) + "," + -resizeSize + ") scale(-1 1)")
        } else {
            this.resizeGroup_.setAttribute("transform", "translate(" + (width - resizeSize) + "," + (height - resizeSize) + ")");
            this.deleteGroup_.setAttribute("transform",
                "translate(" + (width - resizeSize) + "," + -resizeSize + ")")
        } this.resizeComment_()
};
Blockly.WorkspaceCommentSvg.prototype.disposeInternal_ = function() {
    this.textarea_ = null;
    this.foreignObject_ = null;
    this.svgRectTarget_ = null;
    this.svgHandleTarget_ = null
};
Blockly.WorkspaceCommentSvg.prototype.setFocus = function() {
    var comment = this;
    this.focused_ = true;
    setTimeout(function() {
        comment.textarea_.focus();
        comment.addFocus();
        Blockly.utils.addClass(comment.svgRectTarget_, "blocklyCommentTargetFocused");
        Blockly.utils.addClass(comment.svgHandleTarget_, "blocklyCommentHandleTargetFocused")
    }, 0)
};
Blockly.WorkspaceCommentSvg.prototype.blurFocus = function() {
    var comment = this;
    this.focused_ = false;
    setTimeout(function() {
        comment.textarea_.blur();
        comment.removeFocus();
        Blockly.utils.removeClass(comment.svgRectTarget_, "blocklyCommentTargetFocused");
        Blockly.utils.removeClass(comment.svgHandleTarget_, "blocklyCommentHandleTargetFocused")
    }, 0)
};
goog.provide("Blockly.WorkspaceCommentSvg");
goog.require("Blockly.Events.CommentCreate");
goog.require("Blockly.Events.CommentDelete");
goog.require("Blockly.Events.CommentMove");
goog.require("Blockly.utils");
goog.require("Blockly.WorkspaceComment");
goog.require("goog.math.Coordinate");
Blockly.WorkspaceCommentSvg = function(workspace, content, height, width, opt_id) {
    this.svgGroup_ = Blockly.utils.createSvgElement("g", {
        "class": "blocklyComment"
    }, null);
    this.svgGroup_.translate_ = "";
    this.svgRect_ = Blockly.utils.createSvgElement("rect", {
        "class": "blocklyCommentRect",
        "x": 0,
        "y": 0,
        "rx": Blockly.WorkspaceCommentSvg.BORDER_RADIUS,
        "ry": Blockly.WorkspaceCommentSvg.BORDER_RADIUS
    });
    this.svgGroup_.appendChild(this.svgRect_);
    this.rendered_ = false;
    this.useDragSurface_ = Blockly.utils.is3dSupported() && !!workspace.blockDragSurface_;
    Blockly.WorkspaceCommentSvg.superClass_.constructor.call(this, workspace, content, height, width, opt_id);
    this.render()
};
goog.inherits(Blockly.WorkspaceCommentSvg, Blockly.WorkspaceComment);
Blockly.WorkspaceCommentSvg.DEFAULT_SIZE = 100;
Blockly.WorkspaceCommentSvg.prototype.dispose = function() {
    if (!this.workspace) return;
    if (Blockly.selected == this) {
        this.unselect();
        this.workspace.cancelCurrentGesture()
    }
    if (Blockly.Events.isEnabled()) Blockly.Events.fire(new Blockly.Events.CommentDelete(this));
    Blockly.utils.removeNode(this.svgGroup_);
    this.svgGroup_ = null;
    this.svgRect_ = null;
    this.disposeInternal_();
    Blockly.Events.disable();
    Blockly.WorkspaceCommentSvg.superClass_.dispose.call(this);
    Blockly.Events.enable()
};
Blockly.WorkspaceCommentSvg.prototype.initSvg = function() {
    if (!this.workspace.rendered) throw TypeError("Workspace is headless.");
    if (!this.workspace.options.readOnly && !this.eventsInit_) {
        Blockly.bindEventWithChecks_(this.svgRectTarget_, "mousedown", this, this.pathMouseDown_);
        Blockly.bindEventWithChecks_(this.svgHandleTarget_, "mousedown", this, this.pathMouseDown_)
    }
    this.eventsInit_ = true;
    this.updateMovable();
    if (!this.getSvgRoot().parentNode) this.workspace.getBubbleCanvas().appendChild(this.getSvgRoot())
};
Blockly.WorkspaceCommentSvg.prototype.pathMouseDown_ = function(e) {
    var gesture = this.workspace.getGesture(e);
    if (gesture) gesture.handleBubbleStart(e, this)
};
Blockly.WorkspaceCommentSvg.prototype.showContextMenu_ = function(e) {
    if (this.workspace.options.readOnly) return;
    var comment = this;
    var menuOptions = [];
    if (this.isDeletable() && this.isMovable()) {
        menuOptions.push(Blockly.ContextMenu.commentDuplicateOption(comment));
        menuOptions.push(Blockly.ContextMenu.commentDeleteOption(comment))
    }
    Blockly.ContextMenu.show(e, menuOptions, this.RTL)
};
Blockly.WorkspaceCommentSvg.prototype.select = function() {
    if (Blockly.selected == this) return;
    var oldId = null;
    if (Blockly.selected) {
        oldId = Blockly.selected.id;
        Blockly.Events.disable();
        try {
            Blockly.selected.unselect()
        } finally {
            Blockly.Events.enable()
        }
    }
    var event = new Blockly.Events.Ui(null, "selected", oldId, this.id);
    event.workspaceId = this.workspace.id;
    Blockly.Events.fire(event);
    Blockly.selected = this;
    this.addSelect()
};
Blockly.WorkspaceCommentSvg.prototype.unselect = function() {
    if (Blockly.selected != this) return;
    var event = new Blockly.Events.Ui(null, "selected", this.id, null);
    event.workspaceId = this.workspace.id;
    Blockly.Events.fire(event);
    Blockly.selected = null;
    this.removeSelect();
    this.blurFocus()
};
Blockly.WorkspaceCommentSvg.prototype.addSelect = function() {
    Blockly.utils.addClass(this.svgGroup_, "blocklySelected");
    this.setFocus()
};
Blockly.WorkspaceCommentSvg.prototype.removeSelect = function() {
    Blockly.utils.removeClass(this.svgGroup_, "blocklySelected");
    this.blurFocus()
};
Blockly.WorkspaceCommentSvg.prototype.addFocus = function() {
    Blockly.utils.addClass(this.svgGroup_, "blocklyFocused")
};
Blockly.WorkspaceCommentSvg.prototype.removeFocus = function() {
    Blockly.utils.removeClass(this.svgGroup_, "blocklyFocused")
};
Blockly.WorkspaceCommentSvg.prototype.getRelativeToSurfaceXY = function() {
    var x = 0;
    var y = 0;
    var dragSurfaceGroup = this.useDragSurface_ ? this.workspace.blockDragSurface_.getGroup() : null;
    var element = this.getSvgRoot();
    if (element) {
        do {
            var xy = Blockly.utils.getRelativeXY(element);
            x += xy.x;
            y += xy.y;
            if (this.useDragSurface_ && this.workspace.blockDragSurface_.getCurrentBlock() == element) {
                var surfaceTranslation = this.workspace.blockDragSurface_.getSurfaceTranslation();
                x += surfaceTranslation.x;
                y += surfaceTranslation.y
            }
            element =
                element.parentNode
        } while (element && element != this.workspace.getBubbleCanvas() && element != dragSurfaceGroup)
    }
    this.xy_ = new goog.math.Coordinate(x, y);
    return this.xy_
};
Blockly.WorkspaceCommentSvg.prototype.moveBy = function(dx, dy) {
    var event = new Blockly.Events.CommentMove(this);
    var xy = this.getRelativeToSurfaceXY();
    this.translate(xy.x + dx, xy.y + dy);
    this.xy_ = new goog.math.Coordinate(xy.x + dx, xy.y + dy);
    event.recordNew();
    Blockly.Events.fire(event);
    this.workspace.resizeContents()
};
Blockly.WorkspaceCommentSvg.prototype.translate = function(x, y) {
    this.xy_ = new goog.math.Coordinate(x, y);
    this.getSvgRoot().setAttribute("transform", "translate(" + x + "," + y + ")")
};
Blockly.WorkspaceCommentSvg.prototype.moveToDragSurface_ = function() {
    if (!this.useDragSurface_) return;
    var xy = this.getRelativeToSurfaceXY();
    this.clearTransformAttributes_();
    this.workspace.blockDragSurface_.translateSurface(xy.x, xy.y);
    this.workspace.blockDragSurface_.setBlocksAndShow(this.getSvgRoot())
};
Blockly.WorkspaceCommentSvg.prototype.moveOffDragSurface_ = function(newXY) {
    if (!this.useDragSurface_) return;
    this.translate(newXY.x, newXY.y);
    this.workspace.blockDragSurface_.clearAndHide(this.workspace.getCanvas())
};
Blockly.WorkspaceCommentSvg.prototype.moveDuringDrag = function(dragSurface, newLoc) {
    if (dragSurface) dragSurface.translateSurface(newLoc.x, newLoc.y);
    else {
        this.svgGroup_.translate_ = "translate(" + newLoc.x + "," + newLoc.y + ")";
        this.svgGroup_.setAttribute("transform", this.svgGroup_.translate_ + this.svgGroup_.skew_)
    }
};
Blockly.WorkspaceCommentSvg.prototype.moveTo = function(x, y) {
    this.translate(x, y)
};
Blockly.WorkspaceCommentSvg.prototype.clearTransformAttributes_ = function() {
    Blockly.utils.removeAttribute(this.getSvgRoot(), "transform")
};
Blockly.WorkspaceCommentSvg.prototype.getBoundingRectangle = function() {
    var blockXY = this.getRelativeToSurfaceXY();
    var commentBounds = this.getHeightWidth();
    var topLeft;
    var bottomRight;
    if (this.RTL) {
        topLeft = new goog.math.Coordinate(blockXY.x - commentBounds.width, blockXY.y);
        bottomRight = new goog.math.Coordinate(blockXY.x, blockXY.y + commentBounds.height)
    } else {
        topLeft = new goog.math.Coordinate(blockXY.x, blockXY.y);
        bottomRight = new goog.math.Coordinate(blockXY.x + commentBounds.width, blockXY.y + commentBounds.height)
    }
    return {
        topLeft: topLeft,
        bottomRight: bottomRight
    }
};
Blockly.WorkspaceCommentSvg.prototype.updateMovable = function() {
    if (this.isMovable()) Blockly.utils.addClass(this.svgGroup_, "blocklyDraggable");
    else Blockly.utils.removeClass(this.svgGroup_, "blocklyDraggable")
};
Blockly.WorkspaceCommentSvg.prototype.setMovable = function(movable) {
    Blockly.WorkspaceCommentSvg.superClass_.setMovable.call(this, movable);
    this.updateMovable()
};
Blockly.WorkspaceCommentSvg.prototype.setDragging = function(adding) {
    if (adding) {
        var group = this.getSvgRoot();
        group.translate_ = "";
        group.skew_ = "";
        Blockly.utils.addClass(this.svgGroup_, "blocklyDragging")
    } else Blockly.utils.removeClass(this.svgGroup_, "blocklyDragging")
};
Blockly.WorkspaceCommentSvg.prototype.getSvgRoot = function() {
    return this.svgGroup_
};
Blockly.WorkspaceCommentSvg.prototype.getContent = function() {
    return this.textarea_ ? this.textarea_.value : this.content_
};
Blockly.WorkspaceCommentSvg.prototype.setContent = function(content) {
    Blockly.WorkspaceCommentSvg.superClass_.setContent.call(this, content);
    if (this.textarea_) this.textarea_.value = content
};
Blockly.WorkspaceCommentSvg.prototype.setDeleteStyle = function(enable) {
    if (enable) Blockly.utils.addClass(this.svgGroup_, "blocklyDraggingDelete");
    else Blockly.utils.removeClass(this.svgGroup_, "blocklyDraggingDelete")
};
Blockly.WorkspaceCommentSvg.prototype.setAutoLayout = function() {};
Blockly.WorkspaceCommentSvg.fromXml = function(xmlComment, workspace, opt_wsWidth) {
    Blockly.Events.disable();
    try {
        var info = Blockly.WorkspaceComment.parseAttributes(xmlComment);
        var comment = new Blockly.WorkspaceCommentSvg(workspace, info.content, info.h, info.w, info.id);
        if (workspace.rendered) {
            comment.initSvg();
            comment.render(false)
        }
        if (!isNaN(info.x) && !isNaN(info.y))
            if (workspace.RTL) {
                var wsWidth = opt_wsWidth || workspace.getWidth();
                comment.moveBy(wsWidth - info.x, info.y)
            } else comment.moveBy(info.x, info.y)
    } finally {
        Blockly.Events.enable()
    }
    Blockly.WorkspaceComment.fireCreateEvent(comment);
    return comment
};
Blockly.WorkspaceCommentSvg.prototype.toXmlWithXY = function(opt_noId) {
    var width;
    if (this.workspace.RTL) width = this.workspace.getWidth();
    var element = this.toXml(opt_noId);
    var xy = this.getRelativeToSurfaceXY();
    element.setAttribute("x", Math.round(this.workspace.RTL ? width - xy.x : xy.x));
    element.setAttribute("y", Math.round(xy.y));
    element.setAttribute("h", this.getHeight());
    element.setAttribute("w", this.getWidth());
    return element
};
goog.provide("Blockly.WorkspaceDragSurfaceSvg");
goog.require("Blockly.utils");
Blockly.WorkspaceDragSurfaceSvg = function(container) {
    this.container_ = container;
    this.createDom()
};
Blockly.WorkspaceDragSurfaceSvg.prototype.SVG_ = null;
Blockly.WorkspaceDragSurfaceSvg.prototype.dragGroup_ = null;
Blockly.WorkspaceDragSurfaceSvg.prototype.container_ = null;
Blockly.WorkspaceDragSurfaceSvg.prototype.createDom = function() {
    if (this.SVG_) return;
    this.SVG_ = Blockly.utils.createSvgElement("svg", {
        "xmlns": Blockly.SVG_NS,
        "xmlns:html": Blockly.HTML_NS,
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        "version": "1.1",
        "class": "blocklyWsDragSurface blocklyOverflowVisible"
    }, null);
    this.container_.appendChild(this.SVG_)
};
Blockly.WorkspaceDragSurfaceSvg.prototype.translateSurface = function(x, y) {
    var fixedX = x.toFixed(0);
    var fixedY = y.toFixed(0);
    this.SVG_.style.display = "block";
    Blockly.utils.setCssTransform(this.SVG_, "translate3d(" + fixedX + "px, " + fixedY + "px, 0px)")
};
Blockly.WorkspaceDragSurfaceSvg.prototype.getSurfaceTranslation = function() {
    return Blockly.utils.getRelativeXY(this.SVG_)
};
Blockly.WorkspaceDragSurfaceSvg.prototype.clearAndHide = function(newSurface) {
    if (!newSurface) throw Error("Couldn't clear and hide the drag surface: missing " + "new surface.");
    var blockCanvas = this.SVG_.childNodes[0];
    var bubbleCanvas = this.SVG_.childNodes[1];
    if (!blockCanvas || !bubbleCanvas || !Blockly.utils.hasClass(blockCanvas, "blocklyBlockCanvas") || !Blockly.utils.hasClass(bubbleCanvas, "blocklyBubbleCanvas")) throw Error("Couldn't clear and hide the drag surface. " + "A node was missing.");
    if (this.previousSibling_ !=
        null) Blockly.utils.insertAfter(blockCanvas, this.previousSibling_);
    else newSurface.insertBefore(blockCanvas, newSurface.firstChild);
    Blockly.utils.insertAfter(bubbleCanvas, blockCanvas);
    this.SVG_.style.display = "none";
    if (this.SVG_.childNodes.length) throw Error("Drag surface was not cleared.");
    Blockly.utils.setCssTransform(this.SVG_, "");
    this.previousSibling_ = null
};
Blockly.WorkspaceDragSurfaceSvg.prototype.setContentsAndShow = function(blockCanvas, bubbleCanvas, previousSibling, width, height, scale) {
    if (this.SVG_.childNodes.length) throw Error("Already dragging a block.");
    this.previousSibling_ = previousSibling;
    blockCanvas.setAttribute("transform", "translate(0, 0) scale(" + scale + ")");
    bubbleCanvas.setAttribute("transform", "translate(0, 0) scale(" + scale + ")");
    this.SVG_.setAttribute("width", width);
    this.SVG_.setAttribute("height", height);
    this.SVG_.appendChild(blockCanvas);
    this.SVG_.appendChild(bubbleCanvas);
    this.SVG_.style.display = "block"
};
goog.provide("Blockly.WorkspaceDragger");
goog.require("goog.math.Coordinate");
Blockly.WorkspaceDragger = function(workspace) {
    this.workspace_ = workspace;
    this.startDragMetrics_ = workspace.getMetrics();
    this.startScrollXY_ = new goog.math.Coordinate(workspace.scrollX, workspace.scrollY)
};
Blockly.WorkspaceDragger.prototype.dispose = function() {
    this.workspace_ = null
};
Blockly.WorkspaceDragger.prototype.startDrag = function() {
    if (Blockly.selected) Blockly.selected.unselect();
    this.workspace_.setupDragSurface()
};
Blockly.WorkspaceDragger.prototype.endDrag = function(currentDragDeltaXY) {
    this.drag(currentDragDeltaXY);
    this.workspace_.resetDragSurface()
};
Blockly.WorkspaceDragger.prototype.drag = function(currentDragDeltaXY) {
    var metrics = this.startDragMetrics_;
    var newXY = goog.math.Coordinate.sum(this.startScrollXY_, currentDragDeltaXY);
    var x = Math.min(newXY.x, -metrics.contentLeft);
    var y = Math.min(newXY.y, -metrics.contentTop);
    x = Math.max(x, metrics.viewWidth - metrics.contentLeft - metrics.contentWidth);
    y = Math.max(y, metrics.viewHeight - metrics.contentTop - metrics.contentHeight);
    x = -x - metrics.contentLeft;
    y = -y - metrics.contentTop;
    this.updateScroll_(x, y)
};
Blockly.WorkspaceDragger.prototype.updateScroll_ = function(x, y) {
    this.workspace_.scrollbar.set(x, y)
};
goog.provide("Blockly.WorkspaceSvg");
goog.require("Blockly.ConnectionDB");
goog.require("Blockly.constants");
goog.require("Blockly.Events.BlockCreate");
goog.require("Blockly.Gesture");
goog.require("Blockly.Grid");
goog.require("Blockly.Options");
goog.require("Blockly.ScrollbarPair");
goog.require("Blockly.Touch");
goog.require("Blockly.TouchGesture");
goog.require("Blockly.Trashcan");
goog.require("Blockly.utils");
goog.require("Blockly.VariablesDynamic");
goog.require("Blockly.Workspace");
goog.require("Blockly.WorkspaceAudio");
goog.require("Blockly.WorkspaceComment");
goog.require("Blockly.WorkspaceCommentSvg");
goog.require("Blockly.WorkspaceCommentSvg.render");
goog.require("Blockly.WorkspaceDragSurfaceSvg");
goog.require("Blockly.Xml");
goog.require("Blockly.ZoomControls");
goog.require("goog.dom");
goog.require("goog.math.Coordinate");
Blockly.WorkspaceSvg = function(options, opt_blockDragSurface, opt_wsDragSurface) {
    Blockly.WorkspaceSvg.superClass_.constructor.call(this, options);
    this.getMetrics = options.getMetrics || Blockly.WorkspaceSvg.getTopLevelWorkspaceMetrics_;
    this.setMetrics = options.setMetrics || Blockly.WorkspaceSvg.setTopLevelWorkspaceMetrics_;
    Blockly.ConnectionDB.init(this);
    if (opt_blockDragSurface) this.blockDragSurface_ = opt_blockDragSurface;
    if (opt_wsDragSurface) this.workspaceDragSurface_ = opt_wsDragSurface;
    this.useWorkspaceDragSurface_ =
        this.workspaceDragSurface_ && Blockly.utils.is3dSupported();
    this.highlightedBlocks_ = [];
    this.audioManager_ = new Blockly.WorkspaceAudio(options.parentWorkspace);
    this.grid_ = this.options.gridPattern ? new Blockly.Grid(options.gridPattern, options.gridOptions) : null;
    if (Blockly.Variables && Blockly.Variables.flyoutCategory) this.registerToolboxCategoryCallback(Blockly.VARIABLE_CATEGORY_NAME, Blockly.Variables.flyoutCategory);
    if (Blockly.VariablesDynamic && Blockly.VariablesDynamic.flyoutCategory) this.registerToolboxCategoryCallback(Blockly.VARIABLE_DYNAMIC_CATEGORY_NAME,
        Blockly.VariablesDynamic.flyoutCategory);
    if (Blockly.Procedures && Blockly.Procedures.flyoutCategory) this.registerToolboxCategoryCallback(Blockly.PROCEDURE_CATEGORY_NAME, Blockly.Procedures.flyoutCategory)
};
goog.inherits(Blockly.WorkspaceSvg, Blockly.Workspace);
Blockly.WorkspaceSvg.prototype.resizeHandlerWrapper_ = null;
Blockly.WorkspaceSvg.prototype.rendered = true;
Blockly.WorkspaceSvg.prototype.isVisible_ = true;
Blockly.WorkspaceSvg.prototype.isFlyout = false;
Blockly.WorkspaceSvg.prototype.isMutator = false;
Blockly.WorkspaceSvg.prototype.resizesEnabled_ = true;
Blockly.WorkspaceSvg.prototype.scrollX = 0;
Blockly.WorkspaceSvg.prototype.scrollY = 0;
Blockly.WorkspaceSvg.prototype.startScrollX = 0;
Blockly.WorkspaceSvg.prototype.startScrollY = 0;
Blockly.WorkspaceSvg.prototype.dragDeltaXY_ = null;
Blockly.WorkspaceSvg.prototype.scale = 1;
Blockly.WorkspaceSvg.prototype.trashcan = null;
Blockly.WorkspaceSvg.prototype.scrollbar = null;
Blockly.WorkspaceSvg.prototype.currentGesture_ = null;
Blockly.WorkspaceSvg.prototype.blockDragSurface_ = null;
Blockly.WorkspaceSvg.prototype.workspaceDragSurface_ = null;
Blockly.WorkspaceSvg.prototype.useWorkspaceDragSurface_ = false;
Blockly.WorkspaceSvg.prototype.isDragSurfaceActive_ = false;
Blockly.WorkspaceSvg.prototype.injectionDiv_ = null;
Blockly.WorkspaceSvg.prototype.lastRecordedPageScroll_ = null;
Blockly.WorkspaceSvg.prototype.flyoutButtonCallbacks_ = {};
Blockly.WorkspaceSvg.prototype.toolboxCategoryCallbacks_ = {};
Blockly.WorkspaceSvg.prototype.configureContextMenu = null;
Blockly.WorkspaceSvg.prototype.targetWorkspace = null;
Blockly.WorkspaceSvg.prototype.inverseScreenCTM_ = null;
Blockly.WorkspaceSvg.prototype.inverseScreenCTMDirty_ = true;
Blockly.WorkspaceSvg.prototype.getInverseScreenCTM = function() {
    if (this.inverseScreenCTMDirty_) {
        var ctm = this.getParentSvg().getScreenCTM();
        if (ctm) {
            this.inverseScreenCTM_ = ctm.inverse();
            this.inverseScreenCTMDirty_ = false
        }
    }
    return this.inverseScreenCTM_
};
Blockly.WorkspaceSvg.prototype.updateInverseScreenCTM = function() {
    this.inverseScreenCTMDirty_ = true
};
Blockly.WorkspaceSvg.prototype.isVisible = function() {
    return this.isVisible_
};
Blockly.WorkspaceSvg.prototype.getSvgXY = function(element) {
    var x = 0;
    var y = 0;
    var scale = 1;
    if (Blockly.utils.containsNode(this.getCanvas(), element) || Blockly.utils.containsNode(this.getBubbleCanvas(), element)) scale = this.scale;
    do {
        var xy = Blockly.utils.getRelativeXY(element);
        if (element == this.getCanvas() || element == this.getBubbleCanvas()) scale = 1;
        x += xy.x * scale;
        y += xy.y * scale;
        element = element.parentNode
    } while (element && element != this.getParentSvg());
    return new goog.math.Coordinate(x, y)
};
Blockly.WorkspaceSvg.prototype.getOriginOffsetInPixels = function() {
    return Blockly.utils.getInjectionDivXY_(this.svgBlockCanvas_)
};
Blockly.WorkspaceSvg.prototype.getInjectionDiv = function() {
    if (!this.injectionDiv_) {
        var element = this.svgGroup_;
        while (element) {
            var classes = element.getAttribute("class") || "";
            if ((" " + classes + " ").indexOf(" injectionDiv ") != -1) {
                this.injectionDiv_ = element;
                break
            }
            element = element.parentNode
        }
    }
    return this.injectionDiv_
};
Blockly.WorkspaceSvg.prototype.setResizeHandlerWrapper = function(handler) {
    this.resizeHandlerWrapper_ = handler
};
Blockly.WorkspaceSvg.prototype.createDom = function(opt_backgroundClass) {
    this.svgGroup_ = Blockly.utils.createSvgElement("g", {
        "class": "blocklyWorkspace"
    }, null);
    if (opt_backgroundClass) {
        this.svgBackground_ = Blockly.utils.createSvgElement("rect", {
            "height": "100%",
            "width": "100%",
            "class": opt_backgroundClass
        }, this.svgGroup_);
        if (opt_backgroundClass == "blocklyMainBackground" && this.grid_) this.svgBackground_.style.fill = "url(#" + this.grid_.getPatternId() + ")"
    }
    this.svgBlockCanvas_ = Blockly.utils.createSvgElement("g", {
            "class": "blocklyBlockCanvas"
        },
        this.svgGroup_);
    this.svgBubbleCanvas_ = Blockly.utils.createSvgElement("g", {
        "class": "blocklyBubbleCanvas"
    }, this.svgGroup_);
    var bottom = Blockly.Scrollbar.scrollbarThickness;
    if (this.options.hasTrashcan) bottom = this.addTrashcan_(bottom);
    if (this.options.zoomOptions && this.options.zoomOptions.controls) this.addZoomControls_(bottom);
    if (!this.isFlyout) {
        Blockly.bindEventWithChecks_(this.svgGroup_, "mousedown", this, this.onMouseDown_, false, true);
        if (this.options.zoomOptions && this.options.zoomOptions.wheel) Blockly.bindEventWithChecks_(this.svgGroup_,
            "wheel", this, this.onMouseWheel_)
    }
    if (this.options.hasCategories) this.toolbox_ = new Blockly.Toolbox(this);
    if (this.grid_) this.grid_.update(this.scale);
    this.recordDeleteAreas();
    return this.svgGroup_
};
Blockly.WorkspaceSvg.prototype.dispose = function() {
    this.rendered = false;
    if (this.currentGesture_) this.currentGesture_.cancel();
    Blockly.WorkspaceSvg.superClass_.dispose.call(this);
    if (this.svgGroup_) {
        Blockly.utils.removeNode(this.svgGroup_);
        this.svgGroup_ = null
    }
    this.svgBlockCanvas_ = null;
    this.svgBubbleCanvas_ = null;
    if (this.toolbox_) {
        this.toolbox_.dispose();
        this.toolbox_ = null
    }
    if (this.flyout_) {
        this.flyout_.dispose();
        this.flyout_ = null
    }
    if (this.trashcan) {
        this.trashcan.dispose();
        this.trashcan = null
    }
    if (this.scrollbar) {
        this.scrollbar.dispose();
        this.scrollbar = null
    }
    if (this.zoomControls_) {
        this.zoomControls_.dispose();
        this.zoomControls_ = null
    }
    if (this.audioManager_) {
        this.audioManager_.dispose();
        this.audioManager_ = null
    }
    if (this.grid_) {
        this.grid_.dispose();
        this.grid_ = null
    }
    if (this.toolboxCategoryCallbacks_) this.toolboxCategoryCallbacks_ = null;
    if (this.flyoutButtonCallbacks_) this.flyoutButtonCallbacks_ = null;
    if (!this.options.parentWorkspace) {
        var div = this.getParentSvg().parentNode;
        if (div) Blockly.utils.removeNode(div)
    }
    if (this.resizeHandlerWrapper_) {
        Blockly.unbindEvent_(this.resizeHandlerWrapper_);
        this.resizeHandlerWrapper_ = null
    }
};
Blockly.WorkspaceSvg.prototype.newBlock = function(prototypeName, opt_id) {
    return new Blockly.BlockSvg(this, prototypeName, opt_id)
};
Blockly.WorkspaceSvg.prototype.addTrashcan_ = function(bottom) {
    this.trashcan = new Blockly.Trashcan(this);
    var svgTrashcan = this.trashcan.createDom();
    this.svgGroup_.insertBefore(svgTrashcan, this.svgBlockCanvas_);
    return this.trashcan.init(bottom)
};
Blockly.WorkspaceSvg.prototype.addZoomControls_ = function(bottom) {
    this.zoomControls_ = new Blockly.ZoomControls(this);
    var svgZoomControls = this.zoomControls_.createDom();
    this.svgGroup_.appendChild(svgZoomControls);
    return this.zoomControls_.init(bottom)
};
Blockly.WorkspaceSvg.prototype.addFlyout_ = function(tagName) {
    var workspaceOptions = {
        disabledPatternId: this.options.disabledPatternId,
        parentWorkspace: this,
        RTL: this.RTL,
        oneBasedIndex: this.options.oneBasedIndex,
        horizontalLayout: this.horizontalLayout,
        toolboxPosition: this.options.toolboxPosition
    };
    this.flyout_ = null;
    if (this.horizontalLayout) this.flyout_ = new Blockly.HorizontalFlyout(workspaceOptions);
    else this.flyout_ = new Blockly.VerticalFlyout(workspaceOptions);
    this.flyout_.autoClose = false;
    return this.flyout_.createDom(tagName)
};
Blockly.WorkspaceSvg.prototype.getFlyout_ = function() {
    if (this.flyout_) return this.flyout_;
    if (this.toolbox_) return this.toolbox_.flyout_;
    return null
};
Blockly.WorkspaceSvg.prototype.getToolbox = function() {
    return this.toolbox_
};
Blockly.WorkspaceSvg.prototype.updateScreenCalculations_ = function() {
    this.updateInverseScreenCTM();
    this.recordDeleteAreas()
};
Blockly.WorkspaceSvg.prototype.resizeContents = function() {
    if (!this.resizesEnabled_ || !this.rendered) return;
    if (this.scrollbar) this.scrollbar.resize();
    this.updateInverseScreenCTM()
};
Blockly.WorkspaceSvg.prototype.resize = function() {
    if (this.toolbox_) this.toolbox_.position();
    if (this.flyout_) this.flyout_.position();
    if (this.trashcan) this.trashcan.position();
    if (this.zoomControls_) this.zoomControls_.position();
    if (this.scrollbar) this.scrollbar.resize();
    this.updateScreenCalculations_()
};
Blockly.WorkspaceSvg.prototype.updateScreenCalculationsIfScrolled = function() {
    var currScroll = goog.dom.getDocumentScroll();
    if (!goog.math.Coordinate.equals(this.lastRecordedPageScroll_, currScroll)) {
        this.lastRecordedPageScroll_ = currScroll;
        this.updateScreenCalculations_()
    }
};
Blockly.WorkspaceSvg.prototype.getCanvas = function() {
    return this.svgBlockCanvas_
};
Blockly.WorkspaceSvg.prototype.getBubbleCanvas = function() {
    return this.svgBubbleCanvas_
};
Blockly.WorkspaceSvg.prototype.getParentSvg = function() {
    if (this.cachedParentSvg_) return this.cachedParentSvg_;
    var element = this.svgGroup_;
    while (element) {
        if (element.tagName == "svg") {
            this.cachedParentSvg_ = element;
            return element
        }
        element = element.parentNode
    }
    return null
};
Blockly.WorkspaceSvg.prototype.translate = function(x, y) {
    if (this.useWorkspaceDragSurface_ && this.isDragSurfaceActive_) this.workspaceDragSurface_.translateSurface(x, y);
    else {
        var translation = "translate(" + x + "," + y + ") " + "scale(" + this.scale + ")";
        this.svgBlockCanvas_.setAttribute("transform", translation);
        this.svgBubbleCanvas_.setAttribute("transform", translation)
    }
    if (this.blockDragSurface_) this.blockDragSurface_.translateAndScaleGroup(x, y, this.scale)
};
Blockly.WorkspaceSvg.prototype.resetDragSurface = function() {
    if (!this.useWorkspaceDragSurface_) return;
    this.isDragSurfaceActive_ = false;
    var trans = this.workspaceDragSurface_.getSurfaceTranslation();
    this.workspaceDragSurface_.clearAndHide(this.svgGroup_);
    var translation = "translate(" + trans.x + "," + trans.y + ") " + "scale(" + this.scale + ")";
    this.svgBlockCanvas_.setAttribute("transform", translation);
    this.svgBubbleCanvas_.setAttribute("transform", translation)
};
Blockly.WorkspaceSvg.prototype.setupDragSurface = function() {
    if (!this.useWorkspaceDragSurface_) return;
    if (this.isDragSurfaceActive_) return;
    this.isDragSurfaceActive_ = true;
    var previousElement = this.svgBlockCanvas_.previousSibling;
    var width = parseInt(this.getParentSvg().getAttribute("width"), 10);
    var height = parseInt(this.getParentSvg().getAttribute("height"), 10);
    var coord = Blockly.utils.getRelativeXY(this.svgBlockCanvas_);
    this.workspaceDragSurface_.setContentsAndShow(this.svgBlockCanvas_, this.svgBubbleCanvas_,
        previousElement, width, height, this.scale);
    this.workspaceDragSurface_.translateSurface(coord.x, coord.y)
};
Blockly.WorkspaceSvg.prototype.getBlockDragSurface = function() {
    return this.blockDragSurface_
};
Blockly.WorkspaceSvg.prototype.getWidth = function() {
    var metrics = this.getMetrics();
    return metrics ? metrics.viewWidth / this.scale : 0
};
Blockly.WorkspaceSvg.prototype.setVisible = function(isVisible) {
    if (this.scrollbar) this.scrollbar.setContainerVisible(isVisible);
    if (this.getFlyout_()) this.getFlyout_().setContainerVisible(isVisible);
    this.getParentSvg().style.display = isVisible ? "block" : "none";
    if (this.toolbox_) this.toolbox_.HtmlDiv.style.display = isVisible ? "block" : "none";
    if (isVisible) {
        this.render();
        if (this.toolbox_) this.toolbox_.position()
    } else Blockly.hideChaff(true);
    this.isVisible_ = isVisible
};
Blockly.WorkspaceSvg.prototype.render = function() {
    var blocks = this.getAllBlocks(false);
    for (var i = blocks.length - 1; i >= 0; i--) blocks[i].render(false)
};
Blockly.WorkspaceSvg.prototype.traceOn = function() {
    console.warn("Deprecated call to traceOn, delete this.")
};
Blockly.WorkspaceSvg.prototype.highlightBlock = function(id, opt_state) {
    if (opt_state === undefined) {
        for (var i = 0, block; block = this.highlightedBlocks_[i]; i++) block.setHighlighted(false);
        this.highlightedBlocks_.length = 0
    }
    var block = id ? this.getBlockById(id) : null;
    if (block) {
        var state = opt_state === undefined || opt_state;
        if (!state) Blockly.utils.arrayRemove(this.highlightedBlocks_, block);
        else if (this.highlightedBlocks_.indexOf(block) == -1) this.highlightedBlocks_.push(block);
        block.setHighlighted(state)
    }
};
Blockly.WorkspaceSvg.prototype.paste = function(xmlBlock) {
    if (!this.rendered || xmlBlock.getElementsByTagName("block").length >= this.remainingCapacity()) return;
    if (this.currentGesture_) this.currentGesture_.cancel();
    if (xmlBlock.tagName.toLowerCase() == "comment") this.pasteWorkspaceComment_(xmlBlock);
    else this.pasteBlock_(xmlBlock)
};
Blockly.WorkspaceSvg.prototype.pasteBlock_ = function(xmlBlock) {
    Blockly.Events.disable();
    try {
        var block = Blockly.Xml.domToBlock(xmlBlock, this);
        var blockX = parseInt(xmlBlock.getAttribute("x"), 10);
        var blockY = parseInt(xmlBlock.getAttribute("y"), 10);
        if (!isNaN(blockX) && !isNaN(blockY)) {
            if (this.RTL) blockX = -blockX;
            do {
                var collide = false;
                var allBlocks = this.getAllBlocks(false);
                for (var i = 0, otherBlock; otherBlock = allBlocks[i]; i++) {
                    var otherXY = otherBlock.getRelativeToSurfaceXY();
                    if (Math.abs(blockX - otherXY.x) <= 1 && Math.abs(blockY -
                            otherXY.y) <= 1) {
                        collide = true;
                        break
                    }
                }
                if (!collide) {
                    var connections = block.getConnections_(false);
                    for (var i = 0, connection; connection = connections[i]; i++) {
                        var neighbour = connection.closest(Blockly.SNAP_RADIUS, new goog.math.Coordinate(blockX, blockY));
                        if (neighbour.connection) {
                            collide = true;
                            break
                        }
                    }
                }
                if (collide) {
                    if (this.RTL) blockX -= Blockly.SNAP_RADIUS;
                    else blockX += Blockly.SNAP_RADIUS;
                    blockY += Blockly.SNAP_RADIUS * 2
                }
            } while (collide);
            block.moveBy(blockX, blockY)
        }
    } finally {
        Blockly.Events.enable()
    }
    if (Blockly.Events.isEnabled() &&
        !block.isShadow()) Blockly.Events.fire(new Blockly.Events.BlockCreate(block));
    block.select()
};
Blockly.WorkspaceSvg.prototype.pasteWorkspaceComment_ = function(xmlComment) {
    Blockly.Events.disable();
    try {
        var comment = Blockly.WorkspaceCommentSvg.fromXml(xmlComment, this);
        var commentX = parseInt(xmlComment.getAttribute("x"), 10);
        var commentY = parseInt(xmlComment.getAttribute("y"), 10);
        if (!isNaN(commentX) && !isNaN(commentY)) {
            if (this.RTL) commentX = -commentX;
            commentX += 50;
            commentY += 50;
            comment.moveBy(commentX, commentY)
        }
    } finally {
        Blockly.Events.enable()
    }
    if (Blockly.Events.isEnabled());
    comment.select()
};
Blockly.WorkspaceSvg.prototype.refreshToolboxSelection = function() {
    var ws = this.isFlyout ? this.targetWorkspace : this;
    if (ws && !ws.currentGesture_ && ws.toolbox_ && ws.toolbox_.flyout_) ws.toolbox_.refreshSelection()
};
Blockly.WorkspaceSvg.prototype.renameVariableById = function(id, newName) {
    Blockly.WorkspaceSvg.superClass_.renameVariableById.call(this, id, newName);
    this.refreshToolboxSelection()
};
Blockly.WorkspaceSvg.prototype.deleteVariableById = function(id) {
    Blockly.WorkspaceSvg.superClass_.deleteVariableById.call(this, id);
    this.refreshToolboxSelection()
};
Blockly.WorkspaceSvg.prototype.createVariable = function(name, opt_type, opt_id) {
    var newVar = Blockly.WorkspaceSvg.superClass_.createVariable.call(this, name, opt_type, opt_id);
    this.refreshToolboxSelection();
    return newVar
};
Blockly.WorkspaceSvg.prototype.recordDeleteAreas = function() {
    if (this.trashcan && this.svgGroup_.parentNode) this.deleteAreaTrash_ = this.trashcan.getClientRect();
    else this.deleteAreaTrash_ = null;
    if (this.flyout_) this.deleteAreaToolbox_ = this.flyout_.getClientRect();
    else if (this.toolbox_) this.deleteAreaToolbox_ = this.toolbox_.getClientRect();
    else this.deleteAreaToolbox_ = null
};
Blockly.WorkspaceSvg.prototype.isDeleteArea = function(e) {
    var xy = new goog.math.Coordinate(e.clientX, e.clientY);
    if (this.deleteAreaTrash_ && this.deleteAreaTrash_.contains(xy)) return Blockly.DELETE_AREA_TRASH;
    if (this.deleteAreaToolbox_ && this.deleteAreaToolbox_.contains(xy)) return Blockly.DELETE_AREA_TOOLBOX;
    return Blockly.DELETE_AREA_NONE
};
Blockly.WorkspaceSvg.prototype.onMouseDown_ = function(e) {
    var gesture = this.getGesture(e);
    if (gesture) gesture.handleWsStart(e, this)
};
Blockly.WorkspaceSvg.prototype.startDrag = function(e, xy) {
    var point = Blockly.utils.mouseToSvg(e, this.getParentSvg(), this.getInverseScreenCTM());
    point.x /= this.scale;
    point.y /= this.scale;
    this.dragDeltaXY_ = goog.math.Coordinate.difference(xy, point)
};
Blockly.WorkspaceSvg.prototype.moveDrag = function(e) {
    var point = Blockly.utils.mouseToSvg(e, this.getParentSvg(), this.getInverseScreenCTM());
    point.x /= this.scale;
    point.y /= this.scale;
    return goog.math.Coordinate.sum(this.dragDeltaXY_, point)
};
Blockly.WorkspaceSvg.prototype.isDragging = function() {
    return this.currentGesture_ != null && this.currentGesture_.isDragging()
};
Blockly.WorkspaceSvg.prototype.isDraggable = function() {
    return !!this.scrollbar
};
Blockly.WorkspaceSvg.prototype.onMouseWheel_ = function(e) {
    if (this.currentGesture_) this.currentGesture_.cancel();
    var PIXELS_PER_ZOOM_STEP = 50;
    var delta = -e.deltaY / PIXELS_PER_ZOOM_STEP;
    var position = Blockly.utils.mouseToSvg(e, this.getParentSvg(), this.getInverseScreenCTM());
    this.zoom(position.x, position.y, delta);
    e.preventDefault()
};
Blockly.WorkspaceSvg.prototype.getBlocksBoundingBox = function() {
    var topBlocks = this.getTopBlocks(false);
    var topComments = this.getTopComments(false);
    var topElements = topBlocks.concat(topComments);
    if (!topElements.length) return {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    var boundary = topElements[0].getBoundingRectangle();
    for (var i = 1; i < topElements.length; i++) {
        var blockBoundary = topElements[i].getBoundingRectangle();
        if (blockBoundary.topLeft.x < boundary.topLeft.x) boundary.topLeft.x = blockBoundary.topLeft.x;
        if (blockBoundary.bottomRight.x >
            boundary.bottomRight.x) boundary.bottomRight.x = blockBoundary.bottomRight.x;
        if (blockBoundary.topLeft.y < boundary.topLeft.y) boundary.topLeft.y = blockBoundary.topLeft.y;
        if (blockBoundary.bottomRight.y > boundary.bottomRight.y) boundary.bottomRight.y = blockBoundary.bottomRight.y
    }
    return {
        x: boundary.topLeft.x,
        y: boundary.topLeft.y,
        width: boundary.bottomRight.x - boundary.topLeft.x,
        height: boundary.bottomRight.y - boundary.topLeft.y
    }
};
Blockly.WorkspaceSvg.prototype.cleanUp = function() {
    this.setResizesEnabled(false);
    Blockly.Events.setGroup(true);
    var topBlocks = this.getTopBlocks(true);
    var cursorY = 0;
    for (var i = 0, block; block = topBlocks[i]; i++) {
        var xy = block.getRelativeToSurfaceXY();
        block.moveBy(-xy.x, cursorY - xy.y);
        block.snapToGrid();
        cursorY = block.getRelativeToSurfaceXY().y + block.getHeightWidth().height + Blockly.BlockSvg.MIN_BLOCK_Y
    }
    Blockly.Events.setGroup(false);
    this.setResizesEnabled(true)
};
Blockly.WorkspaceSvg.prototype.showContextMenu_ = function(e) {
    if (this.options.readOnly || this.isFlyout) return;
    var menuOptions = [];
    var topBlocks = this.getTopBlocks(true);
    var eventGroup = Blockly.utils.genUid();
    var ws = this;
    var undoOption = {};
    undoOption.text = Blockly.Msg["UNDO"];
    undoOption.enabled = this.undoStack_.length > 0;
    undoOption.callback = this.undo.bind(this, false);
    menuOptions.push(undoOption);
    var redoOption = {};
    redoOption.text = Blockly.Msg["REDO"];
    redoOption.enabled = this.redoStack_.length > 0;
    redoOption.callback =
        this.undo.bind(this, true);
    menuOptions.push(redoOption);
    if (this.scrollbar) {
        var cleanOption = {};
        cleanOption.text = Blockly.Msg["CLEAN_UP"];
        cleanOption.enabled = topBlocks.length > 1;
        cleanOption.callback = this.cleanUp.bind(this);
        menuOptions.push(cleanOption)
    }
    var DELAY = 10;
    if (this.options.collapse) {
        var hasCollapsedBlocks = false;
        var hasExpandedBlocks = false;
        for (var i = 0; i < topBlocks.length; i++) {
            var block = topBlocks[i];
            while (block) {
                if (block.isCollapsed()) hasCollapsedBlocks = true;
                else hasExpandedBlocks = true;
                block = block.getNextBlock()
            }
        }
        var toggleOption =
            function(shouldCollapse) {
                var ms = 0;
                for (var i = 0; i < topBlocks.length; i++) {
                    var block = topBlocks[i];
                    while (block) {
                        setTimeout(block.setCollapsed.bind(block, shouldCollapse), ms);
                        block = block.getNextBlock();
                        ms += DELAY
                    }
                }
            };
        var collapseOption = {
            enabled: hasExpandedBlocks
        };
        collapseOption.text = Blockly.Msg["COLLAPSE_ALL"];
        collapseOption.callback = function() {
            toggleOption(true)
        };
        menuOptions.push(collapseOption);
        var expandOption = {
            enabled: hasCollapsedBlocks
        };
        expandOption.text = Blockly.Msg["EXPAND_ALL"];
        expandOption.callback =
            function() {
                toggleOption(false)
            };
        menuOptions.push(expandOption)
    }
    var deleteList = [];

    function addDeletableBlocks(block) {
        if (block.isDeletable()) deleteList = deleteList.concat(block.getDescendants(false));
        else {
            var children = block.getChildren(false);
            for (var i = 0; i < children.length; i++) addDeletableBlocks(children[i])
        }
    }
    for (var i = 0; i < topBlocks.length; i++) addDeletableBlocks(topBlocks[i]);

    function deleteNext() {
        Blockly.Events.setGroup(eventGroup);
        var block = deleteList.shift();
        if (block)
            if (block.workspace) {
                block.dispose(false,
                    true);
                setTimeout(deleteNext, DELAY)
            } else deleteNext();
        Blockly.Events.setGroup(false)
    }
    var deleteOption = {
        text: deleteList.length == 1 ? Blockly.Msg["DELETE_BLOCK"] : Blockly.Msg["DELETE_X_BLOCKS"].replace("%1", String(deleteList.length)),
        enabled: deleteList.length > 0,
        callback: function() {
            if (ws.currentGesture_) ws.currentGesture_.cancel();
            if (deleteList.length < 2) deleteNext();
            else Blockly.confirm(Blockly.Msg["DELETE_ALL_BLOCKS"].replace("%1", deleteList.length), function(ok) {
                if (ok) deleteNext()
            })
        }
    };
    menuOptions.push(deleteOption);
    if (this.configureContextMenu) this.configureContextMenu(menuOptions);
    Blockly.ContextMenu.show(e, menuOptions, this.RTL)
};
Blockly.WorkspaceSvg.prototype.updateToolbox = function(tree) {
    tree = Blockly.Options.parseToolboxTree(tree);
    if (!tree) {
        if (this.options.languageTree) throw Error("Can't nullify an existing toolbox.");
        return
    }
    if (!this.options.languageTree) throw Error("Existing toolbox is null.  Can't create new toolbox.");
    if (tree.getElementsByTagName("category").length) {
        if (!this.toolbox_) throw Error("Existing toolbox has no categories.  Can't change mode.");
        this.options.languageTree = tree;
        this.toolbox_.populate_(tree);
        this.toolbox_.addColour_()
    } else {
        if (!this.flyout_) throw Error("Existing toolbox has categories.  Can't change mode.");
        this.options.languageTree = tree;
        this.flyout_.show(tree.childNodes)
    }
};
Blockly.WorkspaceSvg.prototype.markFocused = function() {
    if (this.options.parentWorkspace) this.options.parentWorkspace.markFocused();
    else {
        Blockly.mainWorkspace = this;
        this.setBrowserFocus()
    }
};
Blockly.WorkspaceSvg.prototype.setBrowserFocus = function() {
    if (document.activeElement) document.activeElement.blur();
    try {
        this.getParentSvg().focus()
    } catch (e$2) {
        try {
            this.getParentSvg().parentNode.setActive()
        } catch (e) {
            this.getParentSvg().parentNode.focus()
        }
    }
};
Blockly.WorkspaceSvg.prototype.zoom = function(x, y, amount) {
    var speed = this.options.zoomOptions.scaleSpeed;
    var metrics = this.getMetrics();
    var center = this.getParentSvg().createSVGPoint();
    center.x = x;
    center.y = y;
    center = center.matrixTransform(this.getCanvas().getCTM().inverse());
    x = center.x;
    y = center.y;
    var canvas = this.getCanvas();
    var scaleChange = Math.pow(speed, amount);
    var newScale = this.scale * scaleChange;
    if (newScale > this.options.zoomOptions.maxScale) scaleChange = this.options.zoomOptions.maxScale / this.scale;
    else if (newScale <
        this.options.zoomOptions.minScale) scaleChange = this.options.zoomOptions.minScale / this.scale;
    if (this.scale == newScale) return;
    if (this.scrollbar) {
        var matrix = canvas.getCTM().translate(x * (1 - scaleChange), y * (1 - scaleChange)).scale(scaleChange);
        this.scrollX = matrix.e - metrics.absoluteLeft;
        this.scrollY = matrix.f - metrics.absoluteTop
    }
    this.setScale(newScale)
};
Blockly.WorkspaceSvg.prototype.zoomCenter = function(type) {
    var metrics = this.getMetrics();
    var x = metrics.viewWidth / 2;
    var y = metrics.viewHeight / 2;
    this.zoom(x, y, type)
};
Blockly.WorkspaceSvg.prototype.zoomToFit = function() {
    var metrics = this.getMetrics();
    var blocksBox = this.getBlocksBoundingBox();
    var blocksWidth = blocksBox.width;
    var blocksHeight = blocksBox.height;
    if (!blocksWidth) return;
    var workspaceWidth = metrics.viewWidth;
    var workspaceHeight = metrics.viewHeight;
    if (this.flyout_) workspaceWidth -= this.flyout_.width_;
    if (!this.scrollbar) {
        blocksWidth += metrics.contentLeft;
        blocksHeight += metrics.contentTop
    }
    var ratioX = workspaceWidth / blocksWidth;
    var ratioY = workspaceHeight / blocksHeight;
    this.setScale(Math.min(ratioX, ratioY));
    this.scrollCenter()
};
Blockly.WorkspaceSvg.prototype.beginCanvasTransition = function() {
    Blockly.utils.addClass(this.svgBlockCanvas_, "blocklyCanvasTransitioning");
    Blockly.utils.addClass(this.svgBubbleCanvas_, "blocklyCanvasTransitioning")
};
Blockly.WorkspaceSvg.prototype.endCanvasTransition = function() {
    Blockly.utils.removeClass(this.svgBlockCanvas_, "blocklyCanvasTransitioning");
    Blockly.utils.removeClass(this.svgBubbleCanvas_, "blocklyCanvasTransitioning")
};
Blockly.WorkspaceSvg.prototype.scrollCenter = function() {
    if (!this.scrollbar) {
        console.warn("Tried to scroll a non-scrollable workspace.");
        return
    }
    var metrics = this.getMetrics();
    var x = (metrics.contentWidth - metrics.viewWidth) / 2;
    if (this.flyout_) x -= this.flyout_.width_ / 2;
    var y = (metrics.contentHeight - metrics.viewHeight) / 2;
    this.scrollbar.set(x, y)
};
Blockly.WorkspaceSvg.prototype.centerOnBlock = function(id) {
    if (!this.scrollbar) {
        console.warn("Tried to scroll a non-scrollable workspace.");
        return
    }
    var block = this.getBlockById(id);
    if (!block) return;
    var xy = block.getRelativeToSurfaceXY();
    var heightWidth = block.getHeightWidth();
    var blockCenterY = xy.y + heightWidth.height / 2;
    var multiplier = this.RTL ? -1 : 1;
    var blockCenterX = xy.x + multiplier * heightWidth.width / 2;
    var scale = this.scale;
    var pixelX = blockCenterX * scale;
    var pixelY = blockCenterY * scale;
    var metrics = this.getMetrics();
    var scrollToBlockX = pixelX - metrics.contentLeft;
    var scrollToBlockY = pixelY - metrics.contentTop;
    var halfViewWidth = metrics.viewWidth / 2;
    var halfViewHeight = metrics.viewHeight / 2;
    var scrollToCenterX = scrollToBlockX - halfViewWidth;
    var scrollToCenterY = scrollToBlockY - halfViewHeight;
    Blockly.hideChaff();
    this.scrollbar.set(scrollToCenterX, scrollToCenterY)
};
Blockly.WorkspaceSvg.prototype.setScale = function(newScale) {
    if (this.options.zoomOptions.maxScale && newScale > this.options.zoomOptions.maxScale) newScale = this.options.zoomOptions.maxScale;
    else if (this.options.zoomOptions.minScale && newScale < this.options.zoomOptions.minScale) newScale = this.options.zoomOptions.minScale;
    this.scale = newScale;
    if (this.grid_) this.grid_.update(this.scale);
    if (this.scrollbar) this.scrollbar.resize();
    else this.translate(this.scrollX, this.scrollY);
    Blockly.hideChaff(false);
    if (this.flyout_) this.flyout_.reflow()
};
Blockly.WorkspaceSvg.getDimensionsPx_ = function(elem) {
    var width = 0;
    var height = 0;
    if (elem) {
        width = elem.getWidth();
        height = elem.getHeight()
    }
    return {
        width: width,
        height: height
    }
};
Blockly.WorkspaceSvg.getContentDimensions_ = function(ws, svgSize) {
    if (ws.scrollbar) return Blockly.WorkspaceSvg.getContentDimensionsBounded_(ws, svgSize);
    else return Blockly.WorkspaceSvg.getContentDimensionsExact_(ws)
};
Blockly.WorkspaceSvg.getContentDimensionsExact_ = function(ws) {
    var blockBox = ws.getBlocksBoundingBox();
    var scale = ws.scale;
    var width = blockBox.width * scale;
    var height = blockBox.height * scale;
    var left = blockBox.x * scale;
    var top = blockBox.y * scale;
    return {
        left: left,
        top: top,
        right: left + width,
        bottom: top + height,
        width: width,
        height: height
    }
};
Blockly.WorkspaceSvg.getContentDimensionsBounded_ = function(ws, svgSize) {
    var content = Blockly.WorkspaceSvg.getContentDimensionsExact_(ws);
    var viewWidth = svgSize.width;
    var viewHeight = svgSize.height;
    var halfWidth = viewWidth / 2;
    var halfHeight = viewHeight / 2;
    var left = Math.min(content.left - halfWidth, content.right - viewWidth);
    var right = Math.max(content.right + halfWidth, content.left + viewWidth);
    var top = Math.min(content.top - halfHeight, content.bottom - viewHeight);
    var bottom = Math.max(content.bottom + halfHeight, content.top +
        viewHeight);
    var dimensions = {
        left: left,
        top: top,
        height: bottom - top,
        width: right - left
    };
    return dimensions
};
Blockly.WorkspaceSvg.getTopLevelWorkspaceMetrics_ = function() {
    var toolboxDimensions = Blockly.WorkspaceSvg.getDimensionsPx_(this.toolbox_);
    var flyoutDimensions = Blockly.WorkspaceSvg.getDimensionsPx_(this.flyout_);
    var svgSize = Blockly.svgSize(this.getParentSvg());
    if (this.toolbox_)
        if (this.toolboxPosition == Blockly.TOOLBOX_AT_TOP || this.toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM) svgSize.height -= toolboxDimensions.height;
        else if (this.toolboxPosition == Blockly.TOOLBOX_AT_LEFT || this.toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) svgSize.width -=
        toolboxDimensions.width;
    var contentDimensions = Blockly.WorkspaceSvg.getContentDimensions_(this, svgSize);
    var absoluteLeft = 0;
    if (this.toolbox_ && this.toolboxPosition == Blockly.TOOLBOX_AT_LEFT) absoluteLeft = toolboxDimensions.width;
    var absoluteTop = 0;
    if (this.toolbox_ && this.toolboxPosition == Blockly.TOOLBOX_AT_TOP) absoluteTop = toolboxDimensions.height;
    var metrics = {
        contentHeight: contentDimensions.height,
        contentWidth: contentDimensions.width,
        contentTop: contentDimensions.top,
        contentLeft: contentDimensions.left,
        viewHeight: svgSize.height,
        viewWidth: svgSize.width,
        viewTop: -this.scrollY,
        viewLeft: -this.scrollX,
        absoluteTop: absoluteTop,
        absoluteLeft: absoluteLeft,
        toolboxWidth: toolboxDimensions.width,
        toolboxHeight: toolboxDimensions.height,
        flyoutWidth: flyoutDimensions.width,
        flyoutHeight: flyoutDimensions.height,
        toolboxPosition: this.toolboxPosition
    };
    return metrics
};
Blockly.WorkspaceSvg.setTopLevelWorkspaceMetrics_ = function(xyRatio) {
    if (!this.scrollbar) throw Error("Attempt to set top level workspace scroll without " + "scrollbars.");
    var metrics = this.getMetrics();
    if (typeof xyRatio.x == "number") this.scrollX = -metrics.contentWidth * xyRatio.x - metrics.contentLeft;
    if (typeof xyRatio.y == "number") this.scrollY = -metrics.contentHeight * xyRatio.y - metrics.contentTop;
    var x = this.scrollX + metrics.absoluteLeft;
    var y = this.scrollY + metrics.absoluteTop;
    this.translate(x, y);
    if (this.grid_) this.grid_.moveTo(x,
        y)
};
Blockly.WorkspaceSvg.prototype.setResizesEnabled = function(enabled) {
    var reenabled = !this.resizesEnabled_ && enabled;
    this.resizesEnabled_ = enabled;
    if (reenabled) this.resizeContents()
};
Blockly.WorkspaceSvg.prototype.clear = function() {
    this.setResizesEnabled(false);
    Blockly.WorkspaceSvg.superClass_.clear.call(this);
    this.setResizesEnabled(true)
};
Blockly.WorkspaceSvg.prototype.registerButtonCallback = function(key, func) {
    if (typeof func != "function") throw TypeError("Button callbacks must be functions.");
    this.flyoutButtonCallbacks_[key] = func
};
Blockly.WorkspaceSvg.prototype.getButtonCallback = function(key) {
    var result = this.flyoutButtonCallbacks_[key];
    return result ? result : null
};
Blockly.WorkspaceSvg.prototype.removeButtonCallback = function(key) {
    this.flyoutButtonCallbacks_[key] = null
};
Blockly.WorkspaceSvg.prototype.registerToolboxCategoryCallback = function(key, func) {
    if (typeof func != "function") throw TypeError("Toolbox category callbacks must be functions.");
    this.toolboxCategoryCallbacks_[key] = func
};
Blockly.WorkspaceSvg.prototype.getToolboxCategoryCallback = function(key) {
    var result = this.toolboxCategoryCallbacks_[key];
    return result ? result : null
};
Blockly.WorkspaceSvg.prototype.removeToolboxCategoryCallback = function(key) {
    this.toolboxCategoryCallbacks_[key] = null
};
Blockly.WorkspaceSvg.prototype.getGesture = function(e) {
    var isStart = e.type == "mousedown" || e.type == "touchstart" || e.type == "pointerdown";
    var gesture = this.currentGesture_;
    if (gesture) {
        if (isStart && gesture.hasStarted()) {
            console.warn("tried to start the same gesture twice");
            gesture.cancel();
            return null
        }
        return gesture
    }
    if (isStart) {
        this.currentGesture_ = new Blockly.TouchGesture(e, this);
        return this.currentGesture_
    }
    return null
};
Blockly.WorkspaceSvg.prototype.clearGesture = function() {
    this.currentGesture_ = null
};
Blockly.WorkspaceSvg.prototype.cancelCurrentGesture = function() {
    if (this.currentGesture_) this.currentGesture_.cancel()
};
Blockly.WorkspaceSvg.prototype.getAudioManager = function() {
    return this.audioManager_
};
Blockly.WorkspaceSvg.prototype.getGrid = function() {
    return this.grid_
};
Blockly.WorkspaceSvg.prototype["setVisible"] = Blockly.WorkspaceSvg.prototype.setVisible;
goog.provide("Blockly.Events.CommentBase");
goog.provide("Blockly.Events.CommentChange");
goog.provide("Blockly.Events.CommentCreate");
goog.provide("Blockly.Events.CommentDelete");
goog.provide("Blockly.Events.CommentMove");
goog.require("Blockly.Events");
goog.require("Blockly.Events.Abstract");
goog.require("Blockly.Xml");
goog.require("Blockly.Xml.utils");
goog.require("goog.math.Coordinate");
Blockly.Events.CommentBase = function(comment) {
    this.commentId = comment.id;
    this.workspaceId = comment.workspace.id;
    this.group = Blockly.Events.group_;
    this.recordUndo = Blockly.Events.recordUndo
};
goog.inherits(Blockly.Events.CommentBase, Blockly.Events.Abstract);
Blockly.Events.CommentBase.prototype.toJson = function() {
    var json = {
        "type": this.type
    };
    if (this.group) json["group"] = this.group;
    if (this.commentId) json["commentId"] = this.commentId;
    return json
};
Blockly.Events.CommentBase.prototype.fromJson = function(json) {
    this.commentId = json["commentId"];
    this.group = json["group"]
};
Blockly.Events.CommentChange = function(comment, oldContents, newContents) {
    if (!comment) return;
    Blockly.Events.CommentChange.superClass_.constructor.call(this, comment);
    this.oldContents_ = oldContents;
    this.newContents_ = newContents
};
goog.inherits(Blockly.Events.CommentChange, Blockly.Events.CommentBase);
Blockly.Events.CommentChange.prototype.type = Blockly.Events.COMMENT_CHANGE;
Blockly.Events.CommentChange.prototype.toJson = function() {
    var json = Blockly.Events.CommentChange.superClass_.toJson.call(this);
    json["newContents"] = this.newContents_;
    return json
};
Blockly.Events.CommentChange.prototype.fromJson = function(json) {
    Blockly.Events.CommentChange.superClass_.fromJson.call(this, json);
    this.newContents_ = json["newValue"]
};
Blockly.Events.CommentChange.prototype.isNull = function() {
    return this.oldContents_ == this.newContents_
};
Blockly.Events.CommentChange.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    var comment = workspace.getCommentById(this.commentId);
    if (!comment) {
        console.warn("Can't change non-existent comment: " + this.commentId);
        return
    }
    var contents = forward ? this.newContents_ : this.oldContents_;
    comment.setContent(contents)
};
Blockly.Events.CommentCreate = function(comment) {
    if (!comment) return;
    Blockly.Events.CommentCreate.superClass_.constructor.call(this, comment);
    this.xml = comment.toXmlWithXY()
};
goog.inherits(Blockly.Events.CommentCreate, Blockly.Events.CommentBase);
Blockly.Events.CommentCreate.prototype.type = Blockly.Events.COMMENT_CREATE;
Blockly.Events.CommentCreate.prototype.toJson = function() {
    var json = Blockly.Events.CommentCreate.superClass_.toJson.call(this);
    json["xml"] = Blockly.Xml.domToText(this.xml);
    return json
};
Blockly.Events.CommentCreate.prototype.fromJson = function(json) {
    Blockly.Events.CommentCreate.superClass_.fromJson.call(this, json);
    this.xml = Blockly.Xml.textToDom("<xml>" + json["xml"] + "</xml>").firstChild
};
Blockly.Events.CommentCreate.prototype.run = function(forward) {
    Blockly.Events.CommentCreateDeleteHelper(this, forward)
};
Blockly.Events.CommentCreateDeleteHelper = function(event, create) {
    var workspace = event.getEventWorkspace_();
    if (create) {
        var xml = Blockly.Xml.utils.createElement("xml");
        xml.appendChild(event.xml);
        Blockly.Xml.domToWorkspace(xml, workspace)
    } else {
        var comment = workspace.getCommentById(event.commentId);
        if (comment) comment.dispose(false, false);
        else console.warn("Can't uncreate non-existent comment: " + event.commentId)
    }
};
Blockly.Events.CommentDelete = function(comment) {
    if (!comment) return;
    Blockly.Events.CommentDelete.superClass_.constructor.call(this, comment);
    this.xml = comment.toXmlWithXY()
};
goog.inherits(Blockly.Events.CommentDelete, Blockly.Events.CommentBase);
Blockly.Events.CommentDelete.prototype.type = Blockly.Events.COMMENT_DELETE;
Blockly.Events.CommentDelete.prototype.toJson = function() {
    var json = Blockly.Events.CommentDelete.superClass_.toJson.call(this);
    return json
};
Blockly.Events.CommentDelete.prototype.fromJson = function(json) {
    Blockly.Events.CommentDelete.superClass_.fromJson.call(this, json)
};
Blockly.Events.CommentDelete.prototype.run = function(forward) {
    Blockly.Events.CommentCreateDeleteHelper(this, !forward)
};
Blockly.Events.CommentMove = function(comment) {
    if (!comment) return;
    Blockly.Events.CommentMove.superClass_.constructor.call(this, comment);
    this.comment_ = comment;
    this.oldCoordinate_ = comment.getXY();
    this.newCoordinate_ = null
};
goog.inherits(Blockly.Events.CommentMove, Blockly.Events.CommentBase);
Blockly.Events.CommentMove.prototype.recordNew = function() {
    if (!this.comment_) throw Error("Tried to record the new position of a comment on the " + "same event twice.");
    this.newCoordinate_ = this.comment_.getXY();
    this.comment_ = null
};
Blockly.Events.CommentMove.prototype.type = Blockly.Events.COMMENT_MOVE;
Blockly.Events.CommentMove.prototype.setOldCoordinate = function(xy) {
    this.oldCoordinate_ = xy
};
Blockly.Events.CommentMove.prototype.toJson = function() {
    var json = Blockly.Events.CommentMove.superClass_.toJson.call(this);
    if (this.newCoordinate_) json["newCoordinate"] = Math.round(this.newCoordinate_.x) + "," + Math.round(this.newCoordinate_.y);
    return json
};
Blockly.Events.CommentMove.prototype.fromJson = function(json) {
    Blockly.Events.CommentMove.superClass_.fromJson.call(this, json);
    if (json["newCoordinate"]) {
        var xy = json["newCoordinate"].split(",");
        this.newCoordinate_ = new goog.math.Coordinate(parseFloat(xy[0]), parseFloat(xy[1]))
    }
};
Blockly.Events.CommentMove.prototype.isNull = function() {
    return goog.math.Coordinate.equals(this.oldCoordinate_, this.newCoordinate_)
};
Blockly.Events.CommentMove.prototype.run = function(forward) {
    var workspace = this.getEventWorkspace_();
    var comment = workspace.getCommentById(this.commentId);
    if (!comment) {
        console.warn("Can't move non-existent comment: " + this.commentId);
        return
    }
    var target = forward ? this.newCoordinate_ : this.oldCoordinate_;
    var current = comment.getXY();
    comment.moveBy(target.x - current.x, target.y - current.y)
};
goog.provide("Blockly.Xml");
goog.require("Blockly.Events.BlockCreate");
goog.require("Blockly.Events.VarCreate");
goog.require("Blockly.Xml.utils");
Blockly.Xml.workspaceToDom = function(workspace, opt_noId) {
    var xml = Blockly.Xml.utils.createElement("xml");
    var variablesElement = Blockly.Xml.variablesToDom(Blockly.Variables.allUsedVarModels(workspace));
    if (variablesElement.hasChildNodes()) xml.appendChild(variablesElement);
    var comments = workspace.getTopComments(true);
    for (var i = 0, comment; comment = comments[i]; i++) xml.appendChild(comment.toXmlWithXY(opt_noId));
    var blocks = workspace.getTopBlocks(true);
    for (var i = 0, block; block = blocks[i]; i++) xml.appendChild(Blockly.Xml.blockToDomWithXY(block,
        opt_noId));
    return xml
};
Blockly.Xml.variablesToDom = function(variableList) {
    var variables = Blockly.Xml.utils.createElement("variables");
    for (var i = 0, variable; variable = variableList[i]; i++) {
        var element = Blockly.Xml.utils.createElement("variable");
        element.appendChild(Blockly.Xml.utils.createTextNode(variable.name));
        element.setAttribute("type", variable.type);
        element.setAttribute("id", variable.getId());
        variables.appendChild(element)
    }
    return variables
};
Blockly.Xml.blockToDomWithXY = function(block, opt_noId) {
    var width;
    if (block.workspace.RTL) width = block.workspace.getWidth();
    var element = Blockly.Xml.blockToDom(block, opt_noId);
    var xy = block.getRelativeToSurfaceXY();
    element.setAttribute("x", Math.round(block.workspace.RTL ? width - xy.x : xy.x));
    element.setAttribute("y", Math.round(xy.y));
    return element
};
Blockly.Xml.fieldToDomVariable_ = function(field) {
    var id = field.getValue();
    if (id == null) {
        field.initModel();
        id = field.getValue()
    }
    var variable = field.getVariable();
    if (!variable) throw Error("Tried to serialize a variable field with no variable.");
    var container = Blockly.Xml.utils.createElement("field");
    container.appendChild(Blockly.Xml.utils.createTextNode(variable.name));
    container.setAttribute("name", field.name);
    container.setAttribute("id", variable.getId());
    container.setAttribute("variabletype", variable.type);
    return container
};
Blockly.Xml.fieldToDom_ = function(field) {
    if (field.name && field.EDITABLE)
        if (field.referencesVariables()) return Blockly.Xml.fieldToDomVariable_(field);
        else {
            var container = Blockly.Xml.utils.createElement("field");
            container.appendChild(Blockly.Xml.utils.createTextNode(field.getValue()));
            container.setAttribute("name", field.name);
            return container
        } return null
};
Blockly.Xml.allFieldsToDom_ = function(block, element) {
    for (var i = 0, input; input = block.inputList[i]; i++)
        for (var j = 0, field; field = input.fieldRow[j]; j++) {
            var fieldDom = Blockly.Xml.fieldToDom_(field);
            if (fieldDom) element.appendChild(fieldDom)
        }
};
Blockly.Xml.blockToDom = function(block, opt_noId) {
    var element = Blockly.Xml.utils.createElement(block.isShadow() ? "shadow" : "block");
    element.setAttribute("type", block.type);
    if (!opt_noId) element.setAttribute("id", block.id);
    if (block.mutationToDom) {
        var mutation = block.mutationToDom();
        if (mutation && (mutation.hasChildNodes() || mutation.hasAttributes())) element.appendChild(mutation)
    }
    Blockly.Xml.allFieldsToDom_(block, element);
    var commentText = block.getCommentText();
    if (commentText) {
        var commentElement = Blockly.Xml.utils.createElement("comment");
        commentElement.appendChild(Blockly.Xml.utils.createTextNode(commentText));
        if (typeof block.comment == "object") {
            commentElement.setAttribute("pinned", block.comment.isVisible());
            var hw = block.comment.getBubbleSize();
            commentElement.setAttribute("h", hw.height);
            commentElement.setAttribute("w", hw.width)
        }
        element.appendChild(commentElement)
    }
    if (block.data) {
        var dataElement = Blockly.Xml.utils.createElement("data");
        dataElement.appendChild(Blockly.Xml.utils.createTextNode(block.data));
        element.appendChild(dataElement)
    }
    for (var i =
            0, input; input = block.inputList[i]; i++) {
        var container;
        var empty = true;
        if (input.type == Blockly.DUMMY_INPUT) continue;
        else {
            var childBlock = input.connection.targetBlock();
            if (input.type == Blockly.INPUT_VALUE) container = Blockly.Xml.utils.createElement("value");
            else if (input.type == Blockly.NEXT_STATEMENT) container = Blockly.Xml.utils.createElement("statement");
            var shadow = input.connection.getShadowDom();
            if (shadow && (!childBlock || !childBlock.isShadow())) container.appendChild(Blockly.Xml.cloneShadow_(shadow));
            if (childBlock) {
                container.appendChild(Blockly.Xml.blockToDom(childBlock,
                    opt_noId));
                empty = false
            }
        }
        container.setAttribute("name", input.name);
        if (!empty) element.appendChild(container)
    }
    if (block.inputsInlineDefault != block.inputsInline) element.setAttribute("inline", block.inputsInline);
    if (block.isCollapsed()) element.setAttribute("collapsed", true);
    if (block.disabled) element.setAttribute("disabled", true);
    if (!block.isDeletable() && !block.isShadow()) element.setAttribute("deletable", false);
    if (!block.isMovable() && !block.isShadow()) element.setAttribute("movable", false);
    if (!block.isEditable()) element.setAttribute("editable",
        false);
    var nextBlock = block.getNextBlock();
    if (nextBlock) {
        var container = Blockly.Xml.utils.createElement("next");
        container.appendChild(Blockly.Xml.blockToDom(nextBlock, opt_noId));
        element.appendChild(container)
    }
    var shadow = block.nextConnection && block.nextConnection.getShadowDom();
    if (shadow && (!nextBlock || !nextBlock.isShadow())) container.appendChild(Blockly.Xml.cloneShadow_(shadow));
    return element
};
Blockly.Xml.cloneShadow_ = function(shadow) {
    shadow = shadow.cloneNode(true);
    var node = shadow;
    var textNode;
    while (node)
        if (node.firstChild) node = node.firstChild;
        else {
            while (node && !node.nextSibling) {
                textNode = node;
                node = node.parentNode;
                if (textNode.nodeType == 3 && textNode.data.trim() == "" && node.firstChild != textNode) Blockly.utils.removeNode(textNode)
            }
            if (node) {
                textNode = node;
                node = node.nextSibling;
                if (textNode.nodeType == 3 && textNode.data.trim() == "") Blockly.utils.removeNode(textNode)
            }
        } return shadow
};
Blockly.Xml.domToText = function(dom) {
    return Blockly.Xml.utils.domToText(dom)
};
Blockly.Xml.domToPrettyText = function(dom) {
    var blob = Blockly.Xml.domToText(dom);
    var lines = blob.split("<");
    var indent = "";
    for (var i = 1; i < lines.length; i++) {
        var line = lines[i];
        if (line[0] == "/") indent = indent.substring(2);
        lines[i] = indent + "<" + line;
        if (line[0] != "/" && line.slice(-2) != "/>") indent += "  "
    }
    var text = lines.join("\n");
    text = text.replace(/(<(\w+)\b[^>]*>[^\n]*)\n *<\/\2>/g, "$1</$2>");
    return text.replace(/^\n/, "")
};
Blockly.Xml.textToDom = function(text) {
    var doc = Blockly.Xml.utils.textToDomDocument(text);
    if (!doc || !doc.documentElement || doc.documentElement.nodeName.toLowerCase() != "xml") throw TypeError("Blockly.Xml.textToDom expected an <xml> document.");
    return doc.documentElement
};
Blockly.Xml.clearWorkspaceAndLoadFromXml = function(xml, workspace) {
    workspace.setResizesEnabled(false);
    workspace.clear();
    var blockIds = Blockly.Xml.domToWorkspace(xml, workspace);
    workspace.setResizesEnabled(true);
    return blockIds
};
Blockly.Xml.domToWorkspace = function(xml, workspace) {
    if (xml instanceof Blockly.Workspace) {
        var swap = xml;
        xml = workspace;
        workspace = swap;
        console.warn("Deprecated call to Blockly.Xml.domToWorkspace, " + "swap the arguments.")
    }
    var width;
    if (workspace.RTL) width = workspace.getWidth();
    var newBlockIds = [];
    Blockly.Field.startCache();
    var childCount = xml.childNodes.length;
    var existingGroup = Blockly.Events.getGroup();
    if (!existingGroup) Blockly.Events.setGroup(true);
    if (workspace.setResizesEnabled) workspace.setResizesEnabled(false);
    var variablesFirst = true;
    try {
        for (var i = 0; i < childCount; i++) {
            var xmlChild = xml.childNodes[i];
            var name = xmlChild.nodeName.toLowerCase();
            if (name == "block" || name == "shadow" && !Blockly.Events.recordUndo) {
                var block = Blockly.Xml.domToBlock(xmlChild, workspace);
                newBlockIds.push(block.id);
                var blockX = xmlChild.hasAttribute("x") ? parseInt(xmlChild.getAttribute("x"), 10) : 10;
                var blockY = xmlChild.hasAttribute("y") ? parseInt(xmlChild.getAttribute("y"), 10) : 10;
                if (!isNaN(blockX) && !isNaN(blockY)) block.moveBy(workspace.RTL ? width -
                    blockX : blockX, blockY);
                variablesFirst = false
            } else if (name == "shadow") throw TypeError("Shadow block cannot be a top-level block.");
            else if (name == "comment")
                if (workspace.rendered) Blockly.WorkspaceCommentSvg.fromXml(xmlChild, workspace, width);
                else Blockly.WorkspaceComment.fromXml(xmlChild, workspace);
            else if (name == "variables") {
                if (variablesFirst) Blockly.Xml.domToVariables(xmlChild, workspace);
                else throw Error("'variables' tag must exist once before block and " + "shadow tag elements in the workspace XML, but it was found in " +
                    "another location.");
                variablesFirst = false
            }
        }
    } finally {
        if (!existingGroup) Blockly.Events.setGroup(false);
        Blockly.Field.stopCache()
    }
    if (workspace.setResizesEnabled) workspace.setResizesEnabled(true);
    return newBlockIds
};
Blockly.Xml.appendDomToWorkspace = function(xml, workspace) {
    var bbox;
    if (workspace.hasOwnProperty("scale")) {
        var savetab = Blockly.BlockSvg.TAB_WIDTH;
        try {
            Blockly.BlockSvg.TAB_WIDTH = 0;
            bbox = workspace.getBlocksBoundingBox()
        } finally {
            Blockly.BlockSvg.TAB_WIDTH = savetab
        }
    }
    var newBlockIds = Blockly.Xml.domToWorkspace(xml, workspace);
    if (bbox && bbox.height) {
        var offsetY = 0;
        var offsetX = 0;
        var farY = bbox.y + bbox.height;
        var topX = bbox.x;
        var newX = Infinity;
        var newY = Infinity;
        for (var i = 0; i < newBlockIds.length; i++) {
            var blockXY = workspace.getBlockById(newBlockIds[i]).getRelativeToSurfaceXY();
            if (blockXY.y < newY) newY = blockXY.y;
            if (blockXY.x < newX) newX = blockXY.x
        }
        offsetY = farY - newY + Blockly.BlockSvg.SEP_SPACE_Y;
        offsetX = topX - newX;
        var width;
        if (workspace.RTL) width = workspace.getWidth();
        for (var i = 0; i < newBlockIds.length; i++) {
            var block = workspace.getBlockById(newBlockIds[i]);
            block.moveBy(workspace.RTL ? width - offsetX : offsetX, offsetY)
        }
    }
    return newBlockIds
};
Blockly.Xml.domToBlock = function(xmlBlock, workspace) {
    if (xmlBlock instanceof Blockly.Workspace) {
        var swap = xmlBlock;
        xmlBlock = workspace;
        workspace = swap;
        console.warn("Deprecated call to Blockly.Xml.domToBlock, " + "swap the arguments.")
    }
    Blockly.Events.disable();
    var variablesBeforeCreation = workspace.getAllVariables();
    try {
        var topBlock = Blockly.Xml.domToBlockHeadless_(xmlBlock, workspace);
        var blocks = topBlock.getDescendants(false);
        if (workspace.rendered) {
            topBlock.setConnectionsHidden(true);
            for (var i = blocks.length -
                    1; i >= 0; i--) blocks[i].initSvg();
            for (var i = blocks.length - 1; i >= 0; i--) blocks[i].render(false);
            setTimeout(function() {
                if (topBlock.workspace) topBlock.setConnectionsHidden(false)
            }, 1);
            topBlock.updateDisabled();
            workspace.resizeContents()
        } else
            for (var i = blocks.length - 1; i >= 0; i--) blocks[i].initModel()
    } finally {
        Blockly.Events.enable()
    }
    if (Blockly.Events.isEnabled()) {
        var newVariables = Blockly.Variables.getAddedVariables(workspace, variablesBeforeCreation);
        for (var i = 0; i < newVariables.length; i++) {
            var thisVariable = newVariables[i];
            Blockly.Events.fire(new Blockly.Events.VarCreate(thisVariable))
        }
        Blockly.Events.fire(new Blockly.Events.BlockCreate(topBlock))
    }
    return topBlock
};
Blockly.Xml.domToVariables = function(xmlVariables, workspace) {
    for (var i = 0, xmlChild; xmlChild = xmlVariables.childNodes[i]; i++) {
        if (xmlChild.nodeType != Element.ELEMENT_NODE) continue;
        var type = xmlChild.getAttribute("type");
        var id = xmlChild.getAttribute("id");
        var name = xmlChild.textContent;
        if (type == null) throw Error("Variable with id, " + id + " is without a type");
        workspace.createVariable(name, type, id)
    }
};
Blockly.Xml.domToBlockHeadless_ = function(xmlBlock, workspace) {
    var block = null;
    var prototypeName = xmlBlock.getAttribute("type");
    if (!prototypeName) throw TypeError("Block type unspecified: " + xmlBlock.outerHTML);
    var id = xmlBlock.getAttribute("id");
    block = workspace.newBlock(prototypeName, id);
    var blockChild = null;
    for (var i = 0, xmlChild; xmlChild = xmlBlock.childNodes[i]; i++) {
        if (xmlChild.nodeType == 3) continue;
        var input;
        var childBlockElement = null;
        var childShadowElement = null;
        for (var j = 0, grandchild; grandchild = xmlChild.childNodes[j]; j++)
            if (grandchild.nodeType ==
                1)
                if (grandchild.nodeName.toLowerCase() == "block") childBlockElement = grandchild;
                else if (grandchild.nodeName.toLowerCase() == "shadow") childShadowElement = grandchild;
        if (!childBlockElement && childShadowElement) childBlockElement = childShadowElement;
        var name = xmlChild.getAttribute("name");
        switch (xmlChild.nodeName.toLowerCase()) {
            case "mutation":
                if (block.domToMutation) {
                    block.domToMutation(xmlChild);
                    if (block.initSvg) block.initSvg()
                }
                break;
            case "comment":
                block.setCommentText(xmlChild.textContent);
                var visible = xmlChild.getAttribute("pinned");
                if (visible && !block.isInFlyout) setTimeout(function() {
                    if (block.comment && block.comment.setVisible) block.comment.setVisible(visible == "true")
                }, 1);
                var bubbleW = parseInt(xmlChild.getAttribute("w"), 10);
                var bubbleH = parseInt(xmlChild.getAttribute("h"), 10);
                if (!isNaN(bubbleW) && !isNaN(bubbleH) && block.comment && block.comment.setVisible) block.comment.setBubbleSize(bubbleW, bubbleH);
                break;
            case "data":
                block.data = xmlChild.textContent;
                break;
            case "title":
            case "field":
                Blockly.Xml.domToField_(block, name, xmlChild);
                break;
            case "value":
            case "statement":
                input =
                    block.getInput(name);
                if (!input) {
                    console.warn("Ignoring non-existent input " + name + " in block " + prototypeName);
                    break
                }
                if (childShadowElement) input.connection.setShadowDom(childShadowElement);
                if (childBlockElement) {
                    blockChild = Blockly.Xml.domToBlockHeadless_(childBlockElement, workspace);
                    if (blockChild.outputConnection) input.connection.connect(blockChild.outputConnection);
                    else if (blockChild.previousConnection) input.connection.connect(blockChild.previousConnection);
                    else throw TypeError("Child block does not have output or previous statement.");
                }
                break;
            case "next":
                if (childShadowElement && block.nextConnection) block.nextConnection.setShadowDom(childShadowElement);
                if (childBlockElement) {
                    if (!block.nextConnection) throw TypeError("Next statement does not exist.");
                    if (block.nextConnection.isConnected()) throw TypeError("Next statement is already connected.");
                    blockChild = Blockly.Xml.domToBlockHeadless_(childBlockElement, workspace);
                    if (!blockChild.previousConnection) throw TypeError("Next block does not have previous statement.");
                    block.nextConnection.connect(blockChild.previousConnection)
                }
                break;
            default:
                console.warn("Ignoring unknown tag: " + xmlChild.nodeName)
        }
    }
    var inline = xmlBlock.getAttribute("inline");
    if (inline) block.setInputsInline(inline == "true");
    var disabled = xmlBlock.getAttribute("disabled");
    if (disabled) block.setDisabled(disabled == "true" || disabled == "disabled");
    var deletable = xmlBlock.getAttribute("deletable");
    if (deletable) block.setDeletable(deletable == "true");
    var movable = xmlBlock.getAttribute("movable");
    if (movable) block.setMovable(movable == "true");
    var editable = xmlBlock.getAttribute("editable");
    if (editable) block.setEditable(editable == "true");
    var collapsed = xmlBlock.getAttribute("collapsed");
    if (collapsed) block.setCollapsed(collapsed == "true");
    if (xmlBlock.nodeName.toLowerCase() == "shadow") {
        var children = block.getChildren(false);
        for (var i = 0, child; child = children[i]; i++)
            if (!child.isShadow()) throw TypeError("Shadow block not allowed non-shadow child.");
        if (block.getVarModels().length) throw TypeError("Shadow blocks cannot have variable references.");
        block.setShadow(true)
    }
    return block
};
Blockly.Xml.domToFieldVariable_ = function(workspace, xml, text, field) {
    var type = xml.getAttribute("variabletype") || "";
    if (type == "''") type = "";
    var variable = Blockly.Variables.getOrCreateVariablePackage(workspace, xml.id, text, type);
    if (type != null && type !== variable.type) throw Error("Serialized variable type with id '" + variable.getId() + "' had type " + variable.type + ", and " + "does not match variable field that references it: " + Blockly.Xml.domToText(xml) + ".");
    field.setValue(variable.getId())
};
Blockly.Xml.domToField_ = function(block, fieldName, xml) {
    var field = block.getField(fieldName);
    if (!field) {
        console.warn("Ignoring non-existent field " + fieldName + " in block " + block.type);
        return
    }
    var workspace = block.workspace;
    var text = xml.textContent;
    if (field.referencesVariables()) Blockly.Xml.domToFieldVariable_(workspace, xml, text, field);
    else field.setValue(text)
};
Blockly.Xml.deleteNext = function(xmlBlock) {
    for (var i = 0, child; child = xmlBlock.childNodes[i]; i++)
        if (child.nodeName.toLowerCase() == "next") {
            xmlBlock.removeChild(child);
            break
        }
};
if (!goog.global["Blockly"]) goog.global["Blockly"] = {};
if (!goog.global["Blockly"]["Xml"]) goog.global["Blockly"]["Xml"] = {};
goog.global["Blockly"]["Xml"]["domToText"] = Blockly.Xml.domToText;
goog.global["Blockly"]["Xml"]["domToWorkspace"] = Blockly.Xml.domToWorkspace;
goog.global["Blockly"]["Xml"]["textToDom"] = Blockly.Xml.textToDom;
goog.global["Blockly"]["Xml"]["workspaceToDom"] = Blockly.Xml.workspaceToDom;
goog.provide("Blockly.Xml.utils");
Blockly.Xml.utils.createElement = function(tagName) {
    return document.createElement(tagName)
};
Blockly.Xml.utils.createTextNode = function(text) {
    return document.createTextNode(text)
};
Blockly.Xml.utils.textToDomDocument = function(text) {
    var oParser = new DOMParser;
    return oParser.parseFromString(text, "text/xml")
};
Blockly.Xml.utils.domToText = function(dom) {
    var oSerializer = new XMLSerializer;
    return oSerializer.serializeToString(dom)
};
goog.provide("Blockly.ZoomControls");
goog.require("Blockly.Touch");
goog.require("Blockly.utils");
Blockly.ZoomControls = function(workspace) {
    this.workspace_ = workspace
};
Blockly.ZoomControls.prototype.WIDTH_ = 32;
Blockly.ZoomControls.prototype.HEIGHT_ = 110;
Blockly.ZoomControls.prototype.MARGIN_BOTTOM_ = 20;
Blockly.ZoomControls.prototype.MARGIN_SIDE_ = 28;
Blockly.ZoomControls.prototype.svgGroup_ = null;
Blockly.ZoomControls.prototype.left_ = 0;
Blockly.ZoomControls.prototype.top_ = 0;
Blockly.ZoomControls.prototype.createDom = function() {
    this.svgGroup_ = Blockly.utils.createSvgElement("g", {
        "class": "blocklyZoom"
    }, null);
    var rnd = String(Math.random()).substring(2);
    this.createZoomOutSvg_(rnd);
    this.createZoomInSvg_(rnd);
    this.createZoomResetSvg_(rnd);
    return this.svgGroup_
};
Blockly.ZoomControls.prototype.init = function(bottom) {
    this.bottom_ = this.MARGIN_BOTTOM_ + bottom;
    return this.bottom_ + this.HEIGHT_
};
Blockly.ZoomControls.prototype.dispose = function() {
    if (this.svgGroup_) {
        Blockly.utils.removeNode(this.svgGroup_);
        this.svgGroup_ = null
    }
    this.workspace_ = null
};
Blockly.ZoomControls.prototype.position = function() {
    var metrics = this.workspace_.getMetrics();
    if (!metrics) return;
    if (this.workspace_.RTL) {
        this.left_ = this.MARGIN_SIDE_ + Blockly.Scrollbar.scrollbarThickness;
        if (metrics.toolboxPosition == Blockly.TOOLBOX_AT_LEFT) {
            this.left_ += metrics.flyoutWidth;
            if (this.workspace_.toolbox_) this.left_ += metrics.absoluteLeft
        }
    } else {
        this.left_ = metrics.viewWidth + metrics.absoluteLeft - this.WIDTH_ - this.MARGIN_SIDE_ - Blockly.Scrollbar.scrollbarThickness;
        if (metrics.toolboxPosition == Blockly.TOOLBOX_AT_RIGHT) this.left_ -=
            metrics.flyoutWidth
    }
    this.top_ = metrics.viewHeight + metrics.absoluteTop - this.HEIGHT_ - this.bottom_;
    if (metrics.toolboxPosition == Blockly.TOOLBOX_AT_BOTTOM) this.top_ -= metrics.flyoutHeight;
    this.svgGroup_.setAttribute("transform", "translate(" + this.left_ + "," + this.top_ + ")")
};
Blockly.ZoomControls.prototype.createZoomOutSvg_ = function(rnd) {
    var ws = this.workspace_;
    var clip = Blockly.utils.createSvgElement("clipPath", {
        "id": "blocklyZoomoutClipPath" + rnd
    }, this.svgGroup_);
    Blockly.utils.createSvgElement("rect", {
        "width": 32,
        "height": 32,
        "y": 77
    }, clip);
    var zoomoutSvg = Blockly.utils.createSvgElement("image", {
        "width": Blockly.SPRITE.width,
        "height": Blockly.SPRITE.height,
        "x": -64,
        "y": -15,
        "clip-path": "url(#blocklyZoomoutClipPath" + rnd + ")"
    }, this.svgGroup_);
    zoomoutSvg.setAttributeNS("http://www.w3.org/1999/xlink",
        "xlink:href", ws.options.pathToMedia + Blockly.SPRITE.url);
    Blockly.bindEventWithChecks_(zoomoutSvg, "mousedown", null, function(e) {
        ws.markFocused();
        ws.zoomCenter(-1);
        Blockly.Touch.clearTouchIdentifier();
        e.stopPropagation();
        e.preventDefault()
    })
};
Blockly.ZoomControls.prototype.createZoomInSvg_ = function(rnd) {
    var ws = this.workspace_;
    var clip = Blockly.utils.createSvgElement("clipPath", {
        "id": "blocklyZoominClipPath" + rnd
    }, this.svgGroup_);
    Blockly.utils.createSvgElement("rect", {
        "width": 32,
        "height": 32,
        "y": 43
    }, clip);
    var zoominSvg = Blockly.utils.createSvgElement("image", {
        "width": Blockly.SPRITE.width,
        "height": Blockly.SPRITE.height,
        "x": -32,
        "y": -49,
        "clip-path": "url(#blocklyZoominClipPath" + rnd + ")"
    }, this.svgGroup_);
    zoominSvg.setAttributeNS("http://www.w3.org/1999/xlink",
        "xlink:href", ws.options.pathToMedia + Blockly.SPRITE.url);
    Blockly.bindEventWithChecks_(zoominSvg, "mousedown", null, function(e) {
        ws.markFocused();
        ws.zoomCenter(1);
        Blockly.Touch.clearTouchIdentifier();
        e.stopPropagation();
        e.preventDefault()
    })
};
Blockly.ZoomControls.prototype.createZoomResetSvg_ = function(rnd) {
    var ws = this.workspace_;
    var clip = Blockly.utils.createSvgElement("clipPath", {
        "id": "blocklyZoomresetClipPath" + rnd
    }, this.svgGroup_);
    Blockly.utils.createSvgElement("rect", {
        "width": 32,
        "height": 32
    }, clip);
    var zoomresetSvg = Blockly.utils.createSvgElement("image", {
        "width": Blockly.SPRITE.width,
        "height": Blockly.SPRITE.height,
        "y": -92,
        "clip-path": "url(#blocklyZoomresetClipPath" + rnd + ")"
    }, this.svgGroup_);
    zoomresetSvg.setAttributeNS("http://www.w3.org/1999/xlink",
        "xlink:href", ws.options.pathToMedia + Blockly.SPRITE.url);
    Blockly.bindEventWithChecks_(zoomresetSvg, "mousedown", null, function(e) {
        ws.markFocused();
        ws.setScale(ws.options.zoomOptions.startScale);
        ws.beginCanvasTransition();
        ws.scrollCenter();
        setTimeout(function() {
            ws.endCanvasTransition()
        }, 500);
        Blockly.Touch.clearTouchIdentifier();
        e.stopPropagation();
        e.preventDefault()
    })
};