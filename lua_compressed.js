// Do not edit this file; automatically generated by build.py.
'use strict';

goog.provide("Blockly.Generator");
goog.provide("Blockly.Lua");
goog.require("Blockly.Generator");
Blockly.Lua = new Blockly.Generator("Lua");
Blockly.Lua.addReservedWords("_," + "__inext,assert,bit,colors,colours,coroutine,disk,dofile,error,fs," + "fetfenv,getmetatable,gps,help,io,ipairs,keys,loadfile,loadstring,math," + "native,next,os,paintutils,pairs,parallel,pcall,peripheral,print," + "printError,rawequal,rawget,rawset,read,rednet,redstone,rs,select," + "setfenv,setmetatable,sleep,string,table,term,textutils,tonumber," + "tostring,turtle,type,unpack,vector,write,xpcall,_VERSION,__indext," + "HTTP," + "and,break,do,else,elseif,end,false,for,function,if,in,local,nil,not,or," +
    "repeat,return,then,true,until,while," + "add,sub,mul,div,mod,pow,unm,concat,len,eq,lt,le,index,newindex,call," + "assert,collectgarbage,dofile,error,_G,getmetatable,inpairs,load," + "loadfile,next,pairs,pcall,print,rawequal,rawget,rawlen,rawset,select," + "setmetatable,tonumber,tostring,type,_VERSION,xpcall," + "require,package,string,table,math,bit32,io,file,os,debug");
Blockly.Lua.ORDER_ATOMIC = 0;
Blockly.Lua.ORDER_HIGH = 1;
Blockly.Lua.ORDER_EXPONENTIATION = 2;
Blockly.Lua.ORDER_UNARY = 3;
Blockly.Lua.ORDER_MULTIPLICATIVE = 4;
Blockly.Lua.ORDER_ADDITIVE = 5;
Blockly.Lua.ORDER_CONCATENATION = 6;
Blockly.Lua.ORDER_RELATIONAL = 7;
Blockly.Lua.ORDER_AND = 8;
Blockly.Lua.ORDER_OR = 9;
Blockly.Lua.ORDER_NONE = 99;
Blockly.Lua.init = function(workspace) {
    Blockly.Lua.definitions_ = Object.create(null);
    Blockly.Lua.functionNames_ = Object.create(null);
    if (!Blockly.Lua.variableDB_) Blockly.Lua.variableDB_ = new Blockly.Names(Blockly.Lua.RESERVED_WORDS_);
    else Blockly.Lua.variableDB_.reset();
    Blockly.Lua.variableDB_.setVariableMap(workspace.getVariableMap())
};
Blockly.Lua.finish = function(code) {
    var definitions = [];
    for (var name in Blockly.Lua.definitions_) definitions.push(Blockly.Lua.definitions_[name]);
    delete Blockly.Lua.definitions_;
    delete Blockly.Lua.functionNames_;
    Blockly.Lua.variableDB_.reset();
    return definitions.join("\n\n") + "\n\n\n" + code
};
Blockly.Lua.scrubNakedValue = function(line) {
    return "local _ = " + line + "\n"
};
Blockly.Lua.quote_ = function(string) {
    string = string.replace(/\\/g, "\\\\").replace(/\n/g, "\\\n").replace(/'/g, "\\'");
    return "'" + string + "'"
};
Blockly.Lua.scrub_ = function(block, code) {
    var commentCode = "";
    if (!block.outputConnection || !block.outputConnection.targetConnection) {
        var comment = block.getCommentText();
        comment = Blockly.utils.wrap(comment, Blockly.Lua.COMMENT_WRAP - 3);
        if (comment) commentCode += Blockly.Lua.prefixLines(comment, "-- ") + "\n";
        for (var i = 0; i < block.inputList.length; i++)
            if (block.inputList[i].type == Blockly.INPUT_VALUE) {
                var childBlock = block.inputList[i].connection.targetBlock();
                if (childBlock) {
                    comment = Blockly.Lua.allNestedComments(childBlock);
                    if (comment) commentCode += Blockly.Lua.prefixLines(comment, "-- ")
                }
            }
    }
    var nextBlock = block.nextConnection && block.nextConnection.targetBlock();
    var nextCode = Blockly.Lua.blockToCode(nextBlock);
    return commentCode + code + nextCode
};
goog.provide("Blockly.Lua.colour");
goog.require("Blockly.Lua");
Blockly.Lua["colour_picker"] = function(block) {
    var code = "'" + block.getFieldValue("COLOUR") + "'";
    return [code, Blockly.Lua.ORDER_ATOMIC]
};
Blockly.Lua["colour_random"] = function(block) {
    var code = 'string.format("#%06x", math.random(0, 2^24 - 1))';
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["colour_rgb"] = function(block) {
    var functionName = Blockly.Lua.provideFunction_("colour_rgb", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(r, g, b)", "  r = math.floor(math.min(100, math.max(0, r)) * 2.55 + .5)", "  g = math.floor(math.min(100, math.max(0, g)) * 2.55 + .5)", "  b = math.floor(math.min(100, math.max(0, b)) * 2.55 + .5)", '  return string.format("#%02x%02x%02x", r, g, b)', "end"]);
    var r = Blockly.Lua.valueToCode(block, "RED", Blockly.Lua.ORDER_NONE) || 0;
    var g = Blockly.Lua.valueToCode(block,
        "GREEN", Blockly.Lua.ORDER_NONE) || 0;
    var b = Blockly.Lua.valueToCode(block, "BLUE", Blockly.Lua.ORDER_NONE) || 0;
    var code = functionName + "(" + r + ", " + g + ", " + b + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["colour_blend"] = function(block) {
    var functionName = Blockly.Lua.provideFunction_("colour_blend", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(colour1, colour2, ratio)", "  local r1 = tonumber(string.sub(colour1, 2, 3), 16)", "  local r2 = tonumber(string.sub(colour2, 2, 3), 16)", "  local g1 = tonumber(string.sub(colour1, 4, 5), 16)", "  local g2 = tonumber(string.sub(colour2, 4, 5), 16)", "  local b1 = tonumber(string.sub(colour1, 6, 7), 16)", "  local b2 = tonumber(string.sub(colour2, 6, 7), 16)",
        "  local ratio = math.min(1, math.max(0, ratio))", "  local r = math.floor(r1 * (1 - ratio) + r2 * ratio + .5)", "  local g = math.floor(g1 * (1 - ratio) + g2 * ratio + .5)", "  local b = math.floor(b1 * (1 - ratio) + b2 * ratio + .5)", '  return string.format("#%02x%02x%02x", r, g, b)', "end"
    ]);
    var colour1 = Blockly.Lua.valueToCode(block, "COLOUR1", Blockly.Lua.ORDER_NONE) || "'#000000'";
    var colour2 = Blockly.Lua.valueToCode(block, "COLOUR2", Blockly.Lua.ORDER_NONE) || "'#000000'";
    var ratio = Blockly.Lua.valueToCode(block,
        "RATIO", Blockly.Lua.ORDER_NONE) || 0;
    var code = functionName + "(" + colour1 + ", " + colour2 + ", " + ratio + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
goog.provide("Blockly.Lua.lists");
goog.require("Blockly.Lua");
Blockly.Lua["lists_create_empty"] = function(block) {
    return ["{}", Blockly.Lua.ORDER_ATOMIC]
};
Blockly.Lua["lists_create_with"] = function(block) {
    var elements = new Array(block.itemCount_);
    for (var i = 0; i < block.itemCount_; i++) elements[i] = Blockly.Lua.valueToCode(block, "ADD" + i, Blockly.Lua.ORDER_NONE) || "None";
    var code = "{" + elements.join(", ") + "}";
    return [code, Blockly.Lua.ORDER_ATOMIC]
};
Blockly.Lua["lists_repeat"] = function(block) {
    var functionName = Blockly.Lua.provideFunction_("create_list_repeated", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(item, count)", "  local t = {}", "  for i = 1, count do", "    table.insert(t, item)", "  end", "  return t", "end"]);
    var element = Blockly.Lua.valueToCode(block, "ITEM", Blockly.Lua.ORDER_NONE) || "None";
    var repeatCount = Blockly.Lua.valueToCode(block, "NUM", Blockly.Lua.ORDER_NONE) || "0";
    var code = functionName + "(" + element + ", " + repeatCount + ")";
    return [code,
        Blockly.Lua.ORDER_HIGH
    ]
};
Blockly.Lua["lists_length"] = function(block) {
    var list = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_UNARY) || "{}";
    return ["#" + list, Blockly.Lua.ORDER_UNARY]
};
Blockly.Lua["lists_isEmpty"] = function(block) {
    var list = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_UNARY) || "{}";
    var code = "#" + list + " == 0";
    return [code, Blockly.Lua.ORDER_RELATIONAL]
};
Blockly.Lua["lists_indexOf"] = function(block) {
    var item = Blockly.Lua.valueToCode(block, "FIND", Blockly.Lua.ORDER_NONE) || "''";
    var list = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_NONE) || "{}";
    if (block.getFieldValue("END") == "FIRST") var functionName = Blockly.Lua.provideFunction_("first_index", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t, elem)", "  for k, v in ipairs(t) do", "    if v == elem then", "      return k", "    end", "  end", "  return 0", "end"]);
    else var functionName = Blockly.Lua.provideFunction_("last_index",
        ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t, elem)", "  for i = #t, 1, -1 do", "    if t[i] == elem then", "      return i", "    end", "  end", "  return 0", "end"]);
    var code = functionName + "(" + list + ", " + item + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua.lists.getIndex_ = function(listName, where, opt_at) {
    if (where == "FIRST") return "1";
    else if (where == "FROM_END") return "#" + listName + " + 1 - " + opt_at;
    else if (where == "LAST") return "#" + listName;
    else if (where == "RANDOM") return "math.random(#" + listName + ")";
    else return opt_at
};
Blockly.Lua["lists_getIndex"] = function(block) {
    var mode = block.getFieldValue("MODE") || "GET";
    var where = block.getFieldValue("WHERE") || "FROM_START";
    var list = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_HIGH) || "{}";
    var getIndex_ = Blockly.Lua.lists.getIndex_;
    if ((where == "LAST" || where == "FROM_END" || where == "RANDOM") && !list.match(/^\w+$/))
        if (mode == "REMOVE") {
            var atOrder = where == "FROM_END" ? Blockly.Lua.ORDER_ADDITIVE : Blockly.Lua.ORDER_NONE;
            var at = Blockly.Lua.valueToCode(block, "AT", atOrder) || "1";
            var listVar =
                Blockly.Lua.variableDB_.getDistinctName("tmp_list", Blockly.Variables.NAME_TYPE);
            at = getIndex_(listVar, where, at);
            var code = listVar + " = " + list + "\n" + "table.remove(" + listVar + ", " + at + ")\n";
            return code
        } else {
            var at = Blockly.Lua.valueToCode(block, "AT", Blockly.Lua.ORDER_NONE) || "1";
            if (mode == "GET") var functionName = Blockly.Lua.provideFunction_("list_get_" + where.toLowerCase(), ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t" + (where == "FROM_END" || where == "FROM_START" ? ", at)" : ")"), "  return t[" + getIndex_("t",
                where, "at") + "]", "end"]);
            else var functionName = Blockly.Lua.provideFunction_("list_remove_" + where.toLowerCase(), ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t" + (where == "FROM_END" || where == "FROM_START" ? ", at)" : ")"), "  return table.remove(t, " + getIndex_("t", where, "at") + ")", "end"]);
            var code = functionName + "(" + list + (where == "FROM_END" || where == "FROM_START" ? ", " + at : "") + ")";
            return [code, Blockly.Lua.ORDER_HIGH]
        }
    else {
        var atOrder = mode == "GET" && where == "FROM_END" ? Blockly.Lua.ORDER_ADDITIVE : Blockly.Lua.ORDER_NONE;
        var at = Blockly.Lua.valueToCode(block, "AT", atOrder) || "1";
        at = getIndex_(list, where, at);
        if (mode == "GET") {
            var code = list + "[" + at + "]";
            return [code, Blockly.Lua.ORDER_HIGH]
        } else {
            var code = "table.remove(" + list + ", " + at + ")";
            if (mode == "GET_REMOVE") return [code, Blockly.Lua.ORDER_HIGH];
            else return code + "\n"
        }
    }
};
Blockly.Lua["lists_setIndex"] = function(block) {
    var list = Blockly.Lua.valueToCode(block, "LIST", Blockly.Lua.ORDER_HIGH) || "{}";
    var mode = block.getFieldValue("MODE") || "SET";
    var where = block.getFieldValue("WHERE") || "FROM_START";
    var at = Blockly.Lua.valueToCode(block, "AT", Blockly.Lua.ORDER_ADDITIVE) || "1";
    var value = Blockly.Lua.valueToCode(block, "TO", Blockly.Lua.ORDER_NONE) || "None";
    var getIndex_ = Blockly.Lua.lists.getIndex_;
    var code = "";
    if ((where == "LAST" || where == "FROM_END" || where == "RANDOM") && !list.match(/^\w+$/)) {
        var listVar =
            Blockly.Lua.variableDB_.getDistinctName("tmp_list", Blockly.Variables.NAME_TYPE);
        code = listVar + " = " + list + "\n";
        list = listVar
    }
    if (mode == "SET") code += list + "[" + getIndex_(list, where, at) + "] = " + value;
    else code += "table.insert(" + list + ", " + (getIndex_(list, where, at) + (where == "LAST" ? " + 1" : "")) + ", " + value + ")";
    return code + "\n"
};
Blockly.Lua["lists_getSublist"] = function(block) {
    var list = Blockly.Lua.valueToCode(block, "LIST", Blockly.Lua.ORDER_NONE) || "{}";
    var where1 = block.getFieldValue("WHERE1");
    var where2 = block.getFieldValue("WHERE2");
    var at1 = Blockly.Lua.valueToCode(block, "AT1", Blockly.Lua.ORDER_NONE) || "1";
    var at2 = Blockly.Lua.valueToCode(block, "AT2", Blockly.Lua.ORDER_NONE) || "1";
    var getIndex_ = Blockly.Lua.lists.getIndex_;
    var functionName = Blockly.Lua.provideFunction_("list_sublist_" + where1.toLowerCase() + "_" + where2.toLowerCase(),
        ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(source" + (where1 == "FROM_END" || where1 == "FROM_START" ? ", at1" : "") + (where2 == "FROM_END" || where2 == "FROM_START" ? ", at2" : "") + ")", "  local t = {}", "  local start = " + getIndex_("source", where1, "at1"), "  local finish = " + getIndex_("source", where2, "at2"), "  for i = start, finish do", "    table.insert(t, source[i])", "  end", "  return t", "end"]);
    var code = functionName + "(" + list + (where1 == "FROM_END" || where1 == "FROM_START" ? ", " + at1 : "") + (where2 == "FROM_END" || where2 ==
        "FROM_START" ? ", " + at2 : "") + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["lists_sort"] = function(block) {
    var list = Blockly.Lua.valueToCode(block, "LIST", Blockly.Lua.ORDER_NONE) || "{}";
    var direction = block.getFieldValue("DIRECTION") === "1" ? 1 : -1;
    var type = block.getFieldValue("TYPE");
    var functionName = Blockly.Lua.provideFunction_("list_sort", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(list, typev, direction)", "  local t = {}", "  for n,v in pairs(list) do table.insert(t, v) end", "  local compareFuncs = {", "    NUMERIC = function(a, b)", "      return (tonumber(tostring(a)) or 0)",
        "          < (tonumber(tostring(b)) or 0) end,", "    TEXT = function(a, b)", "      return tostring(a) < tostring(b) end,", "    IGNORE_CASE = function(a, b)", "      return string.lower(tostring(a)) < string.lower(tostring(b)) end", "  }", "  local compareTemp = compareFuncs[typev]", "  local compare = compareTemp", "  if direction == -1", "  then compare = function(a, b) return compareTemp(b, a) end", "  end", "  table.sort(t, compare)", "  return t", "end"
    ]);
    var code = functionName + "(" + list + ',"' + type + '", ' +
        direction + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["lists_split"] = function(block) {
    var input = Blockly.Lua.valueToCode(block, "INPUT", Blockly.Lua.ORDER_NONE);
    var delimiter = Blockly.Lua.valueToCode(block, "DELIM", Blockly.Lua.ORDER_NONE) || "''";
    var mode = block.getFieldValue("MODE");
    var functionName;
    if (mode == "SPLIT") {
        if (!input) input = "''";
        functionName = Blockly.Lua.provideFunction_("list_string_split", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(input, delim)", "  local t = {}", "  local pos = 1", "  while true do", "    next_delim = string.find(input, delim, pos)",
            "    if next_delim == nil then", "      table.insert(t, string.sub(input, pos))", "      break", "    else", "      table.insert(t, string.sub(input, pos, next_delim-1))", "      pos = next_delim + #delim", "    end", "  end", "  return t", "end"
        ])
    } else if (mode == "JOIN") {
        if (!input) input = "{}";
        functionName = "table.concat"
    } else throw Error("Unknown mode: " + mode);
    var code = functionName + "(" + input + ", " + delimiter + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["lists_reverse"] = function(block) {
    var list = Blockly.Lua.valueToCode(block, "LIST", Blockly.Lua.ORDER_NONE) || "{}";
    var functionName = Blockly.Lua.provideFunction_("list_reverse", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(input)", "  local reversed = {}", "  for i = #input, 1, -1 do", "    table.insert(reversed, input[i])", "  end", "  return reversed", "end"]);
    var code = "list_reverse(" + list + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
goog.provide("Blockly.Lua.logic");
goog.require("Blockly.Lua");
Blockly.Lua["controls_if"] = function(block) {
    var n = 0;
    var code = "",
        branchCode, conditionCode;
    do {
        conditionCode = Blockly.Lua.valueToCode(block, "IF" + n, Blockly.Lua.ORDER_NONE) || "false";
        branchCode = Blockly.Lua.statementToCode(block, "DO" + n);
        code += (n > 0 ? "else" : "") + "if " + conditionCode + " then\n" + branchCode;
        ++n
    } while (block.getInput("IF" + n));
    if (block.getInput("ELSE")) {
        branchCode = Blockly.Lua.statementToCode(block, "ELSE");
        code += "else\n" + branchCode
    }
    return code + "end\n"
};
Blockly.Lua["controls_ifelse"] = Blockly.Lua["controls_if"];
Blockly.Lua["logic_compare"] = function(block) {
    var OPERATORS = {
        "EQ": "==",
        "NEQ": "~=",
        "LT": "<",
        "LTE": "<=",
        "GT": ">",
        "GTE": ">="
    };
    var operator = OPERATORS[block.getFieldValue("OP")];
    var argument0 = Blockly.Lua.valueToCode(block, "A", Blockly.Lua.ORDER_RELATIONAL) || "0";
    var argument1 = Blockly.Lua.valueToCode(block, "B", Blockly.Lua.ORDER_RELATIONAL) || "0";
    var code = argument0 + " " + operator + " " + argument1;
    return [code, Blockly.Lua.ORDER_RELATIONAL]
};
Blockly.Lua["logic_operation"] = function(block) {
    var operator = block.getFieldValue("OP") == "AND" ? "and" : "or";
    var order = operator == "and" ? Blockly.Lua.ORDER_AND : Blockly.Lua.ORDER_OR;
    var argument0 = Blockly.Lua.valueToCode(block, "A", order);
    var argument1 = Blockly.Lua.valueToCode(block, "B", order);
    if (!argument0 && !argument1) {
        argument0 = "false";
        argument1 = "false"
    } else {
        var defaultArgument = operator == "and" ? "true" : "false";
        if (!argument0) argument0 = defaultArgument;
        if (!argument1) argument1 = defaultArgument
    }
    var code = argument0 +
        " " + operator + " " + argument1;
    return [code, order]
};
Blockly.Lua["logic_negate"] = function(block) {
    var argument0 = Blockly.Lua.valueToCode(block, "BOOL", Blockly.Lua.ORDER_UNARY) || "true";
    var code = "not " + argument0;
    return [code, Blockly.Lua.ORDER_UNARY]
};
Blockly.Lua["logic_boolean"] = function(block) {
    var code = block.getFieldValue("BOOL") == "TRUE" ? "true" : "false";
    return [code, Blockly.Lua.ORDER_ATOMIC]
};
Blockly.Lua["logic_null"] = function(block) {
    return ["nil", Blockly.Lua.ORDER_ATOMIC]
};
Blockly.Lua["logic_ternary"] = function(block) {
    var value_if = Blockly.Lua.valueToCode(block, "IF", Blockly.Lua.ORDER_AND) || "false";
    var value_then = Blockly.Lua.valueToCode(block, "THEN", Blockly.Lua.ORDER_AND) || "nil";
    var value_else = Blockly.Lua.valueToCode(block, "ELSE", Blockly.Lua.ORDER_OR) || "nil";
    var code = value_if + " and " + value_then + " or " + value_else;
    return [code, Blockly.Lua.ORDER_OR]
};
goog.provide("Blockly.Lua.loops");
goog.require("Blockly.Lua");
Blockly.Lua.CONTINUE_STATEMENT = "goto continue\n";
Blockly.Lua.addContinueLabel = function(branch) {
    if (branch.indexOf(Blockly.Lua.CONTINUE_STATEMENT) > -1) return branch + Blockly.Lua.INDENT + "::continue::\n";
    else return branch
};
Blockly.Lua["controls_repeat"] = function(block) {
    var repeats = parseInt(block.getFieldValue("TIMES"), 10);
    var branch = Blockly.Lua.statementToCode(block, "DO") || "";
    branch = Blockly.Lua.addContinueLabel(branch);
    var loopVar = Blockly.Lua.variableDB_.getDistinctName("count", Blockly.Variables.NAME_TYPE);
    var code = "for " + loopVar + " = 1, " + repeats + " do\n" + branch + "end\n";
    return code
};
Blockly.Lua["controls_repeat_ext"] = function(block) {
    var repeats = Blockly.Lua.valueToCode(block, "TIMES", Blockly.Lua.ORDER_NONE) || "0";
    if (Blockly.isNumber(repeats)) repeats = parseInt(repeats, 10);
    else repeats = "math.floor(" + repeats + ")";
    var branch = Blockly.Lua.statementToCode(block, "DO") || "\n";
    branch = Blockly.Lua.addContinueLabel(branch);
    var loopVar = Blockly.Lua.variableDB_.getDistinctName("count", Blockly.Variables.NAME_TYPE);
    var code = "for " + loopVar + " = 1, " + repeats + " do\n" + branch + "end\n";
    return code
};
Blockly.Lua["controls_whileUntil"] = function(block) {
    var until = block.getFieldValue("MODE") == "UNTIL";
    var argument0 = Blockly.Lua.valueToCode(block, "BOOL", until ? Blockly.Lua.ORDER_UNARY : Blockly.Lua.ORDER_NONE) || "false";
    var branch = Blockly.Lua.statementToCode(block, "DO") || "\n";
    branch = Blockly.Lua.addLoopTrap(branch, block.id);
    branch = Blockly.Lua.addContinueLabel(branch);
    if (until) argument0 = "not " + argument0;
    return "while " + argument0 + " do\n" + branch + "end\n"
};
Blockly.Lua["controls_for"] = function(block) {
    var variable0 = Blockly.Lua.variableDB_.getName(block.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    var startVar = Blockly.Lua.valueToCode(block, "FROM", Blockly.Lua.ORDER_NONE) || "0";
    var endVar = Blockly.Lua.valueToCode(block, "TO", Blockly.Lua.ORDER_NONE) || "0";
    var increment = Blockly.Lua.valueToCode(block, "BY", Blockly.Lua.ORDER_NONE) || "1";
    var branch = Blockly.Lua.statementToCode(block, "DO") || "\n";
    branch = Blockly.Lua.addLoopTrap(branch, block.id);
    branch = Blockly.Lua.addContinueLabel(branch);
    var code = "";
    var incValue;
    if (Blockly.isNumber(startVar) && Blockly.isNumber(endVar) && Blockly.isNumber(increment)) {
        var up = parseFloat(startVar) <= parseFloat(endVar);
        var step = Math.abs(parseFloat(increment));
        incValue = (up ? "" : "-") + step
    } else {
        code = "";
        incValue = Blockly.Lua.variableDB_.getDistinctName(variable0 + "_inc", Blockly.Variables.NAME_TYPE);
        code += incValue + " = ";
        if (Blockly.isNumber(increment)) code += Math.abs(increment) + "\n";
        else code += "math.abs(" + increment + ")\n";
        code += "if (" + startVar + ") > (" + endVar + ") then\n";
        code += Blockly.Lua.INDENT + incValue + " = -" + incValue + "\n";
        code += "end\n"
    }
    code += "for " + variable0 + " = " + startVar + ", " + endVar + ", " + incValue;
    code += " do\n" + branch + "end\n";
    return code
};
Blockly.Lua["controls_forEach"] = function(block) {
    var variable0 = Blockly.Lua.variableDB_.getName(block.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    var argument0 = Blockly.Lua.valueToCode(block, "LIST", Blockly.Lua.ORDER_NONE) || "{}";
    var branch = Blockly.Lua.statementToCode(block, "DO") || "\n";
    branch = Blockly.Lua.addContinueLabel(branch);
    var code = "for _, " + variable0 + " in ipairs(" + argument0 + ") do \n" + branch + "end\n";
    return code
};
Blockly.Lua["controls_flow_statements"] = function(block) {
    switch (block.getFieldValue("FLOW")) {
        case "BREAK":
            return "break\n";
        case "CONTINUE":
            return Blockly.Lua.CONTINUE_STATEMENT
    }
    throw Error("Unknown flow statement.");
};
goog.provide("Blockly.Lua.math");
goog.require("Blockly.Lua");
Blockly.Lua["math_number"] = function(block) {
    var code = parseFloat(block.getFieldValue("NUM"));
    var order = code < 0 ? Blockly.Lua.ORDER_UNARY : Blockly.Lua.ORDER_ATOMIC;
    return [code, order]
};
Blockly.Lua["math_arithmetic"] = function(block) {
    var OPERATORS = {
        ADD: [" + ", Blockly.Lua.ORDER_ADDITIVE],
        MINUS: [" - ", Blockly.Lua.ORDER_ADDITIVE],
        MULTIPLY: [" * ", Blockly.Lua.ORDER_MULTIPLICATIVE],
        DIVIDE: [" / ", Blockly.Lua.ORDER_MULTIPLICATIVE],
        POWER: [" ^ ", Blockly.Lua.ORDER_EXPONENTIATION]
    };
    var tuple = OPERATORS[block.getFieldValue("OP")];
    var operator = tuple[0];
    var order = tuple[1];
    var argument0 = Blockly.Lua.valueToCode(block, "A", order) || "0";
    var argument1 = Blockly.Lua.valueToCode(block, "B", order) || "0";
    var code =
        argument0 + operator + argument1;
    return [code, order]
};
Blockly.Lua["math_single"] = function(block) {
    var operator = block.getFieldValue("OP");
    var code;
    var arg;
    if (operator == "NEG") {
        arg = Blockly.Lua.valueToCode(block, "NUM", Blockly.Lua.ORDER_UNARY) || "0";
        return ["-" + arg, Blockly.Lua.ORDER_UNARY]
    }
    if (operator == "POW10") {
        arg = Blockly.Lua.valueToCode(block, "NUM", Blockly.Lua.ORDER_EXPONENTIATION) || "0";
        return ["10 ^ " + arg, Blockly.Lua.ORDER_EXPONENTIATION]
    }
    if (operator == "ROUND") arg = Blockly.Lua.valueToCode(block, "NUM", Blockly.Lua.ORDER_ADDITIVE) || "0";
    else arg = Blockly.Lua.valueToCode(block,
        "NUM", Blockly.Lua.ORDER_NONE) || "0";
    switch (operator) {
        case "ABS":
            code = "math.abs(" + arg + ")";
            break;
        case "ROOT":
            code = "math.sqrt(" + arg + ")";
            break;
        case "LN":
            code = "math.log(" + arg + ")";
            break;
        case "LOG10":
            code = "math.log(" + arg + ", 10)";
            break;
        case "EXP":
            code = "math.exp(" + arg + ")";
            break;
        case "ROUND":
            code = "math.floor(" + arg + " + .5)";
            break;
        case "ROUNDUP":
            code = "math.ceil(" + arg + ")";
            break;
        case "ROUNDDOWN":
            code = "math.floor(" + arg + ")";
            break;
        case "SIN":
            code = "math.sin(math.rad(" + arg + "))";
            break;
        case "COS":
            code = "math.cos(math.rad(" +
                arg + "))";
            break;
        case "TAN":
            code = "math.tan(math.rad(" + arg + "))";
            break;
        case "ASIN":
            code = "math.deg(math.asin(" + arg + "))";
            break;
        case "ACOS":
            code = "math.deg(math.acos(" + arg + "))";
            break;
        case "ATAN":
            code = "math.deg(math.atan(" + arg + "))";
            break;
        default:
            throw Error("Unknown math operator: " + operator);
    }
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["math_constant"] = function(block) {
    var CONSTANTS = {
        PI: ["math.pi", Blockly.Lua.ORDER_HIGH],
        E: ["math.exp(1)", Blockly.Lua.ORDER_HIGH],
        GOLDEN_RATIO: ["(1 + math.sqrt(5)) / 2", Blockly.Lua.ORDER_MULTIPLICATIVE],
        SQRT2: ["math.sqrt(2)", Blockly.Lua.ORDER_HIGH],
        SQRT1_2: ["math.sqrt(1 / 2)", Blockly.Lua.ORDER_HIGH],
        INFINITY: ["math.huge", Blockly.Lua.ORDER_HIGH]
    };
    return CONSTANTS[block.getFieldValue("CONSTANT")]
};
Blockly.Lua["math_number_property"] = function(block) {
    var number_to_check = Blockly.Lua.valueToCode(block, "NUMBER_TO_CHECK", Blockly.Lua.ORDER_MULTIPLICATIVE) || "0";
    var dropdown_property = block.getFieldValue("PROPERTY");
    var code;
    if (dropdown_property == "PRIME") {
        var functionName = Blockly.Lua.provideFunction_("math_isPrime", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(n)", "  -- https://en.wikipedia.org/wiki/Primality_test#Naive_methods", "  if n == 2 or n == 3 then", "    return true", "  end", "  -- False if n is NaN, negative, is 1, or not whole.",
            "  -- And false if n is divisible by 2 or 3.", "  if not(n > 1) or n % 1 ~= 0 or n % 2 == 0 or n % 3 == 0 then", "    return false", "  end", "  -- Check all the numbers of form 6k +/- 1, up to sqrt(n).", "  for x = 6, math.sqrt(n) + 1.5, 6 do", "    if n % (x - 1) == 0 or n % (x + 1) == 0 then", "      return false", "    end", "  end", "  return true", "end"
        ]);
        code = functionName + "(" + number_to_check + ")";
        return [code, Blockly.Lua.ORDER_HIGH]
    }
    switch (dropdown_property) {
        case "EVEN":
            code = number_to_check + " % 2 == 0";
            break;
        case "ODD":
            code = number_to_check + " % 2 == 1";
            break;
        case "WHOLE":
            code = number_to_check + " % 1 == 0";
            break;
        case "POSITIVE":
            code = number_to_check + " > 0";
            break;
        case "NEGATIVE":
            code = number_to_check + " < 0";
            break;
        case "DIVISIBLE_BY":
            var divisor = Blockly.Lua.valueToCode(block, "DIVISOR", Blockly.Lua.ORDER_MULTIPLICATIVE);
            if (!divisor || divisor == "0") return ["nil", Blockly.Lua.ORDER_ATOMIC];
            code = number_to_check + " % " + divisor + " == 0";
            break
    }
    return [code, Blockly.Lua.ORDER_RELATIONAL]
};
Blockly.Lua["math_change"] = function(block) {
    var argument0 = Blockly.Lua.valueToCode(block, "DELTA", Blockly.Lua.ORDER_ADDITIVE) || "0";
    var varName = Blockly.Lua.variableDB_.getName(block.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    return varName + " = " + varName + " + " + argument0 + "\n"
};
Blockly.Lua["math_round"] = Blockly.Lua["math_single"];
Blockly.Lua["math_trig"] = Blockly.Lua["math_single"];
Blockly.Lua["math_on_list"] = function(block) {
    var func = block.getFieldValue("OP");
    var list = Blockly.Lua.valueToCode(block, "LIST", Blockly.Lua.ORDER_NONE) || "{}";
    var functionName;

    function provideSum() {
        return Blockly.Lua.provideFunction_("math_sum", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t)", "  local result = 0", "  for _, v in ipairs(t) do", "    result = result + v", "  end", "  return result", "end"])
    }
    switch (func) {
        case "SUM":
            functionName = provideSum();
            break;
        case "MIN":
            functionName = Blockly.Lua.provideFunction_("math_min",
                ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t)", "  if #t == 0 then", "    return 0", "  end", "  local result = math.huge", "  for _, v in ipairs(t) do", "    if v < result then", "      result = v", "    end", "  end", "  return result", "end"]);
            break;
        case "AVERAGE":
            functionName = Blockly.Lua.provideFunction_("math_average", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t)", "  if #t == 0 then", "    return 0", "  end", "  return " + provideSum() + "(t) / #t", "end"]);
            break;
        case "MAX":
            functionName = Blockly.Lua.provideFunction_("math_max",
                ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t)", "  if #t == 0 then", "    return 0", "  end", "  local result = -math.huge", "  for _, v in ipairs(t) do", "    if v > result then", "      result = v", "    end", "  end", "  return result", "end"]);
            break;
        case "MEDIAN":
            functionName = Blockly.Lua.provideFunction_("math_median", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t)", "  -- Source: http://lua-users.org/wiki/SimpleStats", "  if #t == 0 then", "    return 0", "  end", "  local temp={}", "  for _, v in ipairs(t) do",
                '    if type(v) == "number" then', "      table.insert(temp, v)", "    end", "  end", "  table.sort(temp)", "  if #temp % 2 == 0 then", "    return (temp[#temp/2] + temp[(#temp/2)+1]) / 2", "  else", "    return temp[math.ceil(#temp/2)]", "  end", "end"
            ]);
            break;
        case "MODE":
            functionName = Blockly.Lua.provideFunction_("math_modes", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t)", "  -- Source: http://lua-users.org/wiki/SimpleStats", "  local counts={}", "  for _, v in ipairs(t) do", "    if counts[v] == nil then",
                "      counts[v] = 1", "    else", "      counts[v] = counts[v] + 1", "    end", "  end", "  local biggestCount = 0", "  for _, v  in pairs(counts) do", "    if v > biggestCount then", "      biggestCount = v", "    end", "  end", "  local temp={}", "  for k, v in pairs(counts) do", "    if v == biggestCount then", "      table.insert(temp, k)", "    end", "  end", "  return temp", "end"
            ]);
            break;
        case "STD_DEV":
            functionName = Blockly.Lua.provideFunction_("math_standard_deviation", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ +
                "(t)", "  local m", "  local vm", "  local total = 0", "  local count = 0", "  local result", "  m = #t == 0 and 0 or " + provideSum() + "(t) / #t", "  for _, v in ipairs(t) do", "    if type(v) == 'number' then", "      vm = v - m", "      total = total + (vm * vm)", "      count = count + 1", "    end", "  end", "  result = math.sqrt(total / (count-1))", "  return result", "end"
            ]);
            break;
        case "RANDOM":
            functionName = Blockly.Lua.provideFunction_("math_random_list", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(t)",
                "  if #t == 0 then", "    return nil", "  end", "  return t[math.random(#t)]", "end"
            ]);
            break;
        default:
            throw Error("Unknown operator: " + func);
    }
    return [functionName + "(" + list + ")", Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["math_modulo"] = function(block) {
    var argument0 = Blockly.Lua.valueToCode(block, "DIVIDEND", Blockly.Lua.ORDER_MULTIPLICATIVE) || "0";
    var argument1 = Blockly.Lua.valueToCode(block, "DIVISOR", Blockly.Lua.ORDER_MULTIPLICATIVE) || "0";
    var code = argument0 + " % " + argument1;
    return [code, Blockly.Lua.ORDER_MULTIPLICATIVE]
};
Blockly.Lua["math_constrain"] = function(block) {
    var argument0 = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_NONE) || "0";
    var argument1 = Blockly.Lua.valueToCode(block, "LOW", Blockly.Lua.ORDER_NONE) || "-math.huge";
    var argument2 = Blockly.Lua.valueToCode(block, "HIGH", Blockly.Lua.ORDER_NONE) || "math.huge";
    var code = "math.min(math.max(" + argument0 + ", " + argument1 + "), " + argument2 + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["math_random_int"] = function(block) {
    var argument0 = Blockly.Lua.valueToCode(block, "FROM", Blockly.Lua.ORDER_NONE) || "0";
    var argument1 = Blockly.Lua.valueToCode(block, "TO", Blockly.Lua.ORDER_NONE) || "0";
    var code = "math.random(" + argument0 + ", " + argument1 + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["math_random_float"] = function(block) {
    return ["math.random()", Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["math_atan2"] = function(block) {
    var argument0 = Blockly.Lua.valueToCode(block, "X", Blockly.Lua.ORDER_NONE) || "0";
    var argument1 = Blockly.Lua.valueToCode(block, "Y", Blockly.Lua.ORDER_NONE) || "0";
    return ["math.deg(math.atan2(" + argument1 + ", " + argument0 + "))", Blockly.Lua.ORDER_HIGH]
};
goog.provide("Blockly.Lua.procedures");
goog.require("Blockly.Lua");
Blockly.Lua["procedures_defreturn"] = function(block) {
    var funcName = Blockly.Lua.variableDB_.getName(block.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE);
    var branch = Blockly.Lua.statementToCode(block, "STACK");
    if (Blockly.Lua.STATEMENT_PREFIX) {
        var id = block.id.replace(/\$/g, "$$$$");
        branch = Blockly.Lua.prefixLines(Blockly.Lua.STATEMENT_PREFIX.replace(/%1/g, "'" + id + "'"), Blockly.Lua.INDENT) + branch
    }
    if (Blockly.Lua.INFINITE_LOOP_TRAP) branch = Blockly.Lua.INFINITE_LOOP_TRAP.replace(/%1/g, "'" + block.id + "'") + branch;
    var returnValue = Blockly.Lua.valueToCode(block, "RETURN", Blockly.Lua.ORDER_NONE) || "";
    if (returnValue) returnValue = Blockly.Lua.INDENT + "return " + returnValue + "\n";
    else if (!branch) branch = "";
    var args = [];
    for (var i = 0; i < block.arguments_.length; i++) args[i] = Blockly.Lua.variableDB_.getName(block.arguments_[i], Blockly.Variables.NAME_TYPE);
    var code = "function " + funcName + "(" + args.join(", ") + ")\n" + branch + returnValue + "end\n";
    code = Blockly.Lua.scrub_(block, code);
    Blockly.Lua.definitions_["%" + funcName] = code;
    return null
};
Blockly.Lua["procedures_defnoreturn"] = Blockly.Lua["procedures_defreturn"];
Blockly.Lua["procedures_callreturn"] = function(block) {
    var funcName = Blockly.Lua.variableDB_.getName(block.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE);
    var args = [];
    for (var i = 0; i < block.arguments_.length; i++) args[i] = Blockly.Lua.valueToCode(block, "ARG" + i, Blockly.Lua.ORDER_NONE) || "nil";
    var code = funcName + "(" + args.join(", ") + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["procedures_callnoreturn"] = function(block) {
    var funcName = Blockly.Lua.variableDB_.getName(block.getFieldValue("NAME"), Blockly.Procedures.NAME_TYPE);
    var args = [];
    for (var i = 0; i < block.arguments_.length; i++) args[i] = Blockly.Lua.valueToCode(block, "ARG" + i, Blockly.Lua.ORDER_NONE) || "nil";
    var code = funcName + "(" + args.join(", ") + ")\n";
    return code
};
Blockly.Lua["procedures_ifreturn"] = function(block) {
    var condition = Blockly.Lua.valueToCode(block, "CONDITION", Blockly.Lua.ORDER_NONE) || "false";
    var code = "if " + condition + " then\n";
    if (block.hasReturnValue_) {
        var value = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_NONE) || "nil";
        code += Blockly.Lua.INDENT + "return " + value + "\n"
    } else code += Blockly.Lua.INDENT + "return\n";
    code += "end\n";
    return code
};
goog.provide("Blockly.Lua.texts");
goog.require("Blockly.Lua");
Blockly.Lua["text"] = function(block) {
    var code = Blockly.Lua.quote_(block.getFieldValue("TEXT"));
    return [code, Blockly.Lua.ORDER_ATOMIC]
};
Blockly.Lua["text_join"] = function(block) {
    if (block.itemCount_ == 0) return ["''", Blockly.Lua.ORDER_ATOMIC];
    else if (block.itemCount_ == 1) {
        var element = Blockly.Lua.valueToCode(block, "ADD0", Blockly.Lua.ORDER_NONE) || "''";
        var code = "tostring(" + element + ")";
        return [code, Blockly.Lua.ORDER_HIGH]
    } else if (block.itemCount_ == 2) {
        var element0 = Blockly.Lua.valueToCode(block, "ADD0", Blockly.Lua.ORDER_CONCATENATION) || "''";
        var element1 = Blockly.Lua.valueToCode(block, "ADD1", Blockly.Lua.ORDER_CONCATENATION) || "''";
        var code = element0 +
            " .. " + element1;
        return [code, Blockly.Lua.ORDER_CONCATENATION]
    } else {
        var elements = [];
        for (var i = 0; i < block.itemCount_; i++) elements[i] = Blockly.Lua.valueToCode(block, "ADD" + i, Blockly.Lua.ORDER_NONE) || "''";
        var code = "table.concat({" + elements.join(", ") + "})";
        return [code, Blockly.Lua.ORDER_HIGH]
    }
};
Blockly.Lua["text_append"] = function(block) {
    var varName = Blockly.Lua.variableDB_.getName(block.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    var value = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_CONCATENATION) || "''";
    return varName + " = " + varName + " .. " + value + "\n"
};
Blockly.Lua["text_length"] = function(block) {
    var text = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_UNARY) || "''";
    return ["#" + text, Blockly.Lua.ORDER_UNARY]
};
Blockly.Lua["text_isEmpty"] = function(block) {
    var text = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_UNARY) || "''";
    return ["#" + text + " == 0", Blockly.Lua.ORDER_RELATIONAL]
};
Blockly.Lua["text_indexOf"] = function(block) {
    var substring = Blockly.Lua.valueToCode(block, "FIND", Blockly.Lua.ORDER_NONE) || "''";
    var text = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_NONE) || "''";
    if (block.getFieldValue("END") == "FIRST") var functionName = Blockly.Lua.provideFunction_("firstIndexOf", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(str, substr) ", "  local i = string.find(str, substr, 1, true)", "  if i == nil then", "    return 0", "  else", "    return i", "  end", "end"]);
    else var functionName =
        Blockly.Lua.provideFunction_("lastIndexOf", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(str, substr)", "  local i = string.find(string.reverse(str), " + "string.reverse(substr), 1, true)", "  if i then", "    return #str + 2 - i - #substr", "  end", "  return 0", "end"]);
    var code = functionName + "(" + text + ", " + substring + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_charAt"] = function(block) {
    var where = block.getFieldValue("WHERE") || "FROM_START";
    var atOrder = where == "FROM_END" ? Blockly.Lua.ORDER_UNARY : Blockly.Lua.ORDER_NONE;
    var at = Blockly.Lua.valueToCode(block, "AT", atOrder) || "1";
    var text = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_NONE) || "''";
    var code;
    if (where == "RANDOM") {
        var functionName = Blockly.Lua.provideFunction_("text_random_letter", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(str)", "  local index = math.random(string.len(str))",
            "  return string.sub(str, index, index)", "end"
        ]);
        code = functionName + "(" + text + ")"
    } else {
        if (where == "FIRST") var start = "1";
        else if (where == "LAST") var start = "-1";
        else if (where == "FROM_START") var start = at;
        else if (where == "FROM_END") var start = "-" + at;
        else throw Error("Unhandled option (text_charAt).");
        if (start.match(/^-?\w*$/)) code = "string.sub(" + text + ", " + start + ", " + start + ")";
        else {
            var functionName = Blockly.Lua.provideFunction_("text_char_at", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(str, index)", "  return string.sub(str, index, index)",
                "end"
            ]);
            code = functionName + "(" + text + ", " + start + ")"
        }
    }
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_getSubstring"] = function(block) {
    var text = Blockly.Lua.valueToCode(block, "STRING", Blockly.Lua.ORDER_NONE) || "''";
    var where1 = block.getFieldValue("WHERE1");
    var at1Order = where1 == "FROM_END" ? Blockly.Lua.ORDER_UNARY : Blockly.Lua.ORDER_NONE;
    var at1 = Blockly.Lua.valueToCode(block, "AT1", at1Order) || "1";
    if (where1 == "FIRST") var start = 1;
    else if (where1 == "FROM_START") var start = at1;
    else if (where1 == "FROM_END") var start = "-" + at1;
    else throw Error("Unhandled option (text_getSubstring)");
    var where2 = block.getFieldValue("WHERE2");
    var at2Order = where2 == "FROM_END" ? Blockly.Lua.ORDER_UNARY : Blockly.Lua.ORDER_NONE;
    var at2 = Blockly.Lua.valueToCode(block, "AT2", at2Order) || "1";
    if (where2 == "LAST") var end = -1;
    else if (where2 == "FROM_START") var end = at2;
    else if (where2 == "FROM_END") var end = "-" + at2;
    else throw Error("Unhandled option (text_getSubstring)");
    var code = "string.sub(" + text + ", " + start + ", " + end + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_changeCase"] = function(block) {
    var operator = block.getFieldValue("CASE");
    var text = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_NONE) || "''";
    if (operator == "UPPERCASE") var functionName = "string.upper";
    else if (operator == "LOWERCASE") var functionName = "string.lower";
    else if (operator == "TITLECASE") var functionName = Blockly.Lua.provideFunction_("text_titlecase", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(str)", "  local buf = {}", "  local inWord = false", "  for i = 1, #str do",
        "    local c = string.sub(str, i, i)", "    if inWord then", "      table.insert(buf, string.lower(c))", '      if string.find(c, "%s") then', "        inWord = false", "      end", "    else", "      table.insert(buf, string.upper(c))", "      inWord = true", "    end", "  end", "  return table.concat(buf)", "end"
    ]);
    var code = functionName + "(" + text + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_trim"] = function(block) {
    var OPERATORS = {
        LEFT: "^%s*(,-)",
        RIGHT: "(.-)%s*$",
        BOTH: "^%s*(.-)%s*$"
    };
    var operator = OPERATORS[block.getFieldValue("MODE")];
    var text = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_NONE) || "''";
    var code = "string.gsub(" + text + ', "' + operator + '", "%1")';
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_print"] = function(block) {
    var msg = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_NONE) || "''";
    return "print(" + msg + ")\n"
};
Blockly.Lua["text_prompt_ext"] = function(block) {
    if (block.getField("TEXT")) var msg = Blockly.Lua.quote_(block.getFieldValue("TEXT"));
    else var msg = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_NONE) || "''";
    var functionName = Blockly.Lua.provideFunction_("text_prompt", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(msg)", "  io.write(msg)", "  io.flush()", "  return io.read()", "end"]);
    var code = functionName + "(" + msg + ")";
    var toNumber = block.getFieldValue("TYPE") == "NUMBER";
    if (toNumber) code = "tonumber(" +
        code + ", 10)";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_prompt"] = Blockly.Lua["text_prompt_ext"];
Blockly.Lua["text_count"] = function(block) {
    var text = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_NONE) || "''";
    var sub = Blockly.Lua.valueToCode(block, "SUB", Blockly.Lua.ORDER_NONE) || "''";
    var functionName = Blockly.Lua.provideFunction_("text_count", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle)", "  if #needle == 0 then", "    return #haystack + 1", "  end", "  local i = 1", "  local count = 0", "  while true do", "    i = string.find(haystack, needle, i, true)", "    if i == nil then",
        "      break", "    end", "    count = count + 1", "    i = i + #needle", "  end", "  return count", "end"
    ]);
    var code = functionName + "(" + text + ", " + sub + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_replace"] = function(block) {
    var text = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_NONE) || "''";
    var from = Blockly.Lua.valueToCode(block, "FROM", Blockly.Lua.ORDER_NONE) || "''";
    var to = Blockly.Lua.valueToCode(block, "TO", Blockly.Lua.ORDER_NONE) || "''";
    var functionName = Blockly.Lua.provideFunction_("text_replace", ["function " + Blockly.Lua.FUNCTION_NAME_PLACEHOLDER_ + "(haystack, needle, replacement)", "  local buf = {}", "  local i = 1", "  while i <= #haystack do", "    if string.sub(haystack, i, i + #needle - 1) == needle then",
        "      for j = 1, #replacement do", "        table.insert(buf, string.sub(replacement, j, j))", "      end", "      i = i + #needle", "    else", "      table.insert(buf, string.sub(haystack, i, i))", "      i = i + 1", "    end", "  end", "  return table.concat(buf)", "end"
    ]);
    var code = functionName + "(" + text + ", " + from + ", " + to + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
Blockly.Lua["text_reverse"] = function(block) {
    var text = Blockly.Lua.valueToCode(block, "TEXT", Blockly.Lua.ORDER_HIGH) || "''";
    var code = "string.reverse(" + text + ")";
    return [code, Blockly.Lua.ORDER_HIGH]
};
goog.provide("Blockly.Lua.variables");
goog.require("Blockly.Lua");
Blockly.Lua["variables_get"] = function(block) {
    var code = Blockly.Lua.variableDB_.getName(block.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    return [code, Blockly.Lua.ORDER_ATOMIC]
};
Blockly.Lua["variables_set"] = function(block) {
    var argument0 = Blockly.Lua.valueToCode(block, "VALUE", Blockly.Lua.ORDER_NONE) || "0";
    var varName = Blockly.Lua.variableDB_.getName(block.getFieldValue("VAR"), Blockly.Variables.NAME_TYPE);
    return varName + " = " + argument0 + "\n"
};
goog.provide("Blockly.Lua.variablesDynamic");
goog.require("Blockly.Lua");
goog.require("Blockly.Lua.variables");
Blockly.Lua["variables_get_dynamic"] = Blockly.Lua["variables_get"];
Blockly.Lua["variables_set_dynamic"] = Blockly.Lua["variables_set"];